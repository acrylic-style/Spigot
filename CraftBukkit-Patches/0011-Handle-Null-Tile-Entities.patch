From 0a9b2dfed1c8cdfc29f9974b04f0975b9fed4c02 Mon Sep 17 00:00:00 2001
From: md_5 <md_5@live.com.au>
Date: Sun, 3 Feb 2013 09:20:19 +1100
Subject: [PATCH] Handle Null Tile Entities


diff --git a/src/main/java/net/minecraft/server/World.java b/src/main/java/net/minecraft/server/World.java
new file mode 100644
index 00000000..10fb0a41
--- /dev/null
+++ b/src/main/java/net/minecraft/server/World.java
@@ -0,0 +1,1060 @@
+package net.minecraft.server;
+
+import com.google.common.collect.Lists;
+import com.mojang.serialization.Codec;
+import java.io.IOException;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Random;
+import java.util.function.Consumer;
+import java.util.function.Predicate;
+import java.util.function.Supplier;
+import javax.annotation.Nullable;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+
+// CraftBukkit start
+import java.util.HashMap;
+import java.util.Map;
+import org.bukkit.Bukkit;
+import org.bukkit.craftbukkit.SpigotTimings; // Spigot
+import org.bukkit.craftbukkit.CraftServer;
+import org.bukkit.craftbukkit.CraftWorld;
+import org.bukkit.craftbukkit.block.CapturedBlockState;
+import org.bukkit.craftbukkit.block.data.CraftBlockData;
+import org.bukkit.event.block.BlockPhysicsEvent;
+// CraftBukkit end
+
+public abstract class World implements GeneratorAccess, AutoCloseable {
+
+    protected static final Logger LOGGER = LogManager.getLogger();
+    public static final Codec<ResourceKey<World>> e = MinecraftKey.a.xmap(ResourceKey.b(IRegistry.Q), ResourceKey::a);
+    public static final ResourceKey<World> OVERWORLD = ResourceKey.a(IRegistry.Q, new MinecraftKey("overworld"));
+    public static final ResourceKey<World> THE_NETHER = ResourceKey.a(IRegistry.Q, new MinecraftKey("the_nether"));
+    public static final ResourceKey<World> THE_END = ResourceKey.a(IRegistry.Q, new MinecraftKey("the_end"));
+    private static final EnumDirection[] a = EnumDirection.values();
+    protected final List<ITickable> tileEntityList = Lists.newArrayList();
+    private final List<ITickable> tileEntityListPending = Lists.newArrayList();
+    private boolean tickingTileEntities;
+    public final Thread serverThread;
+    private final boolean debugWorld;
+    private int u;
+    protected int j = (new Random()).nextInt();
+    protected final int k = 1013904223;
+    protected float lastRainLevel;
+    protected float rainLevel;
+    protected float lastThunderLevel;
+    protected float thunderLevel;
+    public final Random random = new Random();
+    private final DimensionManager v;
+    public final WorldDataMutable worldData;
+    private final Supplier<GameProfilerFiller> methodProfiler;
+    public final boolean isClientSide;
+    private final WorldBorder worldBorder;
+    private final BiomeManager biomeManager;
+    private final ResourceKey<World> dimensionKey;
+
+    // CraftBukkit start Added the following
+    private final ResourceKey<DimensionManager> typeKey;
+    private final CraftWorld world;
+    public boolean pvpMode;
+    public boolean keepSpawnInMemory = true;
+    public org.bukkit.generator.ChunkGenerator generator;
+
+    public boolean captureBlockStates = false;
+    public boolean captureTreeGeneration = false;
+    public Map<BlockPosition, CapturedBlockState> capturedBlockStates = new java.util.LinkedHashMap<>();
+    public Map<BlockPosition, TileEntity> capturedTileEntities = new HashMap<>();
+    public List<EntityItem> captureDrops;
+    public long ticksPerAnimalSpawns;
+    public long ticksPerMonsterSpawns;
+    public long ticksPerWaterSpawns;
+    public long ticksPerWaterAmbientSpawns;
+    public long ticksPerAmbientSpawns;
+    public boolean populating;
+    public final org.spigotmc.SpigotWorldConfig spigotConfig; // Spigot
+
+    public final SpigotTimings.WorldTimingsHandler timings; // Spigot
+
+    public CraftWorld getWorld() {
+        return this.world;
+    }
+
+    public CraftServer getServer() {
+        return (CraftServer) Bukkit.getServer();
+    }
+
+    public ResourceKey<DimensionManager> getTypeKey() {
+        return typeKey;
+    }
+
+    protected World(WorldDataMutable worlddatamutable, ResourceKey<World> resourcekey, final DimensionManager dimensionmanager, Supplier<GameProfilerFiller> supplier, boolean flag, boolean flag1, long i, org.bukkit.generator.ChunkGenerator gen, org.bukkit.World.Environment env) {
+        this.spigotConfig = new org.spigotmc.SpigotWorldConfig(((WorldDataServer) worlddatamutable).getName()); // Spigot
+        this.generator = gen;
+        this.world = new CraftWorld((WorldServer) this, gen, env);
+        this.ticksPerAnimalSpawns = this.getServer().getTicksPerAnimalSpawns(); // CraftBukkit
+        this.ticksPerMonsterSpawns = this.getServer().getTicksPerMonsterSpawns(); // CraftBukkit
+        this.ticksPerWaterSpawns = this.getServer().getTicksPerWaterSpawns(); // CraftBukkit
+        this.ticksPerWaterAmbientSpawns = this.getServer().getTicksPerWaterAmbientSpawns(); // CraftBukkit
+        this.ticksPerAmbientSpawns = this.getServer().getTicksPerAmbientSpawns(); // CraftBukkit
+        this.typeKey = (ResourceKey) this.getServer().getHandle().getServer().customRegistry.b(IRegistry.P).c(dimensionmanager).orElseThrow(() -> {
+            return new IllegalStateException("Unregistered dimension type: " + dimensionmanager);
+        });
+        // CraftBukkit end
+        this.methodProfiler = supplier;
+        this.worldData = worlddatamutable;
+        this.v = dimensionmanager;
+        this.dimensionKey = resourcekey;
+        this.isClientSide = flag;
+        if (dimensionmanager.getCoordinateScale() != 1.0D) {
+            this.worldBorder = new WorldBorder() {
+                @Override
+                public double getCenterX() {
+                    return super.getCenterX(); // CraftBukkit
+                }
+
+                @Override
+                public double getCenterZ() {
+                    return super.getCenterZ(); // CraftBukkit
+                }
+            };
+        } else {
+            this.worldBorder = new WorldBorder();
+        }
+
+        this.serverThread = Thread.currentThread();
+        this.biomeManager = new BiomeManager(this, i, dimensionmanager.getGenLayerZoomer());
+        this.debugWorld = flag1;
+        // CraftBukkit start
+        getWorldBorder().world = (WorldServer) this;
+        // From PlayerList.setPlayerFileData
+        getWorldBorder().a(new IWorldBorderListener() {
+            public void a(WorldBorder worldborder, double d0) {
+                getServer().getHandle().sendAll(new PacketPlayOutWorldBorder(worldborder, PacketPlayOutWorldBorder.EnumWorldBorderAction.SET_SIZE), worldborder.world);
+            }
+
+            public void a(WorldBorder worldborder, double d0, double d1, long i) {
+                getServer().getHandle().sendAll(new PacketPlayOutWorldBorder(worldborder, PacketPlayOutWorldBorder.EnumWorldBorderAction.LERP_SIZE), worldborder.world);
+            }
+
+            public void a(WorldBorder worldborder, double d0, double d1) {
+                getServer().getHandle().sendAll(new PacketPlayOutWorldBorder(worldborder, PacketPlayOutWorldBorder.EnumWorldBorderAction.SET_CENTER), worldborder.world);
+            }
+
+            public void a(WorldBorder worldborder, int i) {
+                getServer().getHandle().sendAll(new PacketPlayOutWorldBorder(worldborder, PacketPlayOutWorldBorder.EnumWorldBorderAction.SET_WARNING_TIME), worldborder.world);
+            }
+
+            public void b(WorldBorder worldborder, int i) {
+                getServer().getHandle().sendAll(new PacketPlayOutWorldBorder(worldborder, PacketPlayOutWorldBorder.EnumWorldBorderAction.SET_WARNING_BLOCKS), worldborder.world);
+            }
+
+            public void b(WorldBorder worldborder, double d0) {}
+
+            public void c(WorldBorder worldborder, double d0) {}
+        });
+        // CraftBukkit end
+        timings = new SpigotTimings.WorldTimingsHandler(this); // Spigot - code below can generate new world and access timings
+    }
+
+    @Override
+    public boolean g() {
+        return this.isClientSide;
+    }
+
+    @Nullable
+    public MinecraftServer getMinecraftServer() {
+        return null;
+    }
+
+    public boolean isValidLocation(BlockPosition blockposition) {
+        return !this.isOutsideWorld(blockposition) && C(blockposition);
+    }
+
+    public static boolean j(BlockPosition blockposition) {
+        return !b(blockposition.getY()) && C(blockposition);
+    }
+
+    private static boolean C(BlockPosition blockposition) {
+        return blockposition.getX() >= -30000000 && blockposition.getZ() >= -30000000 && blockposition.getX() < 30000000 && blockposition.getZ() < 30000000;
+    }
+
+    private static boolean b(int i) {
+        return i < -20000000 || i >= 20000000;
+    }
+
+    public Chunk getChunkAtWorldCoords(BlockPosition blockposition) {
+        return this.getChunkAt(SectionPosition.a(blockposition.getX()), SectionPosition.a(blockposition.getZ()));
+    }
+
+    @Override
+    public Chunk getChunkAt(int i, int j) {
+        return (Chunk) this.getChunkAt(i, j, ChunkStatus.FULL);
+    }
+
+    @Override
+    public IChunkAccess getChunkAt(int i, int j, ChunkStatus chunkstatus, boolean flag) {
+        IChunkAccess ichunkaccess = this.getChunkProvider().getChunkAt(i, j, chunkstatus, flag);
+
+        if (ichunkaccess == null && flag) {
+            throw new IllegalStateException("Should always be able to create a chunk!");
+        } else {
+            return ichunkaccess;
+        }
+    }
+
+    @Override
+    public boolean setTypeAndData(BlockPosition blockposition, IBlockData iblockdata, int i) {
+        return this.a(blockposition, iblockdata, i, 512);
+    }
+
+    @Override
+    public boolean a(BlockPosition blockposition, IBlockData iblockdata, int i, int j) {
+        // CraftBukkit start - tree generation
+        if (this.captureTreeGeneration) {
+            CapturedBlockState blockstate = capturedBlockStates.get(blockposition);
+            if (blockstate == null) {
+                blockstate = CapturedBlockState.getTreeBlockState(this, blockposition, i);
+                this.capturedBlockStates.put(blockposition.immutableCopy(), blockstate);
+            }
+            blockstate.setData(iblockdata);
+            return true;
+        }
+        // CraftBukkit end
+        if (this.isOutsideWorld(blockposition)) {
+            return false;
+        } else if (!this.isClientSide && this.isDebugWorld()) {
+            return false;
+        } else {
+            Chunk chunk = this.getChunkAtWorldCoords(blockposition);
+            Block block = iblockdata.getBlock();
+
+            // CraftBukkit start - capture blockstates
+            boolean captured = false;
+            if (this.captureBlockStates && !this.capturedBlockStates.containsKey(blockposition)) {
+                CapturedBlockState blockstate = CapturedBlockState.getBlockState(this, blockposition, i);
+                this.capturedBlockStates.put(blockposition.immutableCopy(), blockstate);
+                captured = true;
+            }
+            // CraftBukkit end
+
+            IBlockData iblockdata1 = chunk.setType(blockposition, iblockdata, (i & 64) != 0, (i & 1024) == 0); // CraftBukkit custom NO_PLACE flag
+
+            if (iblockdata1 == null) {
+                // CraftBukkit start - remove blockstate if failed (or the same)
+                if (this.captureBlockStates && captured) {
+                    this.capturedBlockStates.remove(blockposition);
+                }
+                // CraftBukkit end
+                return false;
+            } else {
+                IBlockData iblockdata2 = this.getType(blockposition);
+
+                if ((i & 128) == 0 && iblockdata2 != iblockdata1 && (iblockdata2.b((IBlockAccess) this, blockposition) != iblockdata1.b((IBlockAccess) this, blockposition) || iblockdata2.f() != iblockdata1.f() || iblockdata2.e() || iblockdata1.e())) {
+                    this.getMethodProfiler().enter("queueCheckLight");
+                    this.getChunkProvider().getLightEngine().a(blockposition);
+                    this.getMethodProfiler().exit();
+                }
+
+                /*
+                if (iblockdata2 == iblockdata) {
+                    if (iblockdata1 != iblockdata2) {
+                        this.b(blockposition, iblockdata1, iblockdata2);
+                    }
+
+                    if ((i & 2) != 0 && (!this.isClientSide || (i & 4) == 0) && (this.isClientSide || chunk.getState() != null && chunk.getState().isAtLeast(PlayerChunk.State.TICKING))) {
+                        this.notify(blockposition, iblockdata1, iblockdata, i);
+                    }
+
+                    if ((i & 1) != 0) {
+                        this.update(blockposition, iblockdata1.getBlock());
+                        if (!this.isClientSide && iblockdata.isComplexRedstone()) {
+                            this.updateAdjacentComparators(blockposition, block);
+                        }
+                    }
+
+                    if ((i & 16) == 0 && j > 0) {
+                        int k = i & -34;
+
+                        iblockdata1.b(this, blockposition, k, j - 1);
+                        iblockdata.a((GeneratorAccess) this, blockposition, k, j - 1);
+                        iblockdata.b(this, blockposition, k, j - 1);
+                    }
+
+                    this.a(blockposition, iblockdata1, iblockdata2);
+                }
+                */
+
+                // CraftBukkit start
+                if (!this.captureBlockStates) { // Don't notify clients or update physics while capturing blockstates
+                    // Modularize client and physic updates
+                    notifyAndUpdatePhysics(blockposition, chunk, iblockdata1, iblockdata, iblockdata2, i, j);
+                }
+                // CraftBukkit end
+
+                return true;
+            }
+        }
+    }
+
+    // CraftBukkit start - Split off from above in order to directly send client and physic updates
+    public void notifyAndUpdatePhysics(BlockPosition blockposition, Chunk chunk, IBlockData oldBlock, IBlockData newBlock, IBlockData actualBlock, int i, int j) {
+        IBlockData iblockdata = newBlock;
+        IBlockData iblockdata1 = oldBlock;
+        IBlockData iblockdata2 = actualBlock;
+        if (iblockdata2 == iblockdata) {
+            if (iblockdata1 != iblockdata2) {
+                this.b(blockposition, iblockdata1, iblockdata2);
+            }
+
+            if ((i & 2) != 0 && (!this.isClientSide || (i & 4) == 0) && (this.isClientSide || chunk == null || (chunk.getState() != null && chunk.getState().isAtLeast(PlayerChunk.State.TICKING)))) { // allow chunk to be null here as chunk.isReady() is false when we send our notification during block placement
+                this.notify(blockposition, iblockdata1, iblockdata, i);
+            }
+
+            if ((i & 1) != 0) {
+                this.update(blockposition, iblockdata1.getBlock());
+                if (!this.isClientSide && iblockdata.isComplexRedstone()) {
+                    this.updateAdjacentComparators(blockposition, newBlock.getBlock());
+                }
+            }
+
+            if ((i & 16) == 0 && j > 0) {
+                int k = i & -34;
+
+                // CraftBukkit start
+                iblockdata1.b(this, blockposition, k, j - 1); // Don't call an event for the old block to limit event spam
+                CraftWorld world = ((WorldServer) this).getWorld();
+                if (world != null) {
+                    BlockPhysicsEvent event = new BlockPhysicsEvent(world.getBlockAt(blockposition.getX(), blockposition.getY(), blockposition.getZ()), CraftBlockData.fromData(iblockdata));
+                    this.getServer().getPluginManager().callEvent(event);
+
+                    if (event.isCancelled()) {
+                        return;
+                    }
+                }
+                // CraftBukkit end
+                iblockdata.a((GeneratorAccess) this, blockposition, k, j - 1);
+                iblockdata.b(this, blockposition, k, j - 1);
+            }
+
+            this.a(blockposition, iblockdata1, iblockdata2);
+        }
+    }
+    // CraftBukkit end
+
+    public void a(BlockPosition blockposition, IBlockData iblockdata, IBlockData iblockdata1) {}
+
+    @Override
+    public boolean a(BlockPosition blockposition, boolean flag) {
+        Fluid fluid = this.getFluid(blockposition);
+
+        return this.setTypeAndData(blockposition, fluid.getBlockData(), 3 | (flag ? 64 : 0));
+    }
+
+    @Override
+    public boolean a(BlockPosition blockposition, boolean flag, @Nullable Entity entity, int i) {
+        IBlockData iblockdata = this.getType(blockposition);
+
+        if (iblockdata.isAir()) {
+            return false;
+        } else {
+            Fluid fluid = this.getFluid(blockposition);
+
+            if (!(iblockdata.getBlock() instanceof BlockFireAbstract)) {
+                this.triggerEffect(2001, blockposition, Block.getCombinedId(iblockdata));
+            }
+
+            if (flag) {
+                TileEntity tileentity = iblockdata.isTileEntity() ? this.getTileEntity(blockposition) : null;
+
+                Block.dropItems(iblockdata, this, blockposition, tileentity, entity, ItemStack.b);
+            }
+
+            boolean flag1 = this.a(blockposition, fluid.getBlockData(), 3, i);
+
+            if (flag1) {
+                this.a(entity, ckz.k, blockposition);
+            }
+
+            return flag1;
+        }
+    }
+
+    public void a(BlockPosition blockposition, IBlockData iblockdata) {}
+
+    public boolean setTypeUpdate(BlockPosition blockposition, IBlockData iblockdata) {
+        return this.setTypeAndData(blockposition, iblockdata, 3);
+    }
+
+    public abstract void notify(BlockPosition blockposition, IBlockData iblockdata, IBlockData iblockdata1, int i);
+
+    public void b(BlockPosition blockposition, IBlockData iblockdata, IBlockData iblockdata1) {}
+
+    public void applyPhysics(BlockPosition blockposition, Block block) {
+        this.a(blockposition.west(), block, blockposition);
+        this.a(blockposition.east(), block, blockposition);
+        this.a(blockposition.down(), block, blockposition);
+        this.a(blockposition.up(), block, blockposition);
+        this.a(blockposition.north(), block, blockposition);
+        this.a(blockposition.south(), block, blockposition);
+    }
+
+    public void a(BlockPosition blockposition, Block block, EnumDirection enumdirection) {
+        if (enumdirection != EnumDirection.WEST) {
+            this.a(blockposition.west(), block, blockposition);
+        }
+
+        if (enumdirection != EnumDirection.EAST) {
+            this.a(blockposition.east(), block, blockposition);
+        }
+
+        if (enumdirection != EnumDirection.DOWN) {
+            this.a(blockposition.down(), block, blockposition);
+        }
+
+        if (enumdirection != EnumDirection.UP) {
+            this.a(blockposition.up(), block, blockposition);
+        }
+
+        if (enumdirection != EnumDirection.NORTH) {
+            this.a(blockposition.north(), block, blockposition);
+        }
+
+        if (enumdirection != EnumDirection.SOUTH) {
+            this.a(blockposition.south(), block, blockposition);
+        }
+
+    }
+
+    public void a(BlockPosition blockposition, Block block, BlockPosition blockposition1) {
+        if (!this.isClientSide) {
+            IBlockData iblockdata = this.getType(blockposition);
+
+            try {
+                // CraftBukkit start
+                CraftWorld world = ((WorldServer) this).getWorld();
+                if (world != null) {
+                    BlockPhysicsEvent event = new BlockPhysicsEvent(world.getBlockAt(blockposition.getX(), blockposition.getY(), blockposition.getZ()), CraftBlockData.fromData(iblockdata), world.getBlockAt(blockposition1.getX(), blockposition1.getY(), blockposition1.getZ()));
+                    this.getServer().getPluginManager().callEvent(event);
+
+                    if (event.isCancelled()) {
+                        return;
+                    }
+                }
+                // CraftBukkit end
+                iblockdata.doPhysics(this, blockposition, block, blockposition1, false);
+            } catch (Throwable throwable) {
+                CrashReport crashreport = CrashReport.a(throwable, "Exception while updating neighbours");
+                CrashReportSystemDetails crashreportsystemdetails = crashreport.a("Block being updated");
+
+                crashreportsystemdetails.a("Source block type", () -> {
+                    try {
+                        return String.format("ID #%s (%s // %s)", IRegistry.BLOCK.getKey(block), block.h(), block.getClass().getCanonicalName());
+                    } catch (Throwable throwable1) {
+                        return "ID #" + IRegistry.BLOCK.getKey(block);
+                    }
+                });
+                CrashReportSystemDetails.a(crashreportsystemdetails, this, blockposition, iblockdata);
+                throw new ReportedException(crashreport);
+            }
+        }
+    }
+
+    @Override
+    public int a(HeightMap.Type heightmap_type, int i, int j) {
+        int k;
+
+        if (i >= -30000000 && j >= -30000000 && i < 30000000 && j < 30000000) {
+            if (this.isChunkLoaded(SectionPosition.a(i), SectionPosition.a(j))) {
+                k = this.getChunkAt(SectionPosition.a(i), SectionPosition.a(j)).getHighestBlock(heightmap_type, i & 15, j & 15) + 1;
+            } else {
+                k = this.getMinBuildHeight();
+            }
+        } else {
+            k = this.getSeaLevel() + 1;
+        }
+
+        return k;
+    }
+
+    @Override
+    public LightEngine e() {
+        return this.getChunkProvider().getLightEngine();
+    }
+
+    @Override
+    public IBlockData getType(BlockPosition blockposition) {
+        // CraftBukkit start - tree generation
+        if (captureTreeGeneration) {
+            CapturedBlockState previous = capturedBlockStates.get(blockposition);
+            if (previous != null) {
+                return previous.getHandle();
+            }
+        }
+        // CraftBukkit end
+        if (this.isOutsideWorld(blockposition)) {
+            return Blocks.VOID_AIR.getBlockData();
+        } else {
+            Chunk chunk = this.getChunkAt(SectionPosition.a(blockposition.getX()), SectionPosition.a(blockposition.getZ()));
+
+            return chunk.getType(blockposition);
+        }
+    }
+
+    @Override
+    public Fluid getFluid(BlockPosition blockposition) {
+        if (this.isOutsideWorld(blockposition)) {
+            return FluidTypes.EMPTY.h();
+        } else {
+            Chunk chunk = this.getChunkAtWorldCoords(blockposition);
+
+            return chunk.getFluid(blockposition);
+        }
+    }
+
+    public boolean isDay() {
+        return !this.getDimensionManager().isFixedTime() && this.u < 4;
+    }
+
+    public boolean isNight() {
+        return !this.getDimensionManager().isFixedTime() && !this.isDay();
+    }
+
+    @Override
+    public void playSound(@Nullable EntityHuman entityhuman, BlockPosition blockposition, SoundEffect soundeffect, SoundCategory soundcategory, float f, float f1) {
+        this.playSound(entityhuman, (double) blockposition.getX() + 0.5D, (double) blockposition.getY() + 0.5D, (double) blockposition.getZ() + 0.5D, soundeffect, soundcategory, f, f1);
+    }
+
+    public abstract void playSound(@Nullable EntityHuman entityhuman, double d0, double d1, double d2, SoundEffect soundeffect, SoundCategory soundcategory, float f, float f1);
+
+    public abstract void playSound(@Nullable EntityHuman entityhuman, Entity entity, SoundEffect soundeffect, SoundCategory soundcategory, float f, float f1);
+
+    public void a(double d0, double d1, double d2, SoundEffect soundeffect, SoundCategory soundcategory, float f, float f1, boolean flag) {}
+
+    @Override
+    public void addParticle(ParticleParam particleparam, double d0, double d1, double d2, double d3, double d4, double d5) {}
+
+    public void b(ParticleParam particleparam, double d0, double d1, double d2, double d3, double d4, double d5) {}
+
+    public void b(ParticleParam particleparam, boolean flag, double d0, double d1, double d2, double d3, double d4, double d5) {}
+
+    public float a(float f) {
+        float f1 = this.f(f);
+
+        return f1 * 6.2831855F;
+    }
+
+    public void a(ITickable itickable) {
+        (this.tickingTileEntities ? this.tileEntityListPending : this.tileEntityList).add(itickable);
+    }
+
+    protected void tickBlockEntities() {
+        GameProfilerFiller gameprofilerfiller = this.getMethodProfiler();
+
+        gameprofilerfiller.enter("blockEntities");
+        timings.tileEntityTick.startTiming(); // Spigot
+        this.tickingTileEntities = true;
+        if (!this.tileEntityListPending.isEmpty()) {
+            this.tileEntityList.addAll(this.tileEntityListPending);
+            this.tileEntityListPending.clear();
+        }
+
+        Iterator iterator = this.tileEntityList.iterator();
+
+        while (iterator.hasNext()) {
+            ITickable itickable = (ITickable) iterator.next();
+
+            if (itickable == null || itickable.b()) { // Spigot
+                iterator.remove();
+            } else {
+                itickable.a();
+            }
+        }
+
+        this.tickingTileEntities = false;
+        gameprofilerfiller.exit();
+        timings.tileEntityTick.stopTiming(); // Spigot
+    }
+
+    public <T extends Entity> void a(Consumer<T> consumer, T t0) {
+        try {
+            SpigotTimings.tickEntityTimer.startTiming(); // Spigot
+            consumer.accept(t0);
+            SpigotTimings.tickEntityTimer.stopTiming(); // Spigot
+        } catch (Throwable throwable) {
+            CrashReport crashreport = CrashReport.a(throwable, "Ticking entity");
+            CrashReportSystemDetails crashreportsystemdetails = crashreport.a("Entity being ticked");
+
+            t0.appendEntityCrashDetails(crashreportsystemdetails);
+            throw new ReportedException(crashreport);
+        }
+    }
+
+    public Explosion explode(@Nullable Entity entity, double d0, double d1, double d2, float f, Explosion.Effect explosion_effect) {
+        return this.createExplosion(entity, (DamageSource) null, (ExplosionDamageCalculator) null, d0, d1, d2, f, false, explosion_effect);
+    }
+
+    public Explosion createExplosion(@Nullable Entity entity, double d0, double d1, double d2, float f, boolean flag, Explosion.Effect explosion_effect) {
+        return this.createExplosion(entity, (DamageSource) null, (ExplosionDamageCalculator) null, d0, d1, d2, f, flag, explosion_effect);
+    }
+
+    public Explosion createExplosion(@Nullable Entity entity, @Nullable DamageSource damagesource, @Nullable ExplosionDamageCalculator explosiondamagecalculator, double d0, double d1, double d2, float f, boolean flag, Explosion.Effect explosion_effect) {
+        Explosion explosion = new Explosion(this, entity, damagesource, explosiondamagecalculator, d0, d1, d2, f, flag, explosion_effect);
+
+        explosion.a();
+        explosion.a(true);
+        return explosion;
+    }
+
+    @Nullable
+    @Override
+    public TileEntity getTileEntity(BlockPosition blockposition) {
+        // CraftBukkit start
+        return getTileEntity(blockposition, true);
+    }
+
+    @Nullable
+    protected TileEntity getTileEntity(BlockPosition blockposition, boolean validate) {
+        // CraftBukkit end
+        return this.isOutsideWorld(blockposition) ? null : (!this.isClientSide && Thread.currentThread() != this.serverThread ? null : this.getChunkAtWorldCoords(blockposition).a(blockposition, Chunk.b.a));
+    }
+
+    public void a(TileEntity tileentity) {
+        BlockPosition blockposition = tileentity.getPosition();
+
+        if (!this.isOutsideWorld(blockposition)) {
+            this.getChunkAtWorldCoords(blockposition).b(tileentity);
+        }
+    }
+
+    public void l(BlockPosition blockposition) {
+        if (!this.isOutsideWorld(blockposition)) {
+            this.getChunkAtWorldCoords(blockposition).removeTileEntity(blockposition);
+        }
+    }
+
+    public boolean m(BlockPosition blockposition) {
+        return this.isOutsideWorld(blockposition) ? false : this.getChunkProvider().b(SectionPosition.a(blockposition.getX()), SectionPosition.a(blockposition.getZ()));
+    }
+
+    public boolean a(BlockPosition blockposition, Entity entity, EnumDirection enumdirection) {
+        if (this.isOutsideWorld(blockposition)) {
+            return false;
+        } else {
+            IChunkAccess ichunkaccess = this.getChunkAt(SectionPosition.a(blockposition.getX()), SectionPosition.a(blockposition.getZ()), ChunkStatus.FULL, false);
+
+            return ichunkaccess == null ? false : ichunkaccess.getType(blockposition).a((IBlockAccess) this, blockposition, entity, enumdirection);
+        }
+    }
+
+    public boolean a(BlockPosition blockposition, Entity entity) {
+        return this.a(blockposition, entity, EnumDirection.UP);
+    }
+
+    public void S() {
+        double d0 = 1.0D - (double) (this.d(1.0F) * 5.0F) / 16.0D;
+        double d1 = 1.0D - (double) (this.b(1.0F) * 5.0F) / 16.0D;
+        double d2 = 0.5D + 2.0D * MathHelper.a((double) MathHelper.cos(this.f(1.0F) * 6.2831855F), -0.25D, 0.25D);
+
+        this.u = (int) ((1.0D - d2 * d0 * d1) * 11.0D);
+    }
+
+    public void setSpawnFlags(boolean flag, boolean flag1) {
+        this.getChunkProvider().a(flag, flag1);
+    }
+
+    protected void T() {
+        if (this.worldData.hasStorm()) {
+            this.rainLevel = 1.0F;
+            if (this.worldData.isThundering()) {
+                this.thunderLevel = 1.0F;
+            }
+        }
+
+    }
+
+    public void close() throws IOException {
+        this.getChunkProvider().close();
+    }
+
+    @Nullable
+    @Override
+    public IBlockAccess c(int i, int j) {
+        return this.getChunkAt(i, j, ChunkStatus.FULL, false);
+    }
+
+    @Override
+    public List<Entity> getEntities(@Nullable Entity entity, AxisAlignedBB axisalignedbb, Predicate<? super Entity> predicate) {
+        this.getMethodProfiler().c("getEntities");
+        List<Entity> list = Lists.newArrayList();
+
+        this.getEntities().a(axisalignedbb, (entity1) -> {
+            if (entity1 != entity && predicate.test(entity1)) {
+                list.add(entity1);
+            }
+
+            if (entity1 instanceof EntityEnderDragon) {
+                EntityComplexPart[] aentitycomplexpart = ((EntityEnderDragon) entity1).fe();
+                int i = aentitycomplexpart.length;
+
+                for (int j = 0; j < i; ++j) {
+                    EntityComplexPart entitycomplexpart = aentitycomplexpart[j];
+
+                    if (entity1 != entity && predicate.test(entitycomplexpart)) {
+                        list.add(entitycomplexpart);
+                    }
+                }
+            }
+
+        });
+        return list;
+    }
+
+    @Override
+    public <T extends Entity> List<T> a(EntityTypeTest<Entity, T> entitytypetest, AxisAlignedBB axisalignedbb, Predicate<? super T> predicate) {
+        this.getMethodProfiler().c("getEntities");
+        List<T> list = Lists.newArrayList();
+
+        this.getEntities().a(entitytypetest, axisalignedbb, (entity) -> {
+            if (predicate.test(entity)) {
+                list.add(entity);
+            }
+
+            if (entity instanceof EntityEnderDragon) {
+                EntityComplexPart[] aentitycomplexpart = ((EntityEnderDragon) entity).fe();
+                int i = aentitycomplexpart.length;
+
+                for (int j = 0; j < i; ++j) {
+                    EntityComplexPart entitycomplexpart = aentitycomplexpart[j];
+                    T t0 = entitytypetest.a(entitycomplexpart); // CraftBukkit - decompile fix
+
+                    if (t0 != null && predicate.test(t0)) {
+                        list.add(t0);
+                    }
+                }
+            }
+
+        });
+        return list;
+    }
+
+    @Nullable
+    public abstract Entity getEntity(int i);
+
+    public void removeTileEntity(BlockPosition blockposition) {
+        if (this.isLoaded(blockposition)) {
+            this.getChunkAtWorldCoords(blockposition).markDirty();
+        }
+
+    }
+
+    @Override
+    public int getSeaLevel() {
+        return 63;
+    }
+
+    public int getBlockPower(BlockPosition blockposition) {
+        byte b0 = 0;
+        int i = Math.max(b0, this.c(blockposition.down(), EnumDirection.DOWN));
+
+        if (i >= 15) {
+            return i;
+        } else {
+            i = Math.max(i, this.c(blockposition.up(), EnumDirection.UP));
+            if (i >= 15) {
+                return i;
+            } else {
+                i = Math.max(i, this.c(blockposition.north(), EnumDirection.NORTH));
+                if (i >= 15) {
+                    return i;
+                } else {
+                    i = Math.max(i, this.c(blockposition.south(), EnumDirection.SOUTH));
+                    if (i >= 15) {
+                        return i;
+                    } else {
+                        i = Math.max(i, this.c(blockposition.west(), EnumDirection.WEST));
+                        if (i >= 15) {
+                            return i;
+                        } else {
+                            i = Math.max(i, this.c(blockposition.east(), EnumDirection.EAST));
+                            return i >= 15 ? i : i;
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+    public boolean isBlockFacePowered(BlockPosition blockposition, EnumDirection enumdirection) {
+        return this.getBlockFacePower(blockposition, enumdirection) > 0;
+    }
+
+    public int getBlockFacePower(BlockPosition blockposition, EnumDirection enumdirection) {
+        IBlockData iblockdata = this.getType(blockposition);
+        int i = iblockdata.b((IBlockAccess) this, blockposition, enumdirection);
+
+        return iblockdata.isOccluding(this, blockposition) ? Math.max(i, this.getBlockPower(blockposition)) : i;
+    }
+
+    public boolean isBlockIndirectlyPowered(BlockPosition blockposition) {
+        return this.getBlockFacePower(blockposition.down(), EnumDirection.DOWN) > 0 ? true : (this.getBlockFacePower(blockposition.up(), EnumDirection.UP) > 0 ? true : (this.getBlockFacePower(blockposition.north(), EnumDirection.NORTH) > 0 ? true : (this.getBlockFacePower(blockposition.south(), EnumDirection.SOUTH) > 0 ? true : (this.getBlockFacePower(blockposition.west(), EnumDirection.WEST) > 0 ? true : this.getBlockFacePower(blockposition.east(), EnumDirection.EAST) > 0))));
+    }
+
+    public int q(BlockPosition blockposition) {
+        int i = 0;
+        EnumDirection[] aenumdirection = World.a;
+        int j = aenumdirection.length;
+
+        for (int k = 0; k < j; ++k) {
+            EnumDirection enumdirection = aenumdirection[k];
+            int l = this.getBlockFacePower(blockposition.shift(enumdirection), enumdirection);
+
+            if (l >= 15) {
+                return 15;
+            }
+
+            if (l > i) {
+                i = l;
+            }
+        }
+
+        return i;
+    }
+
+    public long getTime() {
+        return this.worldData.getTime();
+    }
+
+    public long getDayTime() {
+        return this.worldData.getDayTime();
+    }
+
+    public boolean a(EntityHuman entityhuman, BlockPosition blockposition) {
+        return true;
+    }
+
+    public void broadcastEntityEffect(Entity entity, byte b0) {}
+
+    public void playBlockAction(BlockPosition blockposition, Block block, int i, int j) {
+        this.getType(blockposition).a(this, blockposition, i, j);
+    }
+
+    @Override
+    public WorldData getWorldData() {
+        return this.worldData;
+    }
+
+    public GameRules getGameRules() {
+        return this.worldData.q();
+    }
+
+    public float b(float f) {
+        return MathHelper.g(f, this.lastThunderLevel, this.thunderLevel) * this.d(f);
+    }
+
+    public float d(float f) {
+        return MathHelper.g(f, this.lastRainLevel, this.rainLevel);
+    }
+
+    public boolean Y() {
+        return this.getDimensionManager().hasSkyLight() && !this.getDimensionManager().hasCeiling() ? (double) this.b(1.0F) > 0.9D : false;
+    }
+
+    public boolean isRaining() {
+        return (double) this.d(1.0F) > 0.2D;
+    }
+
+    public boolean isRainingAt(BlockPosition blockposition) {
+        if (!this.isRaining()) {
+            return false;
+        } else if (!this.e(blockposition)) {
+            return false;
+        } else if (this.getHighestBlockYAt(HeightMap.Type.MOTION_BLOCKING, blockposition).getY() > blockposition.getY()) {
+            return false;
+        } else {
+            BiomeBase biomebase = this.getBiome(blockposition);
+
+            return biomebase.c() == BiomeBase.Precipitation.RAIN && biomebase.getAdjustedTemperature(blockposition) >= 0.15F;
+        }
+    }
+
+    public boolean s(BlockPosition blockposition) {
+        BiomeBase biomebase = this.getBiome(blockposition);
+
+        return biomebase.d();
+    }
+
+    @Nullable
+    public abstract WorldMap a(String s);
+
+    public abstract void a(String s, WorldMap worldmap);
+
+    public abstract int getWorldMapCount();
+
+    public void b(int i, BlockPosition blockposition, int j) {}
+
+    public CrashReportSystemDetails a(CrashReport crashreport) {
+        CrashReportSystemDetails crashreportsystemdetails = crashreport.a("Affected level", 1);
+
+        crashreportsystemdetails.a("All players", () -> {
+            return this.getPlayers().size() + " total; " + this.getPlayers();
+        });
+        IChunkProvider ichunkprovider = this.getChunkProvider();
+
+        crashreportsystemdetails.a("Chunk stats", ichunkprovider::getName);
+        crashreportsystemdetails.a("Level dimension", () -> {
+            return this.getDimensionKey().a().toString();
+        });
+
+        try {
+            this.worldData.a(crashreportsystemdetails, this);
+        } catch (Throwable throwable) {
+            crashreportsystemdetails.a("Level Data Unobtainable", throwable);
+        }
+
+        return crashreportsystemdetails;
+    }
+
+    public abstract void a(int i, BlockPosition blockposition, int j);
+
+    public abstract Scoreboard getScoreboard();
+
+    public void updateAdjacentComparators(BlockPosition blockposition, Block block) {
+        Iterator iterator = EnumDirection.EnumDirectionLimit.HORIZONTAL.iterator();
+
+        while (iterator.hasNext()) {
+            EnumDirection enumdirection = (EnumDirection) iterator.next();
+            BlockPosition blockposition1 = blockposition.shift(enumdirection);
+
+            if (this.isLoaded(blockposition1)) {
+                IBlockData iblockdata = this.getType(blockposition1);
+
+                if (iblockdata.a(Blocks.COMPARATOR)) {
+                    iblockdata.doPhysics(this, blockposition1, block, blockposition, false);
+                } else if (iblockdata.isOccluding(this, blockposition1)) {
+                    blockposition1 = blockposition1.shift(enumdirection);
+                    iblockdata = this.getType(blockposition1);
+                    if (iblockdata.a(Blocks.COMPARATOR)) {
+                        iblockdata.doPhysics(this, blockposition1, block, blockposition, false);
+                    }
+                }
+            }
+        }
+
+    }
+
+    @Override
+    public DifficultyDamageScaler getDamageScaler(BlockPosition blockposition) {
+        long i = 0L;
+        float f = 0.0F;
+
+        if (this.isLoaded(blockposition)) {
+            f = this.ak();
+            i = this.getChunkAtWorldCoords(blockposition).getInhabitedTime();
+        }
+
+        return new DifficultyDamageScaler(this.getDifficulty(), this.getDayTime(), i, f);
+    }
+
+    @Override
+    public int c() {
+        return this.u;
+    }
+
+    public void c(int i) {}
+
+    @Override
+    public WorldBorder getWorldBorder() {
+        return this.worldBorder;
+    }
+
+    public void a(Packet<?> packet) {
+        throw new UnsupportedOperationException("Can't send packets to server unless you're on the client.");
+    }
+
+    @Override
+    public DimensionManager getDimensionManager() {
+        return this.v;
+    }
+
+    public ResourceKey<World> getDimensionKey() {
+        return this.dimensionKey;
+    }
+
+    @Override
+    public Random getRandom() {
+        return this.random;
+    }
+
+    @Override
+    public boolean a(BlockPosition blockposition, Predicate<IBlockData> predicate) {
+        return predicate.test(this.getType(blockposition));
+    }
+
+    public abstract CraftingManager getCraftingManager();
+
+    public abstract ITagRegistry r();
+
+    public BlockPosition a(int i, int j, int k, int l) {
+        this.j = this.j * 3 + 1013904223;
+        int i1 = this.j >> 2;
+
+        return new BlockPosition(i + (i1 & 15), j + (i1 >> 16 & l), k + (i1 >> 8 & 15));
+    }
+
+    public boolean isSavingDisabled() {
+        return false;
+    }
+
+    public GameProfilerFiller getMethodProfiler() {
+        return (GameProfilerFiller) this.methodProfiler.get();
+    }
+
+    public Supplier<GameProfilerFiller> getMethodProfilerSupplier() {
+        return this.methodProfiler;
+    }
+
+    @Override
+    public BiomeManager v_() {
+        return this.biomeManager;
+    }
+
+    public final boolean isDebugWorld() {
+        return this.debugWorld;
+    }
+
+    protected abstract WorldEntityGetter<Entity> getEntities();
+
+    // CraftBukkit start
+    public void setTileEntity(BlockPosition blockposition, TileEntity tileentity) {
+        tileentity.position = blockposition;
+        getChunkAtWorldCoords(blockposition).setTileEntity(tileentity);
+    }
+
+    public void setTileEntity(TileEntity tileentity) {
+        setTileEntity(tileentity.position, tileentity);
+    }
+    // CraftBukkit end
+
+    protected void a(@Nullable Entity entity, ckz ckz, BlockPosition blockposition, int i) {
+        int j = SectionPosition.a(blockposition.getX() - i);
+        int k = SectionPosition.a(blockposition.getZ() - i);
+        int l = SectionPosition.a(blockposition.getX() + i);
+        int i1 = SectionPosition.a(blockposition.getZ() + i);
+        int j1 = SectionPosition.a(blockposition.getY() - i);
+        int k1 = SectionPosition.a(blockposition.getY() + i);
+
+        for (int l1 = j; l1 <= l; ++l1) {
+            for (int i2 = k; i2 <= i1; ++i2) {
+                Chunk chunk = this.getChunkProvider().a(l1, i2);
+
+                if (chunk != null) {
+                    for (int j2 = j1; j2 <= k1; ++j2) {
+                        chunk.a(j2).a(ckz, entity, blockposition);
+                    }
+                }
+            }
+        }
+
+    }
+}
-- 
2.21.0.windows.1

