From 667992019773344f7ba62e9b46195775b1867dc1 Mon Sep 17 00:00:00 2001
From: drXor <mcyoungsota@gmail.com>
Date: Sat, 29 Mar 2014 13:44:25 -0400
Subject: [PATCH] Configurable dragon death and wither spawn sounds


diff --git a/src/main/java/net/minecraft/server/EntityEnderDragon.java b/src/main/java/net/minecraft/server/EntityEnderDragon.java
new file mode 100644
index 00000000..1d31cd80
--- /dev/null
+++ b/src/main/java/net/minecraft/server/EntityEnderDragon.java
@@ -0,0 +1,939 @@
+package net.minecraft.server;
+
+import com.google.common.collect.Lists;
+import java.util.Iterator;
+import java.util.List;
+import javax.annotation.Nullable;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+// CraftBukkit start
+import org.bukkit.craftbukkit.block.CraftBlock;
+import org.bukkit.event.entity.EntityExplodeEvent;
+import org.bukkit.event.entity.EntityRegainHealthEvent;
+// CraftBukkit end
+
+// PAIL: Fixme
+public class EntityEnderDragon extends EntityInsentient implements IMonster {
+
+    private static final Logger LOGGER = LogManager.getLogger();
+    public static final DataWatcherObject<Integer> PHASE = DataWatcher.a(EntityEnderDragon.class, DataWatcherRegistry.b);
+    private static final PathfinderTargetCondition br = (new PathfinderTargetCondition()).a(64.0D);
+    public final double[][] c = new double[64][3];
+    public int d = -1;
+    public final EntityComplexPart[] children;
+    public final EntityComplexPart bj = new EntityComplexPart(this, "head", 1.0F, 1.0F);
+    private final EntityComplexPart bt = new EntityComplexPart(this, "neck", 3.0F, 3.0F);
+    private final EntityComplexPart bu = new EntityComplexPart(this, "body", 5.0F, 3.0F);
+    private final EntityComplexPart bv = new EntityComplexPart(this, "tail", 2.0F, 2.0F);
+    private final EntityComplexPart bw = new EntityComplexPart(this, "tail", 2.0F, 2.0F);
+    private final EntityComplexPart bx = new EntityComplexPart(this, "tail", 2.0F, 2.0F);
+    private final EntityComplexPart by = new EntityComplexPart(this, "wing", 4.0F, 2.0F);
+    private final EntityComplexPart bz = new EntityComplexPart(this, "wing", 4.0F, 2.0F);
+    public float bk;
+    public float bl;
+    public boolean bm;
+    public int deathAnimationTicks;
+    public float bo;
+    @Nullable
+    public EntityEnderCrystal currentEnderCrystal;
+    @Nullable
+    private final EnderDragonBattle bA;
+    private final DragonControllerManager bB;
+    private int bC = 100;
+    private int bD;
+    private final PathPoint[] bE = new PathPoint[24];
+    private final int[] bF = new int[24];
+    private final Path bG = new Path();
+    private Explosion explosionSource = new Explosion(null, this, null, null, Double.NaN, Double.NaN, Double.NaN, Float.NaN, true, Explosion.Effect.DESTROY); // CraftBukkit - reusable source for CraftTNTPrimed.getSource()
+
+    public EntityEnderDragon(EntityTypes<? extends EntityEnderDragon> entitytypes, World world) {
+        super(EntityTypes.ENDER_DRAGON, world);
+        this.children = new EntityComplexPart[]{this.bj, this.bt, this.bu, this.bv, this.bw, this.bx, this.by, this.bz};
+        this.setHealth(this.getMaxHealth());
+        this.noclip = true;
+        this.S = true;
+        if (world instanceof WorldServer) {
+            this.bA = ((WorldServer) world).getDragonBattle();
+        } else {
+            this.bA = null;
+        }
+
+        this.bB = new DragonControllerManager(this);
+    }
+
+    public static AttributeProvider.Builder m() {
+        return EntityInsentient.p().a(GenericAttributes.MAX_HEALTH, 200.0D);
+    }
+
+    @Override
+    protected void initDatawatcher() {
+        super.initDatawatcher();
+        this.getDataWatcher().register(EntityEnderDragon.PHASE, DragonControllerPhase.HOVER.b());
+    }
+
+    public double[] a(int i, float f) {
+        if (this.dG()) {
+            f = 0.0F;
+        }
+
+        f = 1.0F - f;
+        int j = this.d - i & 63;
+        int k = this.d - i - 1 & 63;
+        double[] adouble = new double[3];
+        double d0 = this.c[j][0];
+        double d1 = MathHelper.g(this.c[k][0] - d0);
+
+        adouble[0] = d0 + d1 * (double) f;
+        d0 = this.c[j][1];
+        d1 = this.c[k][1] - d0;
+        adouble[1] = d0 + d1 * (double) f;
+        adouble[2] = MathHelper.d((double) f, this.c[j][2], this.c[k][2]);
+        return adouble;
+    }
+
+    @Override
+    public void movementTick() {
+        float f;
+        float f1;
+
+        if (this.world.isClientSide) {
+            this.setHealth(this.getHealth());
+            if (!this.isSilent()) {
+                f = MathHelper.cos(this.bl * 6.2831855F);
+                f1 = MathHelper.cos(this.bk * 6.2831855F);
+                if (f1 <= -0.3F && f >= -0.3F) {
+                    this.world.a(this.locX(), this.locY(), this.locZ(), SoundEffects.ENDER_DRAGON_FLAP, this.getSoundCategory(), 5.0F, 0.8F + this.random.nextFloat() * 0.3F, false);
+                }
+
+                if (!this.bB.a().a() && --this.bC < 0) {
+                    this.world.a(this.locX(), this.locY(), this.locZ(), SoundEffects.ENDER_DRAGON_GROWL, this.getSoundCategory(), 2.5F, 0.8F + this.random.nextFloat() * 0.3F, false);
+                    this.bC = 200 + this.random.nextInt(200);
+                }
+            }
+        }
+
+        this.bk = this.bl;
+        if (this.dG()) {
+            f = (this.random.nextFloat() - 0.5F) * 8.0F;
+            f1 = (this.random.nextFloat() - 0.5F) * 4.0F;
+            float f2 = (this.random.nextFloat() - 0.5F) * 8.0F;
+
+            this.world.addParticle(Particles.EXPLOSION, this.locX() + (double) f, this.locY() + 2.0D + (double) f1, this.locZ() + (double) f2, 0.0D, 0.0D, 0.0D);
+        } else {
+            this.fi();
+            Vec3D vec3d = this.getMot();
+
+            f1 = 0.2F / (MathHelper.sqrt(c(vec3d)) * 10.0F + 1.0F);
+            f1 *= (float) Math.pow(2.0D, vec3d.y);
+            if (this.bB.a().a()) {
+                this.bl += 0.1F;
+            } else if (this.bm) {
+                this.bl += f1 * 0.5F;
+            } else {
+                this.bl += f1;
+            }
+
+            this.yaw = MathHelper.g(this.yaw);
+            if (this.isNoAI()) {
+                this.bl = 0.5F;
+            } else {
+                if (this.d < 0) {
+                    for (int i = 0; i < this.c.length; ++i) {
+                        this.c[i][0] = (double) this.yaw;
+                        this.c[i][1] = this.locY();
+                    }
+                }
+
+                if (++this.d == this.c.length) {
+                    this.d = 0;
+                }
+
+                this.c[this.d][0] = (double) this.yaw;
+                this.c[this.d][1] = this.locY();
+                double d0;
+                double d1;
+                double d2;
+                float f3;
+                float f4;
+
+                if (this.world.isClientSide) {
+                    if (this.aP > 0) {
+                        double d3 = this.locX() + (this.aQ - this.locX()) / (double) this.aP;
+
+                        d0 = this.locY() + (this.aR - this.locY()) / (double) this.aP;
+                        d1 = this.locZ() + (this.aS - this.locZ()) / (double) this.aP;
+                        d2 = MathHelper.g(this.aT - (double) this.yaw);
+                        this.yaw = (float) ((double) this.yaw + d2 / (double) this.aP);
+                        this.pitch = (float) ((double) this.pitch + (this.aU - (double) this.pitch) / (double) this.aP);
+                        --this.aP;
+                        this.setPosition(d3, d0, d1);
+                        this.setYawPitch(this.yaw, this.pitch);
+                    }
+
+                    this.bB.a().b();
+                } else {
+                    IDragonController idragoncontroller = this.bB.a();
+
+                    idragoncontroller.c();
+                    if (this.bB.a() != idragoncontroller) {
+                        idragoncontroller = this.bB.a();
+                        idragoncontroller.c();
+                    }
+
+                    Vec3D vec3d1 = idragoncontroller.g();
+
+                    if (vec3d1 != null && idragoncontroller.getControllerPhase() != DragonControllerPhase.HOVER) { // CraftBukkit - Don't move when hovering
+                        d0 = vec3d1.x - this.locX();
+                        d1 = vec3d1.y - this.locY();
+                        d2 = vec3d1.z - this.locZ();
+                        double d4 = d0 * d0 + d1 * d1 + d2 * d2;
+                        float f5 = idragoncontroller.f();
+                        double d5 = (double) MathHelper.sqrt(d0 * d0 + d2 * d2);
+
+                        if (d5 > 0.0D) {
+                            d1 = MathHelper.a(d1 / d5, (double) (-f5), (double) f5);
+                        }
+
+                        this.setMot(this.getMot().add(0.0D, d1 * 0.01D, 0.0D));
+                        this.yaw = MathHelper.g(this.yaw);
+                        double d6 = MathHelper.a(MathHelper.g(180.0D - MathHelper.d(d0, d2) * 57.2957763671875D - (double) this.yaw), -50.0D, 50.0D);
+                        Vec3D vec3d2 = vec3d1.a(this.locX(), this.locY(), this.locZ()).d();
+                        Vec3D vec3d3 = (new Vec3D((double) MathHelper.sin(this.yaw * 0.017453292F), this.getMot().y, (double) (-MathHelper.cos(this.yaw * 0.017453292F)))).d();
+
+                        f3 = Math.max(((float) vec3d3.b(vec3d2) + 0.5F) / 1.5F, 0.0F);
+                        this.bo *= 0.8F;
+                        this.bo = (float) ((double) this.bo + d6 * (double) idragoncontroller.h());
+                        this.yaw += this.bo * 0.1F;
+                        f4 = (float) (2.0D / (d4 + 1.0D));
+                        float f6 = 0.06F;
+
+                        this.a(0.06F * (f3 * f4 + (1.0F - f4)), new Vec3D(0.0D, 0.0D, -1.0D));
+                        if (this.bm) {
+                            this.move(EnumMoveType.SELF, this.getMot().a(0.800000011920929D));
+                        } else {
+                            this.move(EnumMoveType.SELF, this.getMot());
+                        }
+
+                        Vec3D vec3d4 = this.getMot().d();
+                        double d7 = 0.8D + 0.15D * (vec3d4.b(vec3d3) + 1.0D) / 2.0D;
+
+                        this.setMot(this.getMot().d(d7, 0.9100000262260437D, d7));
+                    }
+                }
+
+                this.av = this.yaw;
+                Vec3D[] avec3d = new Vec3D[this.children.length];
+
+                for (int j = 0; j < this.children.length; ++j) {
+                    avec3d[j] = new Vec3D(this.children[j].locX(), this.children[j].locY(), this.children[j].locZ());
+                }
+
+                float f7 = (float) (this.a(5, 1.0F)[1] - this.a(10, 1.0F)[1]) * 10.0F * 0.017453292F;
+                float f8 = MathHelper.cos(f7);
+                float f9 = MathHelper.sin(f7);
+                float f10 = this.yaw * 0.017453292F;
+                float f11 = MathHelper.sin(f10);
+                float f12 = MathHelper.cos(f10);
+
+                this.a(this.bu, (double) (f11 * 0.5F), 0.0D, (double) (-f12 * 0.5F));
+                this.a(this.by, (double) (f12 * 4.5F), 2.0D, (double) (f11 * 4.5F));
+                this.a(this.bz, (double) (f12 * -4.5F), 2.0D, (double) (f11 * -4.5F));
+                if (!this.world.isClientSide && this.hurtTimestamp == 0) {
+                    this.a(this.world.getEntities(this, this.by.getBoundingBox().grow(4.0D, 2.0D, 4.0D).d(0.0D, -2.0D, 0.0D), IEntitySelector.e));
+                    this.a(this.world.getEntities(this, this.bz.getBoundingBox().grow(4.0D, 2.0D, 4.0D).d(0.0D, -2.0D, 0.0D), IEntitySelector.e));
+                    this.b(this.world.getEntities(this, this.bj.getBoundingBox().g(1.0D), IEntitySelector.e));
+                    this.b(this.world.getEntities(this, this.bt.getBoundingBox().g(1.0D), IEntitySelector.e));
+                }
+
+                float f13 = MathHelper.sin(this.yaw * 0.017453292F - this.bo * 0.01F);
+                float f14 = MathHelper.cos(this.yaw * 0.017453292F - this.bo * 0.01F);
+                float f15 = this.fh();
+
+                this.a(this.bj, (double) (f13 * 6.5F * f8), (double) (f15 + f9 * 6.5F), (double) (-f14 * 6.5F * f8));
+                this.a(this.bt, (double) (f13 * 5.5F * f8), (double) (f15 + f9 * 5.5F), (double) (-f14 * 5.5F * f8));
+                double[] adouble = this.a(5, 1.0F);
+
+                int k;
+
+                for (k = 0; k < 3; ++k) {
+                    EntityComplexPart entitycomplexpart = null;
+
+                    if (k == 0) {
+                        entitycomplexpart = this.bv;
+                    }
+
+                    if (k == 1) {
+                        entitycomplexpart = this.bw;
+                    }
+
+                    if (k == 2) {
+                        entitycomplexpart = this.bx;
+                    }
+
+                    double[] adouble1 = this.a(12 + k * 2, 1.0F);
+                    float f16 = this.yaw * 0.017453292F + this.i(adouble1[0] - adouble[0]) * 0.017453292F;
+                    float f17 = MathHelper.sin(f16);
+                    float f18 = MathHelper.cos(f16);
+
+                    f3 = 1.5F;
+                    f4 = (float) (k + 1) * 2.0F;
+                    this.a(entitycomplexpart, (double) (-(f11 * 1.5F + f17 * f4) * f8), adouble1[1] - adouble[1] - (double) ((f4 + 1.5F) * f9) + 1.5D, (double) ((f12 * 1.5F + f18 * f4) * f8));
+                }
+
+                if (!this.world.isClientSide) {
+                    this.bm = this.b(this.bj.getBoundingBox()) | this.b(this.bt.getBoundingBox()) | this.b(this.bu.getBoundingBox());
+                    if (this.bA != null) {
+                        this.bA.b(this);
+                    }
+                }
+
+                for (k = 0; k < this.children.length; ++k) {
+                    this.children[k].lastX = avec3d[k].x;
+                    this.children[k].lastY = avec3d[k].y;
+                    this.children[k].lastZ = avec3d[k].z;
+                    this.children[k].B = avec3d[k].x;
+                    this.children[k].C = avec3d[k].y;
+                    this.children[k].D = avec3d[k].z;
+                }
+
+            }
+        }
+    }
+
+    private void a(EntityComplexPart entitycomplexpart, double d0, double d1, double d2) {
+        entitycomplexpart.setPosition(this.locX() + d0, this.locY() + d1, this.locZ() + d2);
+    }
+
+    private float fh() {
+        if (this.bB.a().a()) {
+            return -1.0F;
+        } else {
+            double[] adouble = this.a(5, 1.0F);
+            double[] adouble1 = this.a(0, 1.0F);
+
+            return (float) (adouble[1] - adouble1[1]);
+        }
+    }
+
+    private void fi() {
+        if (this.currentEnderCrystal != null) {
+            if (this.currentEnderCrystal.cW()) {
+                this.currentEnderCrystal = null;
+            } else if (this.ticksLived % 10 == 0 && this.getHealth() < this.getMaxHealth()) {
+                // CraftBukkit start
+                EntityRegainHealthEvent event = new EntityRegainHealthEvent(this.getBukkitEntity(), 1.0F, EntityRegainHealthEvent.RegainReason.ENDER_CRYSTAL);
+                this.world.getServer().getPluginManager().callEvent(event);
+
+                if (!event.isCancelled()) {
+                    this.setHealth((float) (this.getHealth() + event.getAmount()));
+                }
+                // CraftBukkit end
+            }
+        }
+
+        if (this.random.nextInt(10) == 0) {
+            List<EntityEnderCrystal> list = this.world.a(EntityEnderCrystal.class, this.getBoundingBox().g(32.0D));
+            EntityEnderCrystal entityendercrystal = null;
+            double d0 = Double.MAX_VALUE;
+            Iterator iterator = list.iterator();
+
+            while (iterator.hasNext()) {
+                EntityEnderCrystal entityendercrystal1 = (EntityEnderCrystal) iterator.next();
+                double d1 = entityendercrystal1.h(this);
+
+                if (d1 < d0) {
+                    d0 = d1;
+                    entityendercrystal = entityendercrystal1;
+                }
+            }
+
+            this.currentEnderCrystal = entityendercrystal;
+        }
+
+    }
+
+    private void a(List<Entity> list) {
+        double d0 = (this.bu.getBoundingBox().minX + this.bu.getBoundingBox().maxX) / 2.0D;
+        double d1 = (this.bu.getBoundingBox().minZ + this.bu.getBoundingBox().maxZ) / 2.0D;
+        Iterator iterator = list.iterator();
+
+        while (iterator.hasNext()) {
+            Entity entity = (Entity) iterator.next();
+
+            if (entity instanceof EntityLiving) {
+                double d2 = entity.locX() - d0;
+                double d3 = entity.locZ() - d1;
+                double d4 = Math.max(d2 * d2 + d3 * d3, 0.1D);
+
+                entity.i(d2 / d4 * 4.0D, 0.20000000298023224D, d3 / d4 * 4.0D);
+                if (!this.bB.a().a() && ((EntityLiving) entity).du() < entity.ticksLived - 2) {
+                    entity.damageEntity(DamageSource.mobAttack(this), 5.0F);
+                    this.a((EntityLiving) this, entity);
+                }
+            }
+        }
+
+    }
+
+    private void b(List<Entity> list) {
+        Iterator iterator = list.iterator();
+
+        while (iterator.hasNext()) {
+            Entity entity = (Entity) iterator.next();
+
+            if (entity instanceof EntityLiving) {
+                entity.damageEntity(DamageSource.mobAttack(this), 10.0F);
+                this.a((EntityLiving) this, entity);
+            }
+        }
+
+    }
+
+    private float i(double d0) {
+        return (float) MathHelper.g(d0);
+    }
+
+    private boolean b(AxisAlignedBB axisalignedbb) {
+        int i = MathHelper.floor(axisalignedbb.minX);
+        int j = MathHelper.floor(axisalignedbb.minY);
+        int k = MathHelper.floor(axisalignedbb.minZ);
+        int l = MathHelper.floor(axisalignedbb.maxX);
+        int i1 = MathHelper.floor(axisalignedbb.maxY);
+        int j1 = MathHelper.floor(axisalignedbb.maxZ);
+        boolean flag = false;
+        boolean flag1 = false;
+        // CraftBukkit start - Create a list to hold all the destroyed blocks
+        List<org.bukkit.block.Block> destroyedBlocks = new java.util.ArrayList<org.bukkit.block.Block>();
+        // CraftBukkit end
+
+        for (int k1 = i; k1 <= l; ++k1) {
+            for (int l1 = j; l1 <= i1; ++l1) {
+                for (int i2 = k; i2 <= j1; ++i2) {
+                    BlockPosition blockposition = new BlockPosition(k1, l1, i2);
+                    IBlockData iblockdata = this.world.getType(blockposition);
+
+                    if (!iblockdata.isAir() && iblockdata.getMaterial() != Material.FIRE) {
+                        if (this.world.getGameRules().getBoolean(GameRules.MOB_GRIEFING) && !iblockdata.a((Tag) TagsBlock.DRAGON_IMMUNE)) {
+                            // CraftBukkit start - Add blocks to list rather than destroying them
+                            // flag1 = this.world.a(blockposition, false) || flag1;
+                            flag1 = true;
+                            destroyedBlocks.add(CraftBlock.at(world, blockposition));
+                            // CraftBukkit end
+                        } else {
+                            flag = true;
+                        }
+                    }
+                }
+            }
+        }
+
+        // CraftBukkit start - Set off an EntityExplodeEvent for the dragon exploding all these blocks
+        // SPIGOT-4882: don't fire event if nothing hit
+        if (!flag1) {
+            return flag;
+        }
+
+        org.bukkit.entity.Entity bukkitEntity = this.getBukkitEntity();
+        EntityExplodeEvent event = new EntityExplodeEvent(bukkitEntity, bukkitEntity.getLocation(), destroyedBlocks, 0F);
+        bukkitEntity.getServer().getPluginManager().callEvent(event);
+        if (event.isCancelled()) {
+            // This flag literally means 'Dragon hit something hard' (Obsidian, White Stone or Bedrock) and will cause the dragon to slow down.
+            // We should consider adding an event extension for it, or perhaps returning true if the event is cancelled.
+            return flag;
+        } else if (event.getYield() == 0F) {
+            // Yield zero ==> no drops
+            for (org.bukkit.block.Block block : event.blockList()) {
+                this.world.a(new BlockPosition(block.getX(), block.getY(), block.getZ()), false);
+            }
+        } else {
+            for (org.bukkit.block.Block block : event.blockList()) {
+                org.bukkit.Material blockId = block.getType();
+                if (blockId.isAir()) {
+                    continue;
+                }
+
+                CraftBlock craftBlock = ((CraftBlock) block);
+                BlockPosition blockposition = craftBlock.getPosition();
+
+                Block nmsBlock = craftBlock.getNMS().getBlock();
+                if (nmsBlock.a(explosionSource)) {
+                    TileEntity tileentity = nmsBlock.getBlockData().getBlock().isTileEntity() ? this.world.getTileEntity(blockposition) : null;
+                    LootTableInfo.Builder loottableinfo_builder = (new LootTableInfo.Builder((WorldServer) this.world)).a(this.world.random).set(LootContextParameters.ORIGIN, Vec3D.a(blockposition)).set(LootContextParameters.TOOL, ItemStack.b).set(LootContextParameters.EXPLOSION_RADIUS, 1.0F / event.getYield()).setOptional(LootContextParameters.BLOCK_ENTITY, tileentity);
+
+                    craftBlock.getNMS().a(loottableinfo_builder).forEach((itemstack) -> {
+                        Block.a(world, blockposition, itemstack);
+                    });
+                    craftBlock.getNMS().dropNaturally((WorldServer) world, blockposition, ItemStack.b);
+                }
+                nmsBlock.wasExploded(world, blockposition, explosionSource);
+
+                this.world.a(blockposition, false);
+            }
+        }
+        // CraftBukkit end
+
+        if (flag1) {
+            BlockPosition blockposition1 = new BlockPosition(i + this.random.nextInt(l - i + 1), j + this.random.nextInt(i1 - j + 1), k + this.random.nextInt(j1 - k + 1));
+
+            this.world.triggerEffect(2008, blockposition1, 0);
+        }
+
+        return flag;
+    }
+
+    public boolean a(EntityComplexPart entitycomplexpart, DamageSource damagesource, float f) {
+        if (this.bB.a().getControllerPhase() == DragonControllerPhase.DYING) {
+            return false;
+        } else {
+            f = this.bB.a().a(damagesource, f);
+            if (entitycomplexpart != this.bj) {
+                f = f / 4.0F + Math.min(f, 1.0F);
+            }
+
+            if (f < 0.01F) {
+                return false;
+            } else {
+                if (damagesource.getEntity() instanceof EntityHuman || damagesource.isExplosion()) {
+                    float f1 = this.getHealth();
+
+                    this.dealDamage(damagesource, f);
+                    if (this.dG() && !this.bB.a().a()) {
+                        this.setHealth(1.0F);
+                        this.bB.setControllerPhase(DragonControllerPhase.DYING);
+                    }
+
+                    if (this.bB.a().a()) {
+                        this.bD = (int) ((float) this.bD + (f1 - this.getHealth()));
+                        if ((float) this.bD > 0.25F * this.getMaxHealth()) {
+                            this.bD = 0;
+                            this.bB.setControllerPhase(DragonControllerPhase.TAKEOFF);
+                        }
+                    }
+                }
+
+                return true;
+            }
+        }
+    }
+
+    @Override
+    public boolean damageEntity(DamageSource damagesource, float f) {
+        if (damagesource instanceof EntityDamageSource && ((EntityDamageSource) damagesource).A()) {
+            this.a(this.bu, damagesource, f);
+        }
+
+        return false;
+    }
+
+    protected boolean dealDamage(DamageSource damagesource, float f) {
+        return super.damageEntity(damagesource, f);
+    }
+
+    @Override
+    public void killEntity() {
+        this.a(RemovalReason.KILLED);
+        if (this.bA != null) {
+            this.bA.b(this);
+            this.bA.a(this);
+        }
+
+    }
+
+    @Override
+    protected void do_() {
+        if (this.bA != null) {
+            this.bA.b(this);
+        }
+
+        ++this.deathAnimationTicks;
+        if (this.deathAnimationTicks >= 180 && this.deathAnimationTicks <= 200) {
+            float f = (this.random.nextFloat() - 0.5F) * 8.0F;
+            float f1 = (this.random.nextFloat() - 0.5F) * 4.0F;
+            float f2 = (this.random.nextFloat() - 0.5F) * 8.0F;
+
+            this.world.addParticle(Particles.EXPLOSION_EMITTER, this.locX() + (double) f, this.locY() + 2.0D + (double) f1, this.locZ() + (double) f2, 0.0D, 0.0D, 0.0D);
+        }
+
+        boolean flag = this.world.getGameRules().getBoolean(GameRules.DO_MOB_LOOT);
+        short short0 = 500;
+
+        if (this.bA != null && !this.bA.isPreviouslyKilled()) {
+            short0 = 12000;
+        }
+
+        if (this.world instanceof WorldServer) {
+            if (this.deathAnimationTicks > 150 && this.deathAnimationTicks % 5 == 0 && flag) {
+                EntityExperienceOrb.a((WorldServer) this.world, this.getPositionVector(), MathHelper.d((float) short0 * 0.08F));
+            }
+
+            if (this.deathAnimationTicks == 1 && !this.isSilent()) {
+                this.world.b(1028, this.getChunkCoordinates(), 0);
+                // CraftBukkit start - Use relative location for far away sounds
+                // this.world.b(1028, this.getChunkCoordinates(), 0);
+                int viewDistance = ((WorldServer) this.world).getServer().getViewDistance() * 16;
+                for (EntityPlayer player : (List<EntityPlayer>) MinecraftServer.getServer().getPlayerList().players) {
+                    double deltaX = this.locX() - player.locX();
+                    double deltaZ = this.locZ() - player.locZ();
+                    double distanceSquared = deltaX * deltaX + deltaZ * deltaZ;
+                    if ( world.spigotConfig.dragonDeathSoundRadius > 0 && distanceSquared > world.spigotConfig.dragonDeathSoundRadius * world.spigotConfig.dragonDeathSoundRadius ) continue; // Spigot
+                    if (distanceSquared > viewDistance * viewDistance) {
+                        double deltaLength = Math.sqrt(distanceSquared);
+                        double relativeX = player.locX() + (deltaX / deltaLength) * viewDistance;
+                        double relativeZ = player.locZ() + (deltaZ / deltaLength) * viewDistance;
+                        player.playerConnection.sendPacket(new PacketPlayOutWorldEvent(1028, new BlockPosition((int) relativeX, (int) this.locY(), (int) relativeZ), 0, true));
+                    } else {
+                        player.playerConnection.sendPacket(new PacketPlayOutWorldEvent(1028, new BlockPosition((int) this.locX(), (int) this.locY(), (int) this.locZ()), 0, true));
+                    }
+                }
+                // CraftBukkit end
+            }
+        }
+
+        this.move(EnumMoveType.SELF, new Vec3D(0.0D, 0.10000000149011612D, 0.0D));
+        this.yaw += 20.0F;
+        this.av = this.yaw;
+        if (this.deathAnimationTicks == 200 && this.world instanceof WorldServer) {
+            if (flag) {
+                EntityExperienceOrb.a((WorldServer) this.world, this.getPositionVector(), MathHelper.d((float) short0 * 0.2F));
+            }
+
+            if (this.bA != null) {
+                this.bA.a(this);
+            }
+
+            this.a(RemovalReason.KILLED);
+        }
+
+    }
+
+    public int fd() {
+        if (this.bE[0] == null) {
+            for (int i = 0; i < 24; ++i) {
+                int j = 5;
+                int k;
+                int l;
+
+                if (i < 12) {
+                    k = MathHelper.d(60.0F * MathHelper.cos(2.0F * (-3.1415927F + 0.2617994F * (float) i)));
+                    l = MathHelper.d(60.0F * MathHelper.sin(2.0F * (-3.1415927F + 0.2617994F * (float) i)));
+                } else {
+                    int i1;
+
+                    if (i < 20) {
+                        i1 = i - 12;
+                        k = MathHelper.d(40.0F * MathHelper.cos(2.0F * (-3.1415927F + 0.3926991F * (float) i1)));
+                        l = MathHelper.d(40.0F * MathHelper.sin(2.0F * (-3.1415927F + 0.3926991F * (float) i1)));
+                        j += 10;
+                    } else {
+                        i1 = i - 20;
+                        k = MathHelper.d(20.0F * MathHelper.cos(2.0F * (-3.1415927F + 0.7853982F * (float) i1)));
+                        l = MathHelper.d(20.0F * MathHelper.sin(2.0F * (-3.1415927F + 0.7853982F * (float) i1)));
+                    }
+                }
+
+                int j1 = Math.max(this.world.getSeaLevel() + 10, this.world.getHighestBlockYAt(HeightMap.Type.MOTION_BLOCKING_NO_LEAVES, new BlockPosition(k, 0, l)).getY() + j);
+
+                this.bE[i] = new PathPoint(k, j1, l);
+            }
+
+            this.bF[0] = 6146;
+            this.bF[1] = 8197;
+            this.bF[2] = 8202;
+            this.bF[3] = 16404;
+            this.bF[4] = 32808;
+            this.bF[5] = 32848;
+            this.bF[6] = 65696;
+            this.bF[7] = 131392;
+            this.bF[8] = 131712;
+            this.bF[9] = 263424;
+            this.bF[10] = 526848;
+            this.bF[11] = 525313;
+            this.bF[12] = 1581057;
+            this.bF[13] = 3166214;
+            this.bF[14] = 2138120;
+            this.bF[15] = 6373424;
+            this.bF[16] = 4358208;
+            this.bF[17] = 12910976;
+            this.bF[18] = 9044480;
+            this.bF[19] = 9706496;
+            this.bF[20] = 15216640;
+            this.bF[21] = 13688832;
+            this.bF[22] = 11763712;
+            this.bF[23] = 8257536;
+        }
+
+        return this.p(this.locX(), this.locY(), this.locZ());
+    }
+
+    public int p(double d0, double d1, double d2) {
+        float f = 10000.0F;
+        int i = 0;
+        PathPoint pathpoint = new PathPoint(MathHelper.floor(d0), MathHelper.floor(d1), MathHelper.floor(d2));
+        byte b0 = 0;
+
+        if (this.bA == null || this.bA.c() == 0) {
+            b0 = 12;
+        }
+
+        for (int j = b0; j < 24; ++j) {
+            if (this.bE[j] != null) {
+                float f1 = this.bE[j].b(pathpoint);
+
+                if (f1 < f) {
+                    f = f1;
+                    i = j;
+                }
+            }
+        }
+
+        return i;
+    }
+
+    @Nullable
+    public PathEntity a(int i, int j, @Nullable PathPoint pathpoint) {
+        PathPoint pathpoint1;
+
+        for (int k = 0; k < 24; ++k) {
+            pathpoint1 = this.bE[k];
+            pathpoint1.i = false;
+            pathpoint1.g = 0.0F;
+            pathpoint1.e = 0.0F;
+            pathpoint1.f = 0.0F;
+            pathpoint1.h = null;
+            pathpoint1.d = -1;
+        }
+
+        PathPoint pathpoint2 = this.bE[i];
+
+        pathpoint1 = this.bE[j];
+        pathpoint2.e = 0.0F;
+        pathpoint2.f = pathpoint2.a(pathpoint1);
+        pathpoint2.g = pathpoint2.f;
+        this.bG.a();
+        this.bG.a(pathpoint2);
+        PathPoint pathpoint3 = pathpoint2;
+        byte b0 = 0;
+
+        if (this.bA == null || this.bA.c() == 0) {
+            b0 = 12;
+        }
+
+        label70:
+        while (!this.bG.e()) {
+            PathPoint pathpoint4 = this.bG.c();
+
+            if (pathpoint4.equals(pathpoint1)) {
+                if (pathpoint != null) {
+                    pathpoint.h = pathpoint1;
+                    pathpoint1 = pathpoint;
+                }
+
+                return this.a(pathpoint2, pathpoint1);
+            }
+
+            if (pathpoint4.a(pathpoint1) < pathpoint3.a(pathpoint1)) {
+                pathpoint3 = pathpoint4;
+            }
+
+            pathpoint4.i = true;
+            int l = 0;
+            int i1 = 0;
+
+            while (true) {
+                if (i1 < 24) {
+                    if (this.bE[i1] != pathpoint4) {
+                        ++i1;
+                        continue;
+                    }
+
+                    l = i1;
+                }
+
+                i1 = b0;
+
+                while (true) {
+                    if (i1 >= 24) {
+                        continue label70;
+                    }
+
+                    if ((this.bF[l] & 1 << i1) > 0) {
+                        PathPoint pathpoint5 = this.bE[i1];
+
+                        if (!pathpoint5.i) {
+                            float f = pathpoint4.e + pathpoint4.a(pathpoint5);
+
+                            if (!pathpoint5.c() || f < pathpoint5.e) {
+                                pathpoint5.h = pathpoint4;
+                                pathpoint5.e = f;
+                                pathpoint5.f = pathpoint5.a(pathpoint1);
+                                if (pathpoint5.c()) {
+                                    this.bG.a(pathpoint5, pathpoint5.e + pathpoint5.f);
+                                } else {
+                                    pathpoint5.g = pathpoint5.e + pathpoint5.f;
+                                    this.bG.a(pathpoint5);
+                                }
+                            }
+                        }
+                    }
+
+                    ++i1;
+                }
+            }
+        }
+
+        if (pathpoint3 == pathpoint2) {
+            return null;
+        } else {
+            EntityEnderDragon.LOGGER.debug("Failed to find path from {} to {}", i, j);
+            if (pathpoint != null) {
+                pathpoint.h = pathpoint3;
+                pathpoint3 = pathpoint;
+            }
+
+            return this.a(pathpoint2, pathpoint3);
+        }
+    }
+
+    private PathEntity a(PathPoint pathpoint, PathPoint pathpoint1) {
+        List<PathPoint> list = Lists.newArrayList();
+        PathPoint pathpoint2 = pathpoint1;
+
+        list.add(0, pathpoint1);
+
+        while (pathpoint2.h != null) {
+            pathpoint2 = pathpoint2.h;
+            list.add(0, pathpoint2);
+        }
+
+        return new PathEntity(list, new BlockPosition(pathpoint1.a, pathpoint1.b, pathpoint1.c), true);
+    }
+
+    @Override
+    public void saveData(NBTTagCompound nbttagcompound) {
+        super.saveData(nbttagcompound);
+        nbttagcompound.setInt("DragonPhase", this.bB.a().getControllerPhase().b());
+    }
+
+    @Override
+    public void loadData(NBTTagCompound nbttagcompound) {
+        super.loadData(nbttagcompound);
+        if (nbttagcompound.hasKey("DragonPhase")) {
+            this.bB.setControllerPhase(DragonControllerPhase.getById(nbttagcompound.getInt("DragonPhase")));
+        }
+
+    }
+
+    @Override
+    public void checkDespawn() {}
+
+    public EntityComplexPart[] fe() {
+        return this.children;
+    }
+
+    @Override
+    public boolean isInteractable() {
+        return false;
+    }
+
+    @Override
+    public SoundCategory getSoundCategory() {
+        return SoundCategory.HOSTILE;
+    }
+
+    @Override
+    protected SoundEffect getSoundAmbient() {
+        return SoundEffects.ENDER_DRAGON_AMBIENT;
+    }
+
+    @Override
+    protected SoundEffect getSoundHurt(DamageSource damagesource) {
+        return SoundEffects.ENDER_DRAGON_HURT;
+    }
+
+    @Override
+    protected float getSoundVolume() {
+        return 5.0F;
+    }
+
+    public Vec3D x(float f) {
+        IDragonController idragoncontroller = this.bB.a();
+        DragonControllerPhase<? extends IDragonController> dragoncontrollerphase = idragoncontroller.getControllerPhase();
+        float f1;
+        Vec3D vec3d;
+
+        if (dragoncontrollerphase != DragonControllerPhase.LANDING && dragoncontrollerphase != DragonControllerPhase.TAKEOFF) {
+            if (idragoncontroller.a()) {
+                float f2 = this.pitch;
+
+                f1 = 1.5F;
+                this.pitch = -45.0F;
+                vec3d = this.f(f);
+                this.pitch = f2;
+            } else {
+                vec3d = this.f(f);
+            }
+        } else {
+            BlockPosition blockposition = this.world.getHighestBlockYAt(HeightMap.Type.MOTION_BLOCKING_NO_LEAVES, WorldGenEndTrophy.a);
+
+            f1 = Math.max(MathHelper.sqrt(blockposition.a((IPosition) this.getPositionVector(), true)) / 4.0F, 1.0F);
+            float f3 = 6.0F / f1;
+            float f4 = this.pitch;
+            float f5 = 1.5F;
+
+            this.pitch = -f3 * 1.5F * 5.0F;
+            vec3d = this.f(f);
+            this.pitch = f4;
+        }
+
+        return vec3d;
+    }
+
+    public void a(EntityEnderCrystal entityendercrystal, BlockPosition blockposition, DamageSource damagesource) {
+        EntityHuman entityhuman;
+
+        if (damagesource.getEntity() instanceof EntityHuman) {
+            entityhuman = (EntityHuman) damagesource.getEntity();
+        } else {
+            entityhuman = this.world.a(EntityEnderDragon.br, (double) blockposition.getX(), (double) blockposition.getY(), (double) blockposition.getZ());
+        }
+
+        if (entityendercrystal == this.currentEnderCrystal) {
+            this.a(this.bj, DamageSource.d(entityhuman), 10.0F);
+        }
+
+        this.bB.a().a(entityendercrystal, blockposition, damagesource, entityhuman);
+    }
+
+    @Override
+    public void a(DataWatcherObject<?> datawatcherobject) {
+        if (EntityEnderDragon.PHASE.equals(datawatcherobject) && this.world.isClientSide) {
+            this.bB.setControllerPhase(DragonControllerPhase.getById((Integer) this.getDataWatcher().get(EntityEnderDragon.PHASE)));
+        }
+
+        super.a(datawatcherobject);
+    }
+
+    public DragonControllerManager getDragonControllerManager() {
+        return this.bB;
+    }
+
+    @Nullable
+    public EnderDragonBattle getEnderDragonBattle() {
+        return this.bA;
+    }
+
+    @Override
+    public boolean addEffect(MobEffect mobeffect) {
+        return false;
+    }
+
+    @Override
+    protected boolean n(Entity entity) {
+        return false;
+    }
+
+    @Override
+    public boolean canPortal() {
+        return false;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/EntityWither.java b/src/main/java/net/minecraft/server/EntityWither.java
new file mode 100644
index 00000000..710e9837
--- /dev/null
+++ b/src/main/java/net/minecraft/server/EntityWither.java
@@ -0,0 +1,567 @@
+package net.minecraft.server;
+
+import com.google.common.collect.ImmutableList;
+import org.bukkit.craftbukkit.event.CraftEventFactory;
+import org.bukkit.event.entity.EntityRegainHealthEvent;
+import org.bukkit.event.entity.EntityTargetEvent;
+import org.bukkit.event.entity.ExplosionPrimeEvent;
+
+import javax.annotation.Nullable;
+import java.util.EnumSet;
+import java.util.List;
+import java.util.function.Predicate;
+// CraftBukkit end
+
+public class EntityWither extends EntityMonster implements IRangedEntity {
+
+    private static final DataWatcherObject<Integer> b = DataWatcher.a(EntityWither.class, DataWatcherRegistry.b);
+    private static final DataWatcherObject<Integer> c = DataWatcher.a(EntityWither.class, DataWatcherRegistry.b);
+    private static final DataWatcherObject<Integer> d = DataWatcher.a(EntityWither.class, DataWatcherRegistry.b);
+    private static final List<DataWatcherObject<Integer>> bj = ImmutableList.of(EntityWither.b, EntityWither.c, EntityWither.d);
+    private static final DataWatcherObject<Integer> bk = DataWatcher.a(EntityWither.class, DataWatcherRegistry.b);
+    private final float[] bl = new float[2];
+    private final float[] bm = new float[2];
+    private final float[] bn = new float[2];
+    private final float[] bo = new float[2];
+    private final int[] bp = new int[2];
+    private final int[] bq = new int[2];
+    private int br;
+    public final BossBattleServer bossBattle;
+    private static final Predicate<EntityLiving> bt = (entityliving) -> {
+        return entityliving.getMonsterType() != EnumMonsterType.UNDEAD && entityliving.eD();
+    };
+    private static final PathfinderTargetCondition bu = (new PathfinderTargetCondition()).a(20.0D).a(EntityWither.bt);
+
+    public EntityWither(EntityTypes<? extends EntityWither> entitytypes, World world) {
+        super(entitytypes, world);
+        this.bossBattle = (BossBattleServer) (new BossBattleServer(this.getScoreboardDisplayName(), BossBattle.BarColor.PURPLE, BossBattle.BarStyle.PROGRESS)).setDarkenSky(true);
+        this.setHealth(this.getMaxHealth());
+        this.getNavigation().d(true);
+        this.f = 50;
+    }
+
+    @Override
+    protected void initPathfinder() {
+        this.goalSelector.a(0, new a());
+        this.goalSelector.a(2, new PathfinderGoalArrowAttack(this, 1.0D, 40, 20.0F));
+        this.goalSelector.a(5, new PathfinderGoalRandomStrollLand(this, 1.0D));
+        this.goalSelector.a(6, new PathfinderGoalLookAtPlayer(this, EntityHuman.class, 8.0F));
+        this.goalSelector.a(7, new PathfinderGoalRandomLookaround(this));
+        this.targetSelector.a(1, new PathfinderGoalHurtByTarget(this, new Class[0]));
+        this.targetSelector.a(2, new PathfinderGoalNearestAttackableTarget<>(this, EntityInsentient.class, 0, false, false, EntityWither.bt));
+    }
+
+    @Override
+    protected void initDatawatcher() {
+        super.initDatawatcher();
+        this.datawatcher.register(EntityWither.b, 0);
+        this.datawatcher.register(EntityWither.c, 0);
+        this.datawatcher.register(EntityWither.d, 0);
+        this.datawatcher.register(EntityWither.bk, 0);
+    }
+
+    @Override
+    public void saveData(NBTTagCompound nbttagcompound) {
+        super.saveData(nbttagcompound);
+        nbttagcompound.setInt("Invul", this.getInvul());
+    }
+
+    @Override
+    public void loadData(NBTTagCompound nbttagcompound) {
+        super.loadData(nbttagcompound);
+        this.setInvul(nbttagcompound.getInt("Invul"));
+        if (this.hasCustomName()) {
+            this.bossBattle.a(this.getScoreboardDisplayName());
+        }
+
+    }
+
+    @Override
+    public void setCustomName(@Nullable IChatBaseComponent ichatbasecomponent) {
+        super.setCustomName(ichatbasecomponent);
+        this.bossBattle.a(this.getScoreboardDisplayName());
+    }
+
+    @Override
+    protected SoundEffect getSoundAmbient() {
+        return SoundEffects.WITHER_AMBIENT;
+    }
+
+    @Override
+    protected SoundEffect getSoundHurt(DamageSource damagesource) {
+        return SoundEffects.WITHER_HURT;
+    }
+
+    @Override
+    protected SoundEffect getSoundDeath() {
+        return SoundEffects.WITHER_DEATH;
+    }
+
+    @Override
+    public void movementTick() {
+        Vec3D vec3d = this.getMot().d(1.0D, 0.6D, 1.0D);
+
+        if (!this.world.isClientSide && this.getHeadTarget(0) > 0) {
+            Entity entity = this.world.getEntity(this.getHeadTarget(0));
+
+            if (entity != null) {
+                double d0 = vec3d.y;
+
+                if (this.locY() < entity.locY() || !this.S_() && this.locY() < entity.locY() + 5.0D) {
+                    d0 = Math.max(0.0D, d0);
+                    d0 += 0.3D - d0 * 0.6000000238418579D;
+                }
+
+                vec3d = new Vec3D(vec3d.x, d0, vec3d.z);
+                Vec3D vec3d1 = new Vec3D(entity.locX() - this.locX(), 0.0D, entity.locZ() - this.locZ());
+
+                if (c(vec3d1) > 9.0D) {
+                    Vec3D vec3d2 = vec3d1.d();
+
+                    vec3d = vec3d.add(vec3d2.x * 0.3D - vec3d.x * 0.6D, 0.0D, vec3d2.z * 0.3D - vec3d.z * 0.6D);
+                }
+            }
+        }
+
+        this.setMot(vec3d);
+        if (c(vec3d) > 0.05D) {
+            this.yaw = (float) MathHelper.d(vec3d.z, vec3d.x) * 57.295776F - 90.0F;
+        }
+
+        super.movementTick();
+
+        int i;
+
+        for (i = 0; i < 2; ++i) {
+            this.bo[i] = this.bm[i];
+            this.bn[i] = this.bl[i];
+        }
+
+        int j;
+
+        for (i = 0; i < 2; ++i) {
+            j = this.getHeadTarget(i + 1);
+            Entity entity1 = null;
+
+            if (j > 0) {
+                entity1 = this.world.getEntity(j);
+            }
+
+            if (entity1 != null) {
+                double d1 = this.v(i + 1);
+                double d2 = this.w(i + 1);
+                double d3 = this.x(i + 1);
+                double d4 = entity1.locX() - d1;
+                double d5 = entity1.getHeadY() - d2;
+                double d6 = entity1.locZ() - d3;
+                double d7 = (double) MathHelper.sqrt(d4 * d4 + d6 * d6);
+                float f = (float) (MathHelper.d(d6, d4) * 57.2957763671875D) - 90.0F;
+                float f1 = (float) (-(MathHelper.d(d5, d7) * 57.2957763671875D));
+
+                this.bl[i] = this.a(this.bl[i], f1, 40.0F);
+                this.bm[i] = this.a(this.bm[i], f, 10.0F);
+            } else {
+                this.bm[i] = this.a(this.bm[i], this.av, 10.0F);
+            }
+        }
+
+        boolean flag = this.S_();
+
+        for (j = 0; j < 3; ++j) {
+            double d8 = this.v(j);
+            double d9 = this.w(j);
+            double d10 = this.x(j);
+
+            this.world.addParticle(Particles.SMOKE, d8 + this.random.nextGaussian() * 0.30000001192092896D, d9 + this.random.nextGaussian() * 0.30000001192092896D, d10 + this.random.nextGaussian() * 0.30000001192092896D, 0.0D, 0.0D, 0.0D);
+            if (flag && this.world.random.nextInt(4) == 0) {
+                this.world.addParticle(Particles.ENTITY_EFFECT, d8 + this.random.nextGaussian() * 0.30000001192092896D, d9 + this.random.nextGaussian() * 0.30000001192092896D, d10 + this.random.nextGaussian() * 0.30000001192092896D, 0.699999988079071D, 0.699999988079071D, 0.5D);
+            }
+        }
+
+        if (this.getInvul() > 0) {
+            for (j = 0; j < 3; ++j) {
+                this.world.addParticle(Particles.ENTITY_EFFECT, this.locX() + this.random.nextGaussian(), this.locY() + (double) (this.random.nextFloat() * 3.3F), this.locZ() + this.random.nextGaussian(), 0.699999988079071D, 0.699999988079071D, 0.8999999761581421D);
+            }
+        }
+
+    }
+
+    @Override
+    protected void mobTick() {
+        int i;
+
+        if (this.getInvul() > 0) {
+            i = this.getInvul() - 1;
+            this.bossBattle.setProgress(1.0F - (float) i / 220.0F);
+            if (i <= 0) {
+                Explosion.Effect explosion_effect = this.world.getGameRules().getBoolean(GameRules.MOB_GRIEFING) ? Explosion.Effect.DESTROY : Explosion.Effect.NONE;
+                // CraftBukkit start
+                // this.world.createExplosion(this, this.locX(), this.getHeadY(), this.locZ(), 7.0F, false, explosion_effect);
+                ExplosionPrimeEvent event = new ExplosionPrimeEvent(this.getBukkitEntity(), 7.0F, false);
+                this.world.getServer().getPluginManager().callEvent(event);
+
+                if (!event.isCancelled()) {
+                    this.world.createExplosion(this, this.locX(), this.getHeadY(), this.locZ(), event.getRadius(), event.getFire(), explosion_effect);
+                }
+                // CraftBukkit end
+
+                if (!this.isSilent()) {
+                    // CraftBukkit start - Use relative location for far away sounds
+                    // this.world.b(1023, new BlockPosition(this), 0);
+                    int viewDistance = ((WorldServer) this.world).getServer().getViewDistance() * 16;
+                    for (EntityPlayer player : (List<EntityPlayer>) MinecraftServer.getServer().getPlayerList().players) {
+                        double deltaX = this.locX() - player.locX();
+                        double deltaZ = this.locZ() - player.locZ();
+                        double distanceSquared = deltaX * deltaX + deltaZ * deltaZ;
+                        if ( world.spigotConfig.witherSpawnSoundRadius > 0 && distanceSquared > world.spigotConfig.witherSpawnSoundRadius * world.spigotConfig.witherSpawnSoundRadius ) continue; // Spigot
+                        if (distanceSquared > viewDistance * viewDistance) {
+                            double deltaLength = Math.sqrt(distanceSquared);
+                            double relativeX = player.locX() + (deltaX / deltaLength) * viewDistance;
+                            double relativeZ = player.locZ() + (deltaZ / deltaLength) * viewDistance;
+                            player.playerConnection.sendPacket(new PacketPlayOutWorldEvent(1023, new BlockPosition((int) relativeX, (int) this.locY(), (int) relativeZ), 0, true));
+                        } else {
+                            player.playerConnection.sendPacket(new PacketPlayOutWorldEvent(1023, this.getChunkCoordinates(), 0, true));
+                        }
+                    }
+                    // CraftBukkit end
+                }
+            }
+
+            this.setInvul(i);
+            if (this.ticksLived % 10 == 0) {
+                this.heal(10.0F, EntityRegainHealthEvent.RegainReason.WITHER_SPAWN); // CraftBukkit
+            }
+
+        } else {
+            super.mobTick();
+
+            int j;
+
+            for (i = 1; i < 3; ++i) {
+                if (this.ticksLived >= this.bp[i - 1]) {
+                    this.bp[i - 1] = this.ticksLived + 10 + this.random.nextInt(10);
+                    if (this.world.getDifficulty() == EnumDifficulty.NORMAL || this.world.getDifficulty() == EnumDifficulty.HARD) {
+                        int k = i - 1;
+                        int l = this.bq[i - 1];
+
+                        this.bq[k] = this.bq[i - 1] + 1;
+                        if (l > 15) {
+                            float f = 10.0F;
+                            float f1 = 5.0F;
+                            double d0 = MathHelper.a(this.random, this.locX() - 10.0D, this.locX() + 10.0D);
+                            double d1 = MathHelper.a(this.random, this.locY() - 5.0D, this.locY() + 5.0D);
+                            double d2 = MathHelper.a(this.random, this.locZ() - 10.0D, this.locZ() + 10.0D);
+
+                            this.a(i + 1, d0, d1, d2, true);
+                            this.bq[i - 1] = 0;
+                        }
+                    }
+
+                    j = this.getHeadTarget(i);
+                    if (j > 0) {
+                        Entity entity = this.world.getEntity(j);
+
+                        if (entity != null && entity.isAlive() && this.h(entity) <= 900.0D && this.hasLineOfSight(entity)) {
+                            if (entity instanceof EntityHuman && ((EntityHuman) entity).eX().isInvulnerable) {
+                                this.setHeadTarget(i, 0);
+                            } else {
+                                this.a(i + 1, (EntityLiving) entity);
+                                this.bp[i - 1] = this.ticksLived + 40 + this.random.nextInt(20);
+                                this.bq[i - 1] = 0;
+                            }
+                        } else {
+                            this.setHeadTarget(i, 0);
+                        }
+                    } else {
+                        List<EntityLiving> list = this.world.a(EntityLiving.class, EntityWither.bu, (EntityLiving) this, this.getBoundingBox().grow(20.0D, 8.0D, 20.0D));
+
+                        for (int i1 = 0; i1 < 10 && !list.isEmpty(); ++i1) {
+                            EntityLiving entityliving = (EntityLiving) list.get(this.random.nextInt(list.size()));
+
+                            if (entityliving != this && entityliving.isAlive() && this.hasLineOfSight(entityliving)) {
+                                if (entityliving instanceof EntityHuman) {
+                                    if (!((EntityHuman) entityliving).eX().isInvulnerable) {
+                                        if (CraftEventFactory.callEntityTargetLivingEvent(this, entityliving, EntityTargetEvent.TargetReason.CLOSEST_PLAYER).isCancelled()) continue; // CraftBukkit
+                                        this.setHeadTarget(i, entityliving.getId());
+                                    }
+                                } else {
+                                    if (CraftEventFactory.callEntityTargetLivingEvent(this, entityliving, EntityTargetEvent.TargetReason.CLOSEST_ENTITY).isCancelled()) continue; // CraftBukkit
+                                    this.setHeadTarget(i, entityliving.getId());
+                                }
+                                break;
+                            }
+
+                            list.remove(entityliving);
+                        }
+                    }
+                }
+            }
+
+            if (this.getGoalTarget() != null) {
+                this.setHeadTarget(0, this.getGoalTarget().getId());
+            } else {
+                this.setHeadTarget(0, 0);
+            }
+
+            if (this.br > 0) {
+                --this.br;
+                if (this.br == 0 && this.world.getGameRules().getBoolean(GameRules.MOB_GRIEFING)) {
+                    i = MathHelper.floor(this.locY());
+                    j = MathHelper.floor(this.locX());
+                    int j1 = MathHelper.floor(this.locZ());
+                    boolean flag = false;
+
+                    for (int k1 = -1; k1 <= 1; ++k1) {
+                        for (int l1 = -1; l1 <= 1; ++l1) {
+                            for (int i2 = 0; i2 <= 3; ++i2) {
+                                int j2 = j + k1;
+                                int k2 = i + i2;
+                                int l2 = j1 + l1;
+                                BlockPosition blockposition = new BlockPosition(j2, k2, l2);
+                                IBlockData iblockdata = this.world.getType(blockposition);
+
+                                if (c(iblockdata)) {
+                                    // CraftBukkit start
+                                    if (CraftEventFactory.callEntityChangeBlockEvent(this, blockposition, Blocks.AIR.getBlockData()).isCancelled()) {
+                                        continue;
+                                    }
+                                    // CraftBukkit end
+                                    flag = this.world.a(blockposition, true, this) || flag;
+                                }
+                            }
+                        }
+                    }
+
+                    if (flag) {
+                        this.world.a((EntityHuman) null, 1022, this.getChunkCoordinates(), 0);
+                    }
+                }
+            }
+
+            if (this.ticksLived % 20 == 0) {
+                this.heal(1.0F, EntityRegainHealthEvent.RegainReason.REGEN); // CraftBukkit
+            }
+
+            this.bossBattle.setProgress(this.getHealth() / this.getMaxHealth());
+        }
+    }
+
+    public static boolean c(IBlockData iblockdata) {
+        return !iblockdata.isAir() && !iblockdata.a((Tag) TagsBlock.WITHER_IMMUNE);
+    }
+
+    public void beginSpawnSequence() {
+        this.setInvul(220);
+        this.bossBattle.setProgress(0.0F);
+        this.setHealth(this.getMaxHealth() / 3.0F);
+    }
+
+    @Override
+    public void a(IBlockData iblockdata, Vec3D vec3d) {}
+
+    @Override
+    public void b(EntityPlayer entityplayer) {
+        super.b(entityplayer);
+        this.bossBattle.addPlayer(entityplayer);
+    }
+
+    @Override
+    public void c(EntityPlayer entityplayer) {
+        super.c(entityplayer);
+        this.bossBattle.removePlayer(entityplayer);
+    }
+
+    private double v(int i) {
+        if (i <= 0) {
+            return this.locX();
+        } else {
+            float f = (this.av + (float) (180 * (i - 1))) * 0.017453292F;
+            float f1 = MathHelper.cos(f);
+
+            return this.locX() + (double) f1 * 1.3D;
+        }
+    }
+
+    private double w(int i) {
+        return i <= 0 ? this.locY() + 3.0D : this.locY() + 2.2D;
+    }
+
+    private double x(int i) {
+        if (i <= 0) {
+            return this.locZ();
+        } else {
+            float f = (this.av + (float) (180 * (i - 1))) * 0.017453292F;
+            float f1 = MathHelper.sin(f);
+
+            return this.locZ() + (double) f1 * 1.3D;
+        }
+    }
+
+    private float a(float f, float f1, float f2) {
+        float f3 = MathHelper.g(f1 - f);
+
+        if (f3 > f2) {
+            f3 = f2;
+        }
+
+        if (f3 < -f2) {
+            f3 = -f2;
+        }
+
+        return f + f3;
+    }
+
+    private void a(int i, EntityLiving entityliving) {
+        this.a(i, entityliving.locX(), entityliving.locY() + (double) entityliving.getHeadHeight() * 0.5D, entityliving.locZ(), i == 0 && this.random.nextFloat() < 0.001F);
+    }
+
+    private void a(int i, double d0, double d1, double d2, boolean flag) {
+        if (!this.isSilent()) {
+            this.world.a((EntityHuman) null, 1024, this.getChunkCoordinates(), 0);
+        }
+
+        double d3 = this.v(i);
+        double d4 = this.w(i);
+        double d5 = this.x(i);
+        double d6 = d0 - d3;
+        double d7 = d1 - d4;
+        double d8 = d2 - d5;
+        EntityWitherSkull entitywitherskull = new EntityWitherSkull(this.world, this, d6, d7, d8);
+
+        entitywitherskull.setShooter(this);
+        if (flag) {
+            entitywitherskull.setCharged(true);
+        }
+
+        entitywitherskull.setPositionRaw(d3, d4, d5);
+        this.world.addEntity(entitywitherskull);
+    }
+
+    @Override
+    public void a(EntityLiving entityliving, float f) {
+        this.a(0, entityliving);
+    }
+
+    @Override
+    public boolean damageEntity(DamageSource damagesource, float f) {
+        if (this.isInvulnerable(damagesource)) {
+            return false;
+        } else if (damagesource != DamageSource.DROWN && !(damagesource.getEntity() instanceof EntityWither)) {
+            if (this.getInvul() > 0 && damagesource != DamageSource.OUT_OF_WORLD) {
+                return false;
+            } else {
+                Entity entity;
+
+                if (this.S_()) {
+                    entity = damagesource.k();
+                    if (entity instanceof EntityArrow) {
+                        return false;
+                    }
+                }
+
+                entity = damagesource.getEntity();
+                if (entity != null && !(entity instanceof EntityHuman) && entity instanceof EntityLiving && ((EntityLiving) entity).getMonsterType() == this.getMonsterType()) {
+                    return false;
+                } else {
+                    if (this.br <= 0) {
+                        this.br = 20;
+                    }
+
+                    for (int i = 0; i < this.bq.length; ++i) {
+                        this.bq[i] += 3;
+                    }
+
+                    return super.damageEntity(damagesource, f);
+                }
+            }
+        } else {
+            return false;
+        }
+    }
+
+    @Override
+    protected void dropDeathLoot(DamageSource damagesource, int i, boolean flag) {
+        super.dropDeathLoot(damagesource, i, flag);
+        EntityItem entityitem = this.a((IMaterial) Items.NETHER_STAR);
+
+        if (entityitem != null) {
+            entityitem.r();
+        }
+
+    }
+
+    @Override
+    public void checkDespawn() {
+        if (this.world.getDifficulty() == EnumDifficulty.PEACEFUL && this.L()) {
+            this.ab();
+        } else {
+            this.ticksFarFromPlayer = 0;
+        }
+    }
+
+    @Override
+    public boolean b(float f, float f1) {
+        return false;
+    }
+
+    @Override
+    public boolean addEffect(MobEffect mobeffect) {
+        return false;
+    }
+
+    public static AttributeProvider.Builder ff() {
+        return EntityMonster.fm().a(GenericAttributes.MAX_HEALTH, 300.0D).a(GenericAttributes.MOVEMENT_SPEED, 0.6000000238418579D).a(GenericAttributes.FOLLOW_RANGE, 40.0D).a(GenericAttributes.ARMOR, 4.0D);
+    }
+
+    public int getInvul() {
+        return (Integer) this.datawatcher.get(EntityWither.bk);
+    }
+
+    public void setInvul(int i) {
+        this.datawatcher.set(EntityWither.bk, i);
+    }
+
+    public int getHeadTarget(int i) {
+        return (Integer) this.datawatcher.get((DataWatcherObject) EntityWither.bj.get(i));
+    }
+
+    public void setHeadTarget(int i, int j) {
+        this.datawatcher.set((DataWatcherObject) EntityWither.bj.get(i), j);
+    }
+
+    public boolean S_() {
+        return this.getHealth() <= this.getMaxHealth() / 2.0F;
+    }
+
+    @Override
+    public EnumMonsterType getMonsterType() {
+        return EnumMonsterType.UNDEAD;
+    }
+
+    @Override
+    protected boolean n(Entity entity) {
+        return false;
+    }
+
+    @Override
+    public boolean canPortal() {
+        return false;
+    }
+
+    @Override
+    public boolean d(MobEffect mobeffect) {
+        return mobeffect.getMobEffect() == MobEffects.WITHER ? false : super.d(mobeffect);
+    }
+
+    class a extends PathfinderGoal {
+
+        public a() {
+            this.a(EnumSet.of(Type.MOVE, Type.JUMP, Type.LOOK));
+        }
+
+        @Override
+        public boolean a() {
+            return EntityWither.this.getInvul() > 0;
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/server/ItemEnderEye.java b/src/main/java/net/minecraft/server/ItemEnderEye.java
new file mode 100644
index 00000000..7b8d52a8
--- /dev/null
+++ b/src/main/java/net/minecraft/server/ItemEnderEye.java
@@ -0,0 +1,107 @@
+package net.minecraft.server;
+
+public class ItemEnderEye extends Item {
+
+    public ItemEnderEye(Info item_info) {
+        super(item_info);
+    }
+
+    @Override
+    public EnumInteractionResult a(ItemActionContext itemactioncontext) {
+        World world = itemactioncontext.getWorld();
+        BlockPosition blockposition = itemactioncontext.getClickPosition();
+        IBlockData iblockdata = world.getType(blockposition);
+
+        if (iblockdata.a(Blocks.END_PORTAL_FRAME) && !(Boolean) iblockdata.get(BlockEnderPortalFrame.EYE)) {
+            if (world.isClientSide) {
+                return EnumInteractionResult.SUCCESS;
+            } else {
+                IBlockData iblockdata1 = (IBlockData) iblockdata.set(BlockEnderPortalFrame.EYE, true);
+
+                Block.a(iblockdata, iblockdata1, world, blockposition);
+                world.setTypeAndData(blockposition, iblockdata1, 2);
+                world.updateAdjacentComparators(blockposition, Blocks.END_PORTAL_FRAME);
+                itemactioncontext.getItemStack().subtract(1);
+                world.triggerEffect(1503, blockposition, 0);
+                ShapeDetector.ShapeDetectorCollection shapedetector_shapedetectorcollection = BlockEnderPortalFrame.c().a(world, blockposition);
+
+                if (shapedetector_shapedetectorcollection != null) {
+                    BlockPosition blockposition1 = shapedetector_shapedetectorcollection.a().b(-3, 0, -3);
+
+                    for (int i = 0; i < 3; ++i) {
+                        for (int j = 0; j < 3; ++j) {
+                            world.setTypeAndData(blockposition1.b(i, 0, j), Blocks.END_PORTAL.getBlockData(), 2);
+                        }
+                    }
+
+                    world.b(1038, blockposition1.b(1, 0, 1), 0);
+                    // CraftBukkit start - Use relative location for far away sounds
+                    // world.b(1038, blockposition1.b(1, 0, 1), 0);
+                    int viewDistance = world.getServer().getViewDistance() * 16;
+                    BlockPosition soundPos = blockposition1.b(1, 0, 1);
+                    for (EntityPlayer player : world.getServer().getServer().getPlayerList().players) {
+                        double deltaX = soundPos.getX() - player.locX();
+                        double deltaZ = soundPos.getZ() - player.locZ();
+                        double distanceSquared = deltaX * deltaX + deltaZ * deltaZ;
+                        if (world.spigotConfig.endPortalSoundRadius > 0 && distanceSquared > world.spigotConfig.endPortalSoundRadius * world.spigotConfig.endPortalSoundRadius) continue; // Spigot
+                        if (distanceSquared > viewDistance * viewDistance) {
+                            double deltaLength = Math.sqrt(distanceSquared);
+                            double relativeX = player.locX() + (deltaX / deltaLength) * viewDistance;
+                            double relativeZ = player.locZ() + (deltaZ / deltaLength) * viewDistance;
+                            player.playerConnection.sendPacket(new PacketPlayOutWorldEvent(1038, new BlockPosition((int) relativeX, (int) soundPos.getY(), (int) relativeZ), 0, true));
+                        } else {
+                            player.playerConnection.sendPacket(new PacketPlayOutWorldEvent(1038, soundPos, 0, true));
+                        }
+                    }
+                    // CraftBukkit end
+                }
+
+                return EnumInteractionResult.CONSUME;
+            }
+        } else {
+            return EnumInteractionResult.PASS;
+        }
+    }
+
+    @Override
+    public InteractionResultWrapper<ItemStack> a(World world, EntityHuman entityhuman, EnumHand enumhand) {
+        ItemStack itemstack = entityhuman.b(enumhand);
+        MovingObjectPositionBlock movingobjectpositionblock = a(world, entityhuman, RayTrace.FluidCollisionOption.NONE);
+
+        if (movingobjectpositionblock.getType() == MovingObjectPosition.EnumMovingObjectType.BLOCK && world.getType(((MovingObjectPositionBlock) movingobjectpositionblock).getBlockPosition()).a(Blocks.END_PORTAL_FRAME)) {
+            return InteractionResultWrapper.pass(itemstack);
+        } else {
+            entityhuman.c(enumhand);
+            if (world instanceof WorldServer) {
+                BlockPosition blockposition = ((WorldServer) world).getChunkProvider().getChunkGenerator().findNearestMapFeature((WorldServer) world, StructureGenerator.STRONGHOLD, entityhuman.getChunkCoordinates(), 100, false);
+
+                if (blockposition != null) {
+                    EntityEnderSignal entityendersignal = new EntityEnderSignal(world, entityhuman.locX(), entityhuman.e(0.5D), entityhuman.locZ());
+
+                    entityendersignal.setItem(itemstack);
+                    entityendersignal.a(blockposition);
+                    // CraftBukkit start
+                    if (!world.addEntity(entityendersignal)) {
+                        return new InteractionResultWrapper(EnumInteractionResult.FAIL, itemstack);
+                    }
+                    // CraftBukkit end
+                    if (entityhuman instanceof EntityPlayer) {
+                        CriterionTriggers.m.a((EntityPlayer) entityhuman, blockposition);
+                    }
+
+                    world.playSound((EntityHuman) null, entityhuman.locX(), entityhuman.locY(), entityhuman.locZ(), SoundEffects.ENDER_EYE_LAUNCH, SoundCategory.NEUTRAL, 0.5F, 0.4F / (world.getRandom().nextFloat() * 0.4F + 0.8F));
+                    world.a((EntityHuman) null, 1003, entityhuman.getChunkCoordinates(), 0);
+                    if (!entityhuman.eX().canInstantlyBuild) {
+                        itemstack.subtract(1);
+                    }
+
+                    entityhuman.b(StatisticList.ITEM_USED.b(this));
+                    entityhuman.swingHand(enumhand, true);
+                    return InteractionResultWrapper.success(itemstack);
+                }
+            }
+
+            return InteractionResultWrapper.consume(itemstack);
+        }
+    }
+}
diff --git a/src/main/java/org/spigotmc/SpigotWorldConfig.java b/src/main/java/org/spigotmc/SpigotWorldConfig.java
index 02326721..35d01cba 100644
--- a/src/main/java/org/spigotmc/SpigotWorldConfig.java
+++ b/src/main/java/org/spigotmc/SpigotWorldConfig.java
@@ -251,4 +251,22 @@ public class SpigotWorldConfig
         enableZombiePigmenPortalSpawns = getBoolean( "enable-zombie-pigmen-portal-spawns", true );
         log( "Allow Zombie Pigmen to spawn from portal blocks: " + enableZombiePigmenPortalSpawns );
     }
+
+    public int dragonDeathSoundRadius;
+    private void keepDragonDeathPerWorld()
+    {
+        dragonDeathSoundRadius = getInt( "dragon-death-sound-radius", 0 );
+    }
+
+    public int witherSpawnSoundRadius;
+    private void witherSpawnSoundRadius()
+    {
+        witherSpawnSoundRadius = getInt( "wither-spawn-sound-radius", 0 );
+    }
+
+    public int endPortalSoundRadius;
+    private void endPortalSoundRadius()
+    {
+        endPortalSoundRadius = getInt( "end-portal-sound-radius", 0 );
+    }
 }
-- 
2.21.0.windows.1

