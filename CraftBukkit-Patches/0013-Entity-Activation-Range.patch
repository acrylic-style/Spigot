From fd0d81361df38e307306d519b0b62791b4ed92da Mon Sep 17 00:00:00 2001
From: Aikar <aikar@aikar.co>
Date: Sun, 3 Feb 2013 05:10:21 -0500
Subject: [PATCH] Entity Activation Range

This feature gives 3 new configurable ranges that if an entity of the matching type is outside of this radius of any player, will tick at 5% of its normal rate.

This will drastically cut down on tick timings for entities that are not in range of a user to actually be "used".
This change can have dramatic impact on gameplay if configured too low. Balance according to your servers desired gameplay.

diff --git a/src/main/java/net/minecraft/server/Entity.java b/src/main/java/net/minecraft/server/Entity.java
new file mode 100644
index 00000000..66e02ad2
--- /dev/null
+++ b/src/main/java/net/minecraft/server/Entity.java
@@ -0,0 +1,3303 @@
+package net.minecraft.server;
+
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.Iterables;
+import com.google.common.collect.Lists;
+import com.google.common.collect.Sets;
+import com.google.common.collect.UnmodifiableIterator;
+import it.unimi.dsi.fastutil.objects.Object2DoubleArrayMap;
+import it.unimi.dsi.fastutil.objects.Object2DoubleMap;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Locale;
+import java.util.Optional;
+import java.util.Random;
+import java.util.Set;
+import java.util.UUID;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.function.Predicate;
+import java.util.stream.Stream;
+import javax.annotation.Nullable;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+
+// CraftBukkit start
+import org.bukkit.Bukkit;
+import org.bukkit.Location;
+import org.bukkit.Server;
+import org.bukkit.block.BlockFace;
+import org.bukkit.command.CommandSender;
+import org.bukkit.craftbukkit.event.CraftPortalEvent;
+import org.bukkit.entity.Hanging;
+import org.bukkit.entity.LivingEntity;
+import org.bukkit.entity.Vehicle;
+import org.spigotmc.CustomTimingsHandler; // Spigot
+import org.bukkit.event.entity.EntityCombustByEntityEvent;
+import org.bukkit.event.hanging.HangingBreakByEntityEvent;
+import org.bukkit.event.vehicle.VehicleBlockCollisionEvent;
+import org.bukkit.event.vehicle.VehicleEnterEvent;
+import org.bukkit.event.vehicle.VehicleExitEvent;
+import org.bukkit.craftbukkit.CraftWorld;
+import org.bukkit.craftbukkit.entity.CraftEntity;
+import org.bukkit.craftbukkit.entity.CraftPlayer;
+import org.bukkit.craftbukkit.event.CraftEventFactory;
+import org.bukkit.entity.Pose;
+import org.bukkit.event.entity.EntityAirChangeEvent;
+import org.bukkit.event.entity.EntityCombustEvent;
+import org.bukkit.event.entity.EntityDropItemEvent;
+import org.bukkit.event.entity.EntityPortalEvent;
+import org.bukkit.event.entity.EntityPoseChangeEvent;
+import org.bukkit.event.player.PlayerTeleportEvent;
+import org.bukkit.plugin.PluginManager;
+// CraftBukkit end
+
+public abstract class Entity implements INamableTileEntity, EntityAccess, ICommandListener {
+
+    // CraftBukkit start
+    private static final int CURRENT_LEVEL = 2;
+    static boolean isLevelAtLeast(NBTTagCompound tag, int level) {
+        return tag.hasKey("Bukkit.updateLevel") && tag.getInt("Bukkit.updateLevel") >= level;
+    }
+
+    private CraftEntity bukkitEntity;
+
+    public CraftEntity getBukkitEntity() {
+        if (bukkitEntity == null) {
+            bukkitEntity = CraftEntity.getEntity(world.getServer(), this);
+        }
+        return bukkitEntity;
+    }
+
+    @Override
+    public CommandSender getBukkitSender(CommandListenerWrapper wrapper) {
+        return getBukkitEntity();
+    }
+    // CraftBukkit end
+
+    protected static final Logger LOGGER = LogManager.getLogger();
+    private static final AtomicInteger entityCount = new AtomicInteger();
+    private static final List<ItemStack> c = Collections.emptyList();
+    private static final AxisAlignedBB d = new AxisAlignedBB(0.0D, 0.0D, 0.0D, 0.0D, 0.0D, 0.0D);
+    private static double e = 1.0D;
+    private final EntityTypes<?> f;
+    private int id;
+    public boolean i;
+    public ImmutableList<Entity> passengers;
+    protected int j;
+    @Nullable
+    private Entity vehicle;
+    public World world;
+    public double lastX;
+    public double lastY;
+    public double lastZ;
+    private Vec3D loc;
+    private BlockPosition locBlock;
+    private Vec3D mot;
+    public float yaw;
+    public float pitch;
+    public float lastYaw;
+    public float lastPitch;
+    private AxisAlignedBB boundingBox;
+    protected boolean onGround;
+    public boolean positionChanged;
+    public boolean u;
+    public boolean velocityChanged;
+    protected Vec3D w;
+    @Nullable
+    public Entity.RemovalReason dead; // CraftBukkit - private -> public
+    public float x;
+    public float y;
+    public float z;
+    public float fallDistance;
+    private float ai;
+    private float aj;
+    public double B;
+    public double C;
+    public double D;
+    public float E;
+    public boolean noclip;
+    public float G;
+    protected final Random random;
+    public int ticksLived;
+    public int fireTicks;
+    public boolean inWater;
+    protected Object2DoubleMap<Tag<FluidType>> K;
+    protected boolean L;
+    @Nullable
+    protected Tag<FluidType> M;
+    public int noDamageTicks;
+    protected boolean justCreated;
+    protected final DataWatcher datawatcher;
+    protected static final DataWatcherObject<Byte> Q = DataWatcher.a(Entity.class, DataWatcherRegistry.a);
+    private static final DataWatcherObject<Integer> al = DataWatcher.a(Entity.class, DataWatcherRegistry.b);
+    private static final DataWatcherObject<Optional<IChatBaseComponent>> am = DataWatcher.a(Entity.class, DataWatcherRegistry.f);
+    private static final DataWatcherObject<Boolean> an = DataWatcher.a(Entity.class, DataWatcherRegistry.i);
+    private static final DataWatcherObject<Boolean> ao = DataWatcher.a(Entity.class, DataWatcherRegistry.i);
+    private static final DataWatcherObject<Boolean> ap = DataWatcher.a(Entity.class, DataWatcherRegistry.i);
+    protected static final DataWatcherObject<EntityPose> POSE = DataWatcher.a(Entity.class, DataWatcherRegistry.s);
+    private static final DataWatcherObject<Integer> AIR_TICKS = DataWatcher.a(Entity.class, DataWatcherRegistry.b);
+    private EntityInWorldCallback ar;
+    private Vec3D as;
+    public boolean S;
+    public boolean impulse;
+    public int portalCooldown;
+    protected boolean inPortal;
+    protected int portalTicks;
+    protected BlockPosition W;
+    private boolean invulnerable;
+    protected UUID uniqueID;
+    protected String Y;
+    public boolean glowing;
+    private final Set<String> av;
+    private final double[] aw;
+    private long ax;
+    private EntitySize size;
+    private float headHeight;
+    protected boolean aa;
+    private float aA;
+    private int aB;
+    // CraftBukkit start
+    public boolean persist = true;
+    public boolean valid;
+    public org.bukkit.projectiles.ProjectileSource projectileSource; // For projectiles only
+    public boolean forceExplosionKnockback; // SPIGOT-949
+    public boolean persistentInvisibility = false;
+    public CustomTimingsHandler tickTimer = org.bukkit.craftbukkit.SpigotTimings.getEntityTimings(this); // Spigot
+    // Spigot start
+    public final org.spigotmc.ActivationRange.ActivationType activationType = org.spigotmc.ActivationRange.initializeEntityActivationType(this);
+    public final boolean defaultActivationState;
+    public long activatedTick = Integer.MIN_VALUE;
+    public void inactiveTick() { }
+    // Spigot end
+
+    public float getBukkitYaw() {
+        return this.yaw;
+    }
+
+    public boolean isChunkLoaded() {
+        return world.isChunkLoaded((int) Math.floor(this.locX()) >> 4, (int) Math.floor(this.locZ()) >> 4);
+    }
+    // CraftBukkit end
+
+    public Entity(EntityTypes<?> entitytypes, World world) {
+        this.id = Entity.entityCount.incrementAndGet();
+        this.passengers = ImmutableList.of();
+        this.mot = Vec3D.ORIGIN;
+        this.boundingBox = Entity.d;
+        this.w = Vec3D.ORIGIN;
+        this.ai = 1.0F;
+        this.aj = 1.0F;
+        this.random = new Random();
+        this.fireTicks = -this.getMaxFireTicks();
+        this.K = new Object2DoubleArrayMap(2);
+        this.justCreated = true;
+        this.ar = EntityInWorldCallback.a;
+        this.uniqueID = MathHelper.a(this.random);
+        this.Y = this.uniqueID.toString();
+        this.av = Sets.newHashSet();
+        this.aw = new double[]{0.0D, 0.0D, 0.0D};
+        this.f = entitytypes;
+        this.world = world;
+        this.size = entitytypes.m();
+        this.loc = Vec3D.ORIGIN;
+        this.locBlock = BlockPosition.ZERO;
+        this.as = Vec3D.ORIGIN;
+        this.setPosition(0.0D, 0.0D, 0.0D);
+        // Spigot start
+        if (world != null) {
+            this.defaultActivationState = org.spigotmc.ActivationRange.initializeEntityActivationState(this, world.spigotConfig);
+        } else {
+            this.defaultActivationState = false;
+        }
+        // Spigot end
+        this.datawatcher = new DataWatcher(this);
+        this.datawatcher.register(Entity.Q, (byte) 0);
+        this.datawatcher.register(Entity.al, this.bK());
+        this.datawatcher.register(Entity.an, false);
+        this.datawatcher.register(Entity.am, Optional.empty());
+        this.datawatcher.register(Entity.ao, false);
+        this.datawatcher.register(Entity.ap, false);
+        this.datawatcher.register(Entity.POSE, EntityPose.STANDING);
+        this.datawatcher.register(Entity.AIR_TICKS, 0);
+        this.initDatawatcher();
+        this.headHeight = this.getHeadHeight(EntityPose.STANDING, this.size);
+    }
+
+    public boolean isSpectator() {
+        return false;
+    }
+
+    public final void decouple() {
+        if (this.isVehicle()) {
+            this.ejectPassengers();
+        }
+
+        if (this.isPassenger()) {
+            this.stopRiding();
+        }
+
+    }
+
+    public void c(double d0, double d1, double d2) {
+        this.a(new Vec3D(d0, d1, d2));
+    }
+
+    public void a(Vec3D vec3d) {
+        this.as = vec3d;
+    }
+
+    public EntityTypes<?> getEntityType() {
+        return this.f;
+    }
+
+    @Override
+    public int getId() {
+        return this.id;
+    }
+
+    public void e(int i) {
+        this.id = i;
+    }
+
+    public Set<String> getScoreboardTags() {
+        return this.av;
+    }
+
+    public boolean addScoreboardTag(String s) {
+        return this.av.size() >= 1024 ? false : this.av.add(s);
+    }
+
+    public boolean removeScoreboardTag(String s) {
+        return this.av.remove(s);
+    }
+
+    public void die() { killEntity(); } // CraftBukkit
+
+    public void killEntity() {
+        this.a(Entity.RemovalReason.KILLED);
+    }
+
+    public final void ab() {
+        this.a(Entity.RemovalReason.DISCARDED);
+    }
+
+    protected abstract void initDatawatcher();
+
+    public DataWatcher getDataWatcher() {
+        return this.datawatcher;
+    }
+
+    public boolean equals(Object object) {
+        return object instanceof Entity ? ((Entity) object).id == this.id : false;
+    }
+
+    public int hashCode() {
+        return this.id;
+    }
+
+    public void a(Entity.RemovalReason entity_removalreason) {
+        this.die(entity_removalreason);
+    }
+
+    public void setPose(EntityPose entitypose) {
+        // CraftBukkit start
+        if (entitypose == this.getPose()) {
+            return;
+        }
+        this.world.getServer().getPluginManager().callEvent(new EntityPoseChangeEvent(this.getBukkitEntity(), Pose.values()[entitypose.ordinal()]));
+        // CraftBukkit end
+        this.datawatcher.set(Entity.POSE, entitypose);
+    }
+
+    public EntityPose getPose() {
+        return (EntityPose) this.datawatcher.get(Entity.POSE);
+    }
+
+    public boolean a(Entity entity, double d0) {
+        double d1 = entity.loc.x - this.loc.x;
+        double d2 = entity.loc.y - this.loc.y;
+        double d3 = entity.loc.z - this.loc.z;
+
+        return d1 * d1 + d2 * d2 + d3 * d3 < d0 * d0;
+    }
+
+    protected void setYawPitch(float f, float f1) {
+        // CraftBukkit start - yaw was sometimes set to NaN, so we need to set it back to 0
+        if (Float.isNaN(f)) {
+            f = 0;
+        }
+
+        if (f == Float.POSITIVE_INFINITY || f == Float.NEGATIVE_INFINITY) {
+            if (this instanceof EntityPlayer) {
+                this.world.getServer().getLogger().warning(this.getName() + " was caught trying to crash the server with an invalid yaw");
+                ((CraftPlayer) this.getBukkitEntity()).kickPlayer("Infinite yaw (Hacking?)");
+            }
+            f = 0;
+        }
+
+        // pitch was sometimes set to NaN, so we need to set it back to 0
+        if (Float.isNaN(f1)) {
+            f1 = 0;
+        }
+
+        if (f1 == Float.POSITIVE_INFINITY || f1 == Float.NEGATIVE_INFINITY) {
+            if (this instanceof EntityPlayer) {
+                this.world.getServer().getLogger().warning(this.getName() + " was caught trying to crash the server with an invalid pitch");
+                ((CraftPlayer) this.getBukkitEntity()).kickPlayer("Infinite pitch (Hacking?)");
+            }
+            f1 = 0;
+        }
+        // CraftBukkit end
+
+        this.yaw = f % 360.0F;
+        this.pitch = f1 % 360.0F;
+    }
+
+    public void setPosition(double d0, double d1, double d2) {
+        this.setPositionRaw(d0, d1, d2);
+        this.a(this.size.a(d0, d1, d2));
+        //if (valid) ((WorldServer) world).chunkCheck(this); // CraftBukkit
+    }
+
+    protected void af() {
+        this.setPosition(this.loc.x, this.loc.y, this.loc.z);
+    }
+
+    public void tick() {
+        if (!this.world.isClientSide) {
+            this.setFlag(6, this.bG());
+        }
+
+        this.entityBaseTick();
+    }
+
+    // CraftBukkit start
+    public void postTick() {
+        // No clean way to break out of ticking once the entity has been copied to a new world, so instead we move the portalling later in the tick cycle
+        if (!(this instanceof EntityPlayer)) {
+            this.doPortalTick();
+        }
+    }
+    // CraftBukkit end
+
+    public void entityBaseTick() {
+        this.world.getMethodProfiler().enter("entityBaseTick");
+        if (this.isPassenger() && this.getVehicle().cW()) {
+            this.stopRiding();
+        }
+
+        if (this.j > 0) {
+            --this.j;
+        }
+
+        this.x = this.y;
+        this.lastPitch = this.pitch;
+        this.lastYaw = this.yaw;
+        if (this instanceof EntityPlayer) this.doPortalTick(); // CraftBukkit - // Moved up to postTick
+        if (this.aQ()) {
+            this.aR();
+        }
+
+        this.aa = false;
+        this.aM();
+        this.m();
+        this.aL();
+        if (this.world.isClientSide) {
+            this.extinguish();
+        } else if (this.fireTicks > 0) {
+            if (this.isFireProof()) {
+                this.setFireTicks(this.fireTicks - 4);
+                if (this.fireTicks < 0) {
+                    this.extinguish();
+                }
+            } else {
+                if (this.fireTicks % 20 == 0 && !this.aS()) {
+                    this.damageEntity(DamageSource.BURN, 1.0F);
+                }
+
+                this.setFireTicks(this.fireTicks - 1);
+            }
+
+            this.setAirTicks(0);
+        }
+
+        if (this.aS()) {
+            this.burnFromLava();
+            this.fallDistance *= 0.5F;
+        }
+
+        this.resetPortalCooldown();
+        if (!this.world.isClientSide) {
+            this.setFlag(0, this.fireTicks > 0);
+        }
+
+        this.justCreated = false;
+        this.world.getMethodProfiler().exit();
+    }
+
+    public void resetPortalCooldown() {
+        if (this.locY() < (double) (this.world.getMinBuildHeight() - 64)) {
+            this.ao();
+        }
+
+    }
+
+    public void ai() {
+        this.portalCooldown = this.getDefaultPortalCooldown();
+    }
+
+    public boolean aj() {
+        return this.portalCooldown > 0;
+    }
+
+    protected void E() {
+        if (this.aj()) {
+            --this.portalCooldown;
+        }
+
+    }
+
+    public int ak() {
+        return 0;
+    }
+
+    public void burnFromLava() {
+        if (!this.isFireProof()) {
+            // CraftBukkit start - Fallen in lava TODO: this event spams!
+            if (this instanceof EntityLiving && fireTicks <= 0) {
+                // not on fire yet
+                // TODO: shouldn't be sending null for the block
+                org.bukkit.block.Block damager = null; // ((WorldServer) this.l).getWorld().getBlockAt(i, j, k);
+                org.bukkit.entity.Entity damagee = this.getBukkitEntity();
+                EntityCombustEvent combustEvent = new org.bukkit.event.entity.EntityCombustByBlockEvent(damager, damagee, 15);
+                this.world.getServer().getPluginManager().callEvent(combustEvent);
+
+                if (!combustEvent.isCancelled()) {
+                    this.setOnFire(combustEvent.getDuration(), false);
+                }
+            } else {
+                // This will be called every single tick the entity is in lava, so don't throw an event
+                this.setOnFire(15, false);
+            }
+            // CraftBukkit end - we also don't throw an event unless the object in lava is living, to save on some event calls
+            this.damageEntity(DamageSource.LAVA, 4.0F);
+        }
+    }
+
+    public void setOnFire(int i) {
+        // CraftBukkit start
+        this.setOnFire(i, true);
+    }
+
+    public void setOnFire(int i, boolean callEvent) {
+        if (callEvent) {
+            EntityCombustEvent event = new EntityCombustEvent(this.getBukkitEntity(), i);
+            this.world.getServer().getPluginManager().callEvent(event);
+
+            if (event.isCancelled()) {
+                return;
+            }
+
+            i = event.getDuration();
+        }
+        // CraftBukkit end
+        int j = i * 20;
+
+        if (this instanceof EntityLiving) {
+            j = EnchantmentProtection.a((EntityLiving) this, j);
+        }
+
+        if (this.fireTicks < j) {
+            this.setFireTicks(j);
+        }
+
+    }
+
+    public void setFireTicks(int i) {
+        this.fireTicks = i;
+    }
+
+    public int getFireTicks() {
+        return this.fireTicks;
+    }
+
+    public void extinguish() {
+        this.setFireTicks(0);
+    }
+
+    protected void ao() {
+        this.ab();
+    }
+
+    public boolean e(double d0, double d1, double d2) {
+        return this.b(this.getBoundingBox().d(d0, d1, d2));
+    }
+
+    private boolean b(AxisAlignedBB axisalignedbb) {
+        return this.world.getCubes(this, axisalignedbb) && !this.world.containsLiquid(axisalignedbb);
+    }
+
+    public void setOnGround(boolean flag) {
+        this.onGround = flag;
+    }
+
+    public boolean isOnGround() {
+        return this.onGround;
+    }
+
+    public void move(EnumMoveType enummovetype, Vec3D vec3d) {
+        org.bukkit.craftbukkit.SpigotTimings.entityMoveTimer.startTiming(); // Spigot
+        if (this.noclip) {
+            this.a(this.getBoundingBox().c(vec3d));
+            this.recalcPosition();
+        } else {
+            if (enummovetype == EnumMoveType.PISTON) {
+                vec3d = this.b(vec3d);
+                if (vec3d.equals(Vec3D.ORIGIN)) {
+                    return;
+                }
+            }
+
+            this.world.getMethodProfiler().enter("move");
+            if (this.w.g() > 1.0E-7D) {
+                vec3d = vec3d.h(this.w);
+                this.w = Vec3D.ORIGIN;
+                this.setMot(Vec3D.ORIGIN);
+            }
+
+            vec3d = this.a(vec3d, enummovetype);
+            Vec3D vec3d1 = this.g(vec3d);
+
+            if (vec3d1.g() > 1.0E-7D) {
+                this.a(this.getBoundingBox().c(vec3d1));
+                this.recalcPosition();
+            }
+
+            this.world.getMethodProfiler().exit();
+            this.world.getMethodProfiler().enter("rest");
+            this.positionChanged = !MathHelper.b(vec3d.x, vec3d1.x) || !MathHelper.b(vec3d.z, vec3d1.z);
+            this.u = vec3d.y != vec3d1.y;
+            this.onGround = this.u && vec3d.y < 0.0D;
+            BlockPosition blockposition = this.aq();
+            IBlockData iblockdata = this.world.getType(blockposition);
+
+            this.a(vec3d1.y, this.onGround, iblockdata, blockposition);
+            Vec3D vec3d2 = this.getMot();
+
+            if (vec3d.x != vec3d1.x) {
+                this.setMot(0.0D, vec3d2.y, vec3d2.z);
+            }
+
+            if (vec3d.z != vec3d1.z) {
+                this.setMot(vec3d2.x, vec3d2.y, 0.0D);
+            }
+
+            Block block = iblockdata.getBlock();
+
+            if (vec3d.y != vec3d1.y) {
+                block.a((IBlockAccess) this.world, this);
+            }
+
+            // CraftBukkit start
+            if (positionChanged && getBukkitEntity() instanceof Vehicle) {
+                Vehicle vehicle = (Vehicle) this.getBukkitEntity();
+                org.bukkit.block.Block bl = this.world.getWorld().getBlockAt(MathHelper.floor(this.locX()), MathHelper.floor(this.locY()), MathHelper.floor(this.locZ()));
+
+                if (vec3d.x > vec3d1.x) {
+                    bl = bl.getRelative(BlockFace.EAST);
+                } else if (vec3d.x < vec3d1.x) {
+                    bl = bl.getRelative(BlockFace.WEST);
+                } else if (vec3d.z > vec3d1.z) {
+                    bl = bl.getRelative(BlockFace.SOUTH);
+                } else if (vec3d.z < vec3d1.z) {
+                    bl = bl.getRelative(BlockFace.NORTH);
+                }
+
+                if (!bl.getType().isAir()) {
+                    VehicleBlockCollisionEvent event = new VehicleBlockCollisionEvent(vehicle, bl);
+                    world.getServer().getPluginManager().callEvent(event);
+                }
+            }
+            // CraftBukkit end
+
+            if (this.onGround && !this.bx()) {
+                block.stepOn(this.world, blockposition, this);
+            }
+
+            if (this.playStepSound() && !this.isPassenger()) {
+                double d0 = vec3d1.x;
+                double d1 = vec3d1.y;
+                double d2 = vec3d1.z;
+
+                if (!iblockdata.a((Tag) TagsBlock.CLIMBABLE) && !iblockdata.a(Blocks.POWDER_SNOW)) {
+                    d1 = 0.0D;
+                }
+
+                this.y = (float) ((double) this.y + (double) MathHelper.sqrt(c(vec3d1)) * 0.6D);
+                this.z = (float) ((double) this.z + (double) MathHelper.sqrt(d0 * d0 + d1 * d1 + d2 * d2) * 0.6D);
+                if (this.z > this.ai && !iblockdata.isAir()) {
+                    this.ai = this.au();
+                    if (this.isInWater()) {
+                        Entity entity = this.isVehicle() && this.getRidingPassenger() != null ? this.getRidingPassenger() : this;
+                        float f = entity == this ? 0.35F : 0.4F;
+                        Vec3D vec3d3 = entity.getMot();
+                        float f1 = MathHelper.sqrt(vec3d3.x * vec3d3.x * 0.20000000298023224D + vec3d3.y * vec3d3.y + vec3d3.z * vec3d3.z * 0.20000000298023224D) * f;
+
+                        if (f1 > 1.0F) {
+                            f1 = 1.0F;
+                        }
+
+                        this.d(f1);
+                        this.a(ckz.b);
+                    } else {
+                        this.b(blockposition, iblockdata);
+                        if (!iblockdata.a((Tag) TagsBlock.aO)) {
+                            this.a(ckz.a);
+                        }
+                    }
+                } else if (this.z > this.aj && this.aA() && iblockdata.isAir()) {
+                    this.aj = this.e(this.z);
+                    this.a(ckz.c);
+                }
+            }
+
+            try {
+                this.checkBlockCollisions();
+            } catch (Throwable throwable) {
+                CrashReport crashreport = CrashReport.a(throwable, "Checking entity block collision");
+                CrashReportSystemDetails crashreportsystemdetails = crashreport.a("Entity being checked for collision");
+
+                this.appendEntityCrashDetails(crashreportsystemdetails);
+                throw new ReportedException(crashreport);
+            }
+
+            float f2 = this.getBlockSpeedFactor();
+
+            this.setMot(this.getMot().d((double) f2, 1.0D, (double) f2));
+            if (this.world.c(this.getBoundingBox().shrink(0.001D)).noneMatch((iblockdata1) -> {
+                return iblockdata1.a((Tag) TagsBlock.FIRE) || iblockdata1.a(Blocks.LAVA);
+            }) && this.fireTicks <= 0) {
+                this.setFireTicks(-this.getMaxFireTicks());
+            }
+
+            if ((this.aI() || this.aa) && this.isBurning()) {
+                this.playSound(SoundEffects.GENERIC_EXTINGUISH_FIRE, 0.7F, 1.6F + (this.random.nextFloat() - this.random.nextFloat()) * 0.4F);
+                this.setFireTicks(-this.getMaxFireTicks());
+            }
+
+            this.world.getMethodProfiler().exit();
+        }
+        org.bukkit.craftbukkit.SpigotTimings.entityMoveTimer.stopTiming(); // Spigot
+    }
+
+    protected BlockPosition aq() {
+        int i = MathHelper.floor(this.loc.x);
+        int j = MathHelper.floor(this.loc.y - 0.20000000298023224D);
+        int k = MathHelper.floor(this.loc.z);
+        BlockPosition blockposition = new BlockPosition(i, j, k);
+
+        if (this.world.getType(blockposition).isAir()) {
+            BlockPosition blockposition1 = blockposition.down();
+            IBlockData iblockdata = this.world.getType(blockposition1);
+
+            if (iblockdata.a((Tag) TagsBlock.FENCES) || iblockdata.a((Tag) TagsBlock.WALLS) || iblockdata.getBlock() instanceof BlockFenceGate) {
+                return blockposition1;
+            }
+        }
+
+        return blockposition;
+    }
+
+    protected float getBlockJumpFactor() {
+        float f = this.world.getType(this.getChunkCoordinates()).getBlock().getJumpFactor();
+        float f1 = this.world.getType(this.at()).getBlock().getJumpFactor();
+
+        return (double) f == 1.0D ? f1 : f;
+    }
+
+    protected float getBlockSpeedFactor() {
+        IBlockData iblockdata = this.world.getType(this.getChunkCoordinates());
+        float f = iblockdata.getBlock().getSpeedFactor();
+
+        return !iblockdata.a(Blocks.WATER) && !iblockdata.a(Blocks.BUBBLE_COLUMN) ? ((double) f == 1.0D ? this.world.getType(this.at()).getBlock().getSpeedFactor() : f) : f;
+    }
+
+    protected BlockPosition at() {
+        return new BlockPosition(this.loc.x, this.getBoundingBox().minY - 0.5000001D, this.loc.z);
+    }
+
+    protected Vec3D a(Vec3D vec3d, EnumMoveType enummovetype) {
+        return vec3d;
+    }
+
+    protected Vec3D b(Vec3D vec3d) {
+        if (vec3d.g() <= 1.0E-7D) {
+            return vec3d;
+        } else {
+            long i = this.world.getTime();
+
+            if (i != this.ax) {
+                Arrays.fill(this.aw, 0.0D);
+                this.ax = i;
+            }
+
+            double d0;
+
+            if (vec3d.x != 0.0D) {
+                d0 = this.a(EnumDirection.EnumAxis.X, vec3d.x);
+                return Math.abs(d0) <= 9.999999747378752E-6D ? Vec3D.ORIGIN : new Vec3D(d0, 0.0D, 0.0D);
+            } else if (vec3d.y != 0.0D) {
+                d0 = this.a(EnumDirection.EnumAxis.Y, vec3d.y);
+                return Math.abs(d0) <= 9.999999747378752E-6D ? Vec3D.ORIGIN : new Vec3D(0.0D, d0, 0.0D);
+            } else if (vec3d.z != 0.0D) {
+                d0 = this.a(EnumDirection.EnumAxis.Z, vec3d.z);
+                return Math.abs(d0) <= 9.999999747378752E-6D ? Vec3D.ORIGIN : new Vec3D(0.0D, 0.0D, d0);
+            } else {
+                return Vec3D.ORIGIN;
+            }
+        }
+    }
+
+    private double a(EnumDirection.EnumAxis enumdirection_enumaxis, double d0) {
+        int i = enumdirection_enumaxis.ordinal();
+        double d1 = MathHelper.a(d0 + this.aw[i], -0.51D, 0.51D);
+
+        d0 = d1 - this.aw[i];
+        this.aw[i] = d1;
+        return d0;
+    }
+
+    private Vec3D g(Vec3D vec3d) {
+        AxisAlignedBB axisalignedbb = this.getBoundingBox();
+        VoxelShapeCollision voxelshapecollision = VoxelShapeCollision.a(this);
+        VoxelShape voxelshape = this.world.getWorldBorder().c();
+        Stream<VoxelShape> stream = VoxelShapes.c(voxelshape, VoxelShapes.a(axisalignedbb.shrink(1.0E-7D)), OperatorBoolean.AND) ? Stream.empty() : Stream.of(voxelshape);
+        Stream<VoxelShape> stream1 = this.world.c(this, axisalignedbb.b(vec3d), (entity) -> {
+            return true;
+        });
+        StreamAccumulator<VoxelShape> streamaccumulator = new StreamAccumulator<>(Stream.concat(stream1, stream));
+        Vec3D vec3d1 = vec3d.g() == 0.0D ? vec3d : a(this, vec3d, axisalignedbb, this.world, voxelshapecollision, streamaccumulator);
+        boolean flag = vec3d.x != vec3d1.x;
+        boolean flag1 = vec3d.y != vec3d1.y;
+        boolean flag2 = vec3d.z != vec3d1.z;
+        boolean flag3 = this.onGround || flag1 && vec3d.y < 0.0D;
+
+        if (this.E > 0.0F && flag3 && (flag || flag2)) {
+            Vec3D vec3d2 = a(this, new Vec3D(vec3d.x, (double) this.E, vec3d.z), axisalignedbb, this.world, voxelshapecollision, streamaccumulator);
+            Vec3D vec3d3 = a(this, new Vec3D(0.0D, (double) this.E, 0.0D), axisalignedbb.b(vec3d.x, 0.0D, vec3d.z), this.world, voxelshapecollision, streamaccumulator);
+
+            if (vec3d3.y < (double) this.E) {
+                Vec3D vec3d4 = a(this, new Vec3D(vec3d.x, 0.0D, vec3d.z), axisalignedbb.c(vec3d3), this.world, voxelshapecollision, streamaccumulator).e(vec3d3);
+
+                if (c(vec3d4) > c(vec3d2)) {
+                    vec3d2 = vec3d4;
+                }
+            }
+
+            if (c(vec3d2) > c(vec3d1)) {
+                return vec3d2.e(a(this, new Vec3D(0.0D, -vec3d2.y + vec3d.y, 0.0D), axisalignedbb.c(vec3d2), this.world, voxelshapecollision, streamaccumulator));
+            }
+        }
+
+        return vec3d1;
+    }
+
+    public static double c(Vec3D vec3d) {
+        return vec3d.x * vec3d.x + vec3d.z * vec3d.z;
+    }
+
+    public static Vec3D a(@Nullable Entity entity, Vec3D vec3d, AxisAlignedBB axisalignedbb, World world, VoxelShapeCollision voxelshapecollision, StreamAccumulator<VoxelShape> streamaccumulator) {
+        boolean flag = vec3d.x == 0.0D;
+        boolean flag1 = vec3d.y == 0.0D;
+        boolean flag2 = vec3d.z == 0.0D;
+
+        if ((!flag || !flag1) && (!flag || !flag2) && (!flag1 || !flag2)) {
+            StreamAccumulator<VoxelShape> streamaccumulator1 = new StreamAccumulator<>(Stream.concat(streamaccumulator.a(), world.b(entity, axisalignedbb.b(vec3d))));
+
+            return a(vec3d, axisalignedbb, streamaccumulator1);
+        } else {
+            return a(vec3d, axisalignedbb, world, voxelshapecollision, streamaccumulator);
+        }
+    }
+
+    public static Vec3D a(Vec3D vec3d, AxisAlignedBB axisalignedbb, StreamAccumulator<VoxelShape> streamaccumulator) {
+        double d0 = vec3d.x;
+        double d1 = vec3d.y;
+        double d2 = vec3d.z;
+
+        if (d1 != 0.0D) {
+            d1 = VoxelShapes.a(EnumDirection.EnumAxis.Y, axisalignedbb, streamaccumulator.a(), d1);
+            if (d1 != 0.0D) {
+                axisalignedbb = axisalignedbb.d(0.0D, d1, 0.0D);
+            }
+        }
+
+        boolean flag = Math.abs(d0) < Math.abs(d2);
+
+        if (flag && d2 != 0.0D) {
+            d2 = VoxelShapes.a(EnumDirection.EnumAxis.Z, axisalignedbb, streamaccumulator.a(), d2);
+            if (d2 != 0.0D) {
+                axisalignedbb = axisalignedbb.d(0.0D, 0.0D, d2);
+            }
+        }
+
+        if (d0 != 0.0D) {
+            d0 = VoxelShapes.a(EnumDirection.EnumAxis.X, axisalignedbb, streamaccumulator.a(), d0);
+            if (!flag && d0 != 0.0D) {
+                axisalignedbb = axisalignedbb.d(d0, 0.0D, 0.0D);
+            }
+        }
+
+        if (!flag && d2 != 0.0D) {
+            d2 = VoxelShapes.a(EnumDirection.EnumAxis.Z, axisalignedbb, streamaccumulator.a(), d2);
+        }
+
+        return new Vec3D(d0, d1, d2);
+    }
+
+    public static Vec3D a(Vec3D vec3d, AxisAlignedBB axisalignedbb, IWorldReader iworldreader, VoxelShapeCollision voxelshapecollision, StreamAccumulator<VoxelShape> streamaccumulator) {
+        double d0 = vec3d.x;
+        double d1 = vec3d.y;
+        double d2 = vec3d.z;
+
+        if (d1 != 0.0D) {
+            d1 = VoxelShapes.a(EnumDirection.EnumAxis.Y, axisalignedbb, iworldreader, d1, voxelshapecollision, streamaccumulator.a());
+            if (d1 != 0.0D) {
+                axisalignedbb = axisalignedbb.d(0.0D, d1, 0.0D);
+            }
+        }
+
+        boolean flag = Math.abs(d0) < Math.abs(d2);
+
+        if (flag && d2 != 0.0D) {
+            d2 = VoxelShapes.a(EnumDirection.EnumAxis.Z, axisalignedbb, iworldreader, d2, voxelshapecollision, streamaccumulator.a());
+            if (d2 != 0.0D) {
+                axisalignedbb = axisalignedbb.d(0.0D, 0.0D, d2);
+            }
+        }
+
+        if (d0 != 0.0D) {
+            d0 = VoxelShapes.a(EnumDirection.EnumAxis.X, axisalignedbb, iworldreader, d0, voxelshapecollision, streamaccumulator.a());
+            if (!flag && d0 != 0.0D) {
+                axisalignedbb = axisalignedbb.d(d0, 0.0D, 0.0D);
+            }
+        }
+
+        if (!flag && d2 != 0.0D) {
+            d2 = VoxelShapes.a(EnumDirection.EnumAxis.Z, axisalignedbb, iworldreader, d2, voxelshapecollision, streamaccumulator.a());
+        }
+
+        return new Vec3D(d0, d1, d2);
+    }
+
+    protected float au() {
+        return (float) ((int) this.z + 1);
+    }
+
+    public void recalcPosition() {
+        AxisAlignedBB axisalignedbb = this.getBoundingBox();
+
+        this.setPositionRaw((axisalignedbb.minX + axisalignedbb.maxX) / 2.0D, axisalignedbb.minY, (axisalignedbb.minZ + axisalignedbb.maxZ) / 2.0D);
+        //if (valid) ((WorldServer) world).chunkCheck(this); // CraftBukkit
+    }
+
+    protected SoundEffect getSoundSwim() {
+        return SoundEffects.GENERIC_SWIM;
+    }
+
+    protected SoundEffect getSoundSplash() {
+        return SoundEffects.GENERIC_SPLASH;
+    }
+
+    protected SoundEffect getSoundSplashHighSpeed() {
+        return SoundEffects.GENERIC_SPLASH;
+    }
+
+    protected void checkBlockCollisions() {
+        AxisAlignedBB axisalignedbb = this.getBoundingBox();
+        BlockPosition blockposition = new BlockPosition(axisalignedbb.minX + 0.001D, axisalignedbb.minY + 0.001D, axisalignedbb.minZ + 0.001D);
+        BlockPosition blockposition1 = new BlockPosition(axisalignedbb.maxX - 0.001D, axisalignedbb.maxY - 0.001D, axisalignedbb.maxZ - 0.001D);
+        BlockPosition.MutableBlockPosition blockposition_mutableblockposition = new BlockPosition.MutableBlockPosition();
+
+        if (this.world.areChunksLoadedBetween(blockposition, blockposition1)) {
+            for (int i = blockposition.getX(); i <= blockposition1.getX(); ++i) {
+                for (int j = blockposition.getY(); j <= blockposition1.getY(); ++j) {
+                    for (int k = blockposition.getZ(); k <= blockposition1.getZ(); ++k) {
+                        blockposition_mutableblockposition.d(i, j, k);
+                        IBlockData iblockdata = this.world.getType(blockposition_mutableblockposition);
+
+                        try {
+                            iblockdata.a(this.world, blockposition_mutableblockposition, this);
+                            this.a(iblockdata);
+                        } catch (Throwable throwable) {
+                            CrashReport crashreport = CrashReport.a(throwable, "Colliding entity with block");
+                            CrashReportSystemDetails crashreportsystemdetails = crashreport.a("Block being collided with");
+
+                            CrashReportSystemDetails.a(crashreportsystemdetails, this.world, blockposition_mutableblockposition, iblockdata);
+                            throw new ReportedException(crashreport);
+                        }
+                    }
+                }
+            }
+        }
+
+    }
+
+    protected void a(IBlockData iblockdata) {}
+
+    protected void a(@Nullable Entity entity, ckz ckz) {
+        this.world.a(entity, ckz, this.locBlock);
+    }
+
+    protected void a(ckz ckz) {
+        this.world.a(this, ckz, this.locBlock);
+    }
+
+    protected void b(BlockPosition blockposition, IBlockData iblockdata) {
+        if (!iblockdata.getMaterial().isLiquid()) {
+            if (iblockdata.a((Tag) TagsBlock.CRYSTAL_SOUND_BLOCKS) && this.ticksLived >= this.aB + 20) {
+                this.aA = (float) ((double) this.aA * Math.pow(0.996999979019165D, (double) (this.ticksLived - this.aB)));
+                this.aA = Math.min(1.0F, this.aA + 0.07F);
+                float f = 0.5F + this.aA * this.random.nextFloat() * 1.2F;
+                float f1 = 0.1F + this.aA * 1.2F;
+
+                this.playSound(SoundEffects.AMETHYST_BLOCK_CHIME, f1, f);
+                this.aB = this.ticksLived;
+            }
+
+            IBlockData iblockdata1 = this.world.getType(blockposition.up());
+            SoundEffectType soundeffecttype = iblockdata1.a((Tag) TagsBlock.INSIDE_STEP_SOUND_BLOCKS) ? iblockdata1.getStepSound() : iblockdata.getStepSound();
+
+            this.playSound(soundeffecttype.d(), soundeffecttype.a() * 0.15F, soundeffecttype.b());
+        }
+    }
+
+    protected void d(float f) {
+        this.playSound(this.getSoundSwim(), f, 1.0F + (this.random.nextFloat() - this.random.nextFloat()) * 0.4F);
+    }
+
+    protected float e(float f) {
+        return 0.0F;
+    }
+
+    protected boolean aA() {
+        return false;
+    }
+
+    public void playSound(SoundEffect soundeffect, float f, float f1) {
+        if (!this.isSilent()) {
+            this.world.playSound((EntityHuman) null, this.locX(), this.locY(), this.locZ(), soundeffect, this.getSoundCategory(), f, f1);
+        }
+
+    }
+
+    public boolean isSilent() {
+        return (Boolean) this.datawatcher.get(Entity.ao);
+    }
+
+    public void setSilent(boolean flag) {
+        this.datawatcher.set(Entity.ao, flag);
+    }
+
+    public boolean isNoGravity() {
+        return (Boolean) this.datawatcher.get(Entity.ap);
+    }
+
+    public void setNoGravity(boolean flag) {
+        this.datawatcher.set(Entity.ap, flag);
+    }
+
+    protected boolean playStepSound() {
+        return true;
+    }
+
+    public boolean isOccludesVibrations() {
+        return false;
+    }
+
+    protected void a(double d0, boolean flag, IBlockData iblockdata, BlockPosition blockposition) {
+        if (flag) {
+            if (this.fallDistance > 0.0F) {
+                iblockdata.getBlock().fallOn(this.world, blockposition, this, this.fallDistance);
+                if (!iblockdata.a((Tag) TagsBlock.aO)) {
+                    this.a(ckz.e);
+                }
+            }
+
+            this.fallDistance = 0.0F;
+        } else if (d0 < 0.0D) {
+            this.fallDistance = (float) ((double) this.fallDistance - d0);
+        }
+
+    }
+
+    public boolean isFireProof() {
+        return this.getEntityType().d();
+    }
+
+    public boolean b(float f, float f1) {
+        if (this.isVehicle()) {
+            Iterator iterator = this.getPassengers().iterator();
+
+            while (iterator.hasNext()) {
+                Entity entity = (Entity) iterator.next();
+
+                entity.b(f, f1);
+            }
+        }
+
+        return false;
+    }
+
+    public boolean isInWater() {
+        return this.inWater;
+    }
+
+    private boolean isInRain() {
+        BlockPosition blockposition = this.getChunkCoordinates();
+
+        return this.world.isRainingAt(blockposition) || this.world.isRainingAt(new BlockPosition((double) blockposition.getX(), this.getBoundingBox().maxY, (double) blockposition.getZ()));
+    }
+
+    private boolean k() {
+        return this.world.getType(this.getChunkCoordinates()).a(Blocks.BUBBLE_COLUMN);
+    }
+
+    public boolean isInWaterOrRain() {
+        return this.isInWater() || this.isInRain();
+    }
+
+    public boolean aI() {
+        return this.isInWater() || this.isInRain() || this.k();
+    }
+
+    public boolean aJ() {
+        return this.isInWater() || this.k();
+    }
+
+    public boolean aK() {
+        return this.L && this.isInWater();
+    }
+
+    public void aL() {
+        if (this.isSwimming()) {
+            this.setSwimming(this.isSprinting() && this.isInWater() && !this.isPassenger());
+        } else {
+            this.setSwimming(this.isSprinting() && this.aK() && !this.isPassenger());
+        }
+
+    }
+
+    protected boolean aM() {
+        this.K.clear();
+        this.aN();
+        double d0 = this.world.getDimensionManager().isNether() ? 0.007D : 0.0023333333333333335D;
+        boolean flag = this.a((Tag) TagsFluid.LAVA, d0);
+
+        return this.isInWater() || flag;
+    }
+
+    void aN() {
+        if (this.getVehicle() instanceof EntityBoat) {
+            this.inWater = false;
+        } else if (this.a((Tag) TagsFluid.WATER, 0.014D)) {
+            if (!this.inWater && !this.justCreated) {
+                this.aO();
+            }
+
+            this.fallDistance = 0.0F;
+            this.inWater = true;
+            this.extinguish();
+        } else {
+            this.inWater = false;
+        }
+
+    }
+
+    private void m() {
+        this.L = this.a((Tag) TagsFluid.WATER);
+        this.M = null;
+        double d0 = this.getHeadY() - 0.1111111119389534D;
+        Entity entity = this.getVehicle();
+
+        if (entity instanceof EntityBoat) {
+            EntityBoat entityboat = (EntityBoat) entity;
+
+            if (!entityboat.aK() && entityboat.getBoundingBox().maxY >= d0 && entityboat.getBoundingBox().minY <= d0) {
+                return;
+            }
+        }
+
+        BlockPosition blockposition = new BlockPosition(this.locX(), d0, this.locZ());
+        Fluid fluid = this.world.getFluid(blockposition);
+        Iterator iterator = TagsFluid.b().iterator();
+
+        Tag tag;
+
+        do {
+            if (!iterator.hasNext()) {
+                return;
+            }
+
+            tag = (Tag) iterator.next();
+        } while (!fluid.a(tag));
+
+        double d1 = (double) ((float) blockposition.getY() + fluid.getHeight(this.world, blockposition));
+
+        if (d1 > d0) {
+            this.M = tag;
+        }
+
+    }
+
+    protected void aO() {
+        Entity entity = this.isVehicle() && this.getRidingPassenger() != null ? this.getRidingPassenger() : this;
+        float f = entity == this ? 0.2F : 0.9F;
+        Vec3D vec3d = entity.getMot();
+        float f1 = MathHelper.sqrt(vec3d.x * vec3d.x * 0.20000000298023224D + vec3d.y * vec3d.y + vec3d.z * vec3d.z * 0.20000000298023224D) * f;
+
+        if (f1 > 1.0F) {
+            f1 = 1.0F;
+        }
+
+        if ((double) f1 < 0.25D) {
+            this.playSound(this.getSoundSplash(), f1, 1.0F + (this.random.nextFloat() - this.random.nextFloat()) * 0.4F);
+        } else {
+            this.playSound(this.getSoundSplashHighSpeed(), f1, 1.0F + (this.random.nextFloat() - this.random.nextFloat()) * 0.4F);
+        }
+
+        float f2 = (float) MathHelper.floor(this.locY());
+
+        double d0;
+        double d1;
+        int i;
+
+        for (i = 0; (float) i < 1.0F + this.size.width * 20.0F; ++i) {
+            d0 = (this.random.nextDouble() * 2.0D - 1.0D) * (double) this.size.width;
+            d1 = (this.random.nextDouble() * 2.0D - 1.0D) * (double) this.size.width;
+            this.world.addParticle(Particles.BUBBLE, this.locX() + d0, (double) (f2 + 1.0F), this.locZ() + d1, vec3d.x, vec3d.y - this.random.nextDouble() * 0.20000000298023224D, vec3d.z);
+        }
+
+        for (i = 0; (float) i < 1.0F + this.size.width * 20.0F; ++i) {
+            d0 = (this.random.nextDouble() * 2.0D - 1.0D) * (double) this.size.width;
+            d1 = (this.random.nextDouble() * 2.0D - 1.0D) * (double) this.size.width;
+            this.world.addParticle(Particles.SPLASH, this.locX() + d0, (double) (f2 + 1.0F), this.locZ() + d1, vec3d.x, vec3d.y, vec3d.z);
+        }
+
+        this.a(ckz.f);
+    }
+
+    protected IBlockData aP() {
+        return this.world.getType(this.aq());
+    }
+
+    public boolean aQ() {
+        return this.isSprinting() && !this.isInWater() && !this.isSpectator() && !this.isSneaking() && !this.aS() && this.isAlive();
+    }
+
+    protected void aR() {
+        int i = MathHelper.floor(this.locX());
+        int j = MathHelper.floor(this.locY() - 0.20000000298023224D);
+        int k = MathHelper.floor(this.locZ());
+        BlockPosition blockposition = new BlockPosition(i, j, k);
+        IBlockData iblockdata = this.world.getType(blockposition);
+
+        if (iblockdata.h() != EnumRenderType.INVISIBLE) {
+            Vec3D vec3d = this.getMot();
+
+            this.world.addParticle(new ParticleParamBlock(Particles.BLOCK, iblockdata), this.locX() + (this.random.nextDouble() - 0.5D) * (double) this.size.width, this.locY() + 0.1D, this.locZ() + (this.random.nextDouble() - 0.5D) * (double) this.size.width, vec3d.x * -4.0D, 1.5D, vec3d.z * -4.0D);
+        }
+
+    }
+
+    public boolean a(Tag<FluidType> tag) {
+        return this.M == tag;
+    }
+
+    public boolean aS() {
+        return !this.justCreated && this.K.getDouble(TagsFluid.LAVA) > 0.0D;
+    }
+
+    public void a(float f, Vec3D vec3d) {
+        Vec3D vec3d1 = a(vec3d, f, this.yaw);
+
+        this.setMot(this.getMot().e(vec3d1));
+    }
+
+    private static Vec3D a(Vec3D vec3d, float f, float f1) {
+        double d0 = vec3d.g();
+
+        if (d0 < 1.0E-7D) {
+            return Vec3D.ORIGIN;
+        } else {
+            Vec3D vec3d1 = (d0 > 1.0D ? vec3d.d() : vec3d).a((double) f);
+            float f2 = MathHelper.sin(f1 * 0.017453292F);
+            float f3 = MathHelper.cos(f1 * 0.017453292F);
+
+            return new Vec3D(vec3d1.x * (double) f3 - vec3d1.z * (double) f2, vec3d1.y, vec3d1.z * (double) f3 + vec3d1.x * (double) f2);
+        }
+    }
+
+    public float aT() {
+        BlockPosition.MutableBlockPosition blockposition_mutableblockposition = new BlockPosition.MutableBlockPosition(this.locX(), 0.0D, this.locZ());
+
+        if (this.world.isLoaded(blockposition_mutableblockposition)) {
+            blockposition_mutableblockposition.t(MathHelper.floor(this.getHeadY()));
+            return this.world.x(blockposition_mutableblockposition);
+        } else {
+            return 0.0F;
+        }
+    }
+
+    public void setLocation(double d0, double d1, double d2, float f, float f1) {
+        this.f(d0, d1, d2);
+        this.yaw = f % 360.0F;
+        this.pitch = MathHelper.a(f1, -90.0F, 90.0F) % 360.0F;
+        this.lastYaw = this.yaw;
+        this.lastPitch = this.pitch;
+    }
+
+    public void f(double d0, double d1, double d2) {
+        double d3 = MathHelper.a(d0, -3.0E7D, 3.0E7D);
+        double d4 = MathHelper.a(d2, -3.0E7D, 3.0E7D);
+
+        this.lastX = d3;
+        this.lastY = d1;
+        this.lastZ = d4;
+        this.setPosition(d3, d1, d4);
+        world.getChunkAt((int) Math.floor(this.locX()) >> 4, (int) Math.floor(this.locZ()) >> 4); // CraftBukkit
+    }
+
+    public void d(Vec3D vec3d) {
+        this.teleportAndSync(vec3d.x, vec3d.y, vec3d.z);
+    }
+
+    public void teleportAndSync(double d0, double d1, double d2) {
+        this.setPositionRotation(d0, d1, d2, this.yaw, this.pitch);
+    }
+
+    public void setPositionRotation(BlockPosition blockposition, float f, float f1) {
+        this.setPositionRotation((double) blockposition.getX() + 0.5D, (double) blockposition.getY(), (double) blockposition.getZ() + 0.5D, f, f1);
+    }
+
+    public void setPositionRotation(double d0, double d1, double d2, float f, float f1) {
+        this.g(d0, d1, d2);
+        this.yaw = f;
+        this.pitch = f1;
+        this.af();
+    }
+
+    public void g(double d0, double d1, double d2) {
+        this.setPositionRaw(d0, d1, d2);
+        this.lastX = d0;
+        this.lastY = d1;
+        this.lastZ = d2;
+        this.B = d0;
+        this.C = d1;
+        this.D = d2;
+    }
+
+    public float g(Entity entity) {
+        float f = (float) (this.locX() - entity.locX());
+        float f1 = (float) (this.locY() - entity.locY());
+        float f2 = (float) (this.locZ() - entity.locZ());
+
+        return MathHelper.c(f * f + f1 * f1 + f2 * f2);
+    }
+
+    // CraftBukkit start
+    public void spawnIn(World world) {
+        if (world == null) {
+            die(RemovalReason.CHANGED_DIMENSION);
+            this.world = ((CraftWorld) Bukkit.getServer().getWorlds().get(0)).getHandle();
+            return;
+        }
+        this.world = world;
+    }
+    // CraftBukkit end
+
+    public double h(double d0, double d1, double d2) {
+        double d3 = this.locX() - d0;
+        double d4 = this.locY() - d1;
+        double d5 = this.locZ() - d2;
+
+        return d3 * d3 + d4 * d4 + d5 * d5;
+    }
+
+    public double h(Entity entity) {
+        return this.e(entity.getPositionVector());
+    }
+
+    public double e(Vec3D vec3d) {
+        double d0 = this.locX() - vec3d.x;
+        double d1 = this.locY() - vec3d.y;
+        double d2 = this.locZ() - vec3d.z;
+
+        return d0 * d0 + d1 * d1 + d2 * d2;
+    }
+
+    public void pickup(EntityHuman entityhuman) {}
+
+    public void collide(Entity entity) {
+        if (!this.isSameVehicle(entity)) {
+            if (!entity.noclip && !this.noclip) {
+                double d0 = entity.locX() - this.locX();
+                double d1 = entity.locZ() - this.locZ();
+                double d2 = MathHelper.a(d0, d1);
+
+                if (d2 >= 0.009999999776482582D) {
+                    d2 = (double) MathHelper.sqrt(d2);
+                    d0 /= d2;
+                    d1 /= d2;
+                    double d3 = 1.0D / d2;
+
+                    if (d3 > 1.0D) {
+                        d3 = 1.0D;
+                    }
+
+                    d0 *= d3;
+                    d1 *= d3;
+                    d0 *= 0.05000000074505806D;
+                    d1 *= 0.05000000074505806D;
+                    d0 *= (double) (1.0F - this.G);
+                    d1 *= (double) (1.0F - this.G);
+                    if (!this.isVehicle()) {
+                        this.i(-d0, 0.0D, -d1);
+                    }
+
+                    if (!entity.isVehicle()) {
+                        entity.i(d0, 0.0D, d1);
+                    }
+                }
+
+            }
+        }
+    }
+
+    public void i(double d0, double d1, double d2) {
+        this.setMot(this.getMot().add(d0, d1, d2));
+        this.impulse = true;
+    }
+
+    protected void velocityChanged() {
+        this.velocityChanged = true;
+    }
+
+    public boolean damageEntity(DamageSource damagesource, float f) {
+        if (this.isInvulnerable(damagesource)) {
+            return false;
+        } else {
+            this.a(damagesource.getEntity(), ckz.i);
+            this.velocityChanged();
+            return false;
+        }
+    }
+
+    public final Vec3D f(float f) {
+        return this.c(this.g(f), this.h(f));
+    }
+
+    public float g(float f) {
+        return f == 1.0F ? this.pitch : MathHelper.g(f, this.lastPitch, this.pitch);
+    }
+
+    public float h(float f) {
+        return f == 1.0F ? this.yaw : MathHelper.g(f, this.lastYaw, this.yaw);
+    }
+
+    protected final Vec3D c(float f, float f1) {
+        float f2 = f * 0.017453292F;
+        float f3 = -f1 * 0.017453292F;
+        float f4 = MathHelper.cos(f3);
+        float f5 = MathHelper.sin(f3);
+        float f6 = MathHelper.cos(f2);
+        float f7 = MathHelper.sin(f2);
+
+        return new Vec3D((double) (f5 * f6), (double) (-f7), (double) (f4 * f6));
+    }
+
+    public final Vec3D i(float f) {
+        return this.d(this.g(f), this.h(f));
+    }
+
+    protected final Vec3D d(float f, float f1) {
+        return this.c(f - 90.0F, f1);
+    }
+
+    public final Vec3D j(float f) {
+        if (f == 1.0F) {
+            return new Vec3D(this.locX(), this.getHeadY(), this.locZ());
+        } else {
+            double d0 = MathHelper.d((double) f, this.lastX, this.locX());
+            double d1 = MathHelper.d((double) f, this.lastY, this.locY()) + (double) this.getHeadHeight();
+            double d2 = MathHelper.d((double) f, this.lastZ, this.locZ());
+
+            return new Vec3D(d0, d1, d2);
+        }
+    }
+
+    public MovingObjectPosition a(double d0, float f, boolean flag) {
+        Vec3D vec3d = this.j(f);
+        Vec3D vec3d1 = this.f(f);
+        Vec3D vec3d2 = vec3d.add(vec3d1.x * d0, vec3d1.y * d0, vec3d1.z * d0);
+
+        return this.world.rayTrace(new RayTrace(vec3d, vec3d2, RayTrace.BlockCollisionOption.OUTLINE, flag ? RayTrace.FluidCollisionOption.ANY : RayTrace.FluidCollisionOption.NONE, this));
+    }
+
+    public boolean isInteractable() {
+        return false;
+    }
+
+    public boolean isCollidable() {
+        return false;
+    }
+
+    // CraftBukkit start - collidable API
+    public boolean canCollideWith(Entity entity) {
+        return isCollidable();
+    }
+    // CraftBukkit end
+
+    public void a(Entity entity, int i, DamageSource damagesource) {
+        if (entity instanceof EntityPlayer) {
+            CriterionTriggers.c.a((EntityPlayer) entity, this, damagesource);
+        }
+
+    }
+
+    public boolean d(NBTTagCompound nbttagcompound) {
+        if (this.dead != null && !this.dead.b()) {
+            return false;
+        } else {
+            String s = this.getSaveID();
+
+            if (this.persist && this.dead == null && s != null) { // CraftBukkit - persist flag
+                nbttagcompound.setString("id", s);
+                this.save(nbttagcompound);
+                return true;
+            } else { return false; } // CraftBukkit
+        }
+    }
+
+    public boolean e(NBTTagCompound nbttagcompound) {
+        return this.isPassenger() ? false : this.d(nbttagcompound);
+    }
+
+    public NBTTagCompound save(NBTTagCompound nbttagcompound) {
+        try {
+            if (this.vehicle != null) {
+                nbttagcompound.set("Pos", this.a(this.vehicle.locX(), this.locY(), this.vehicle.locZ()));
+            } else {
+                nbttagcompound.set("Pos", this.a(this.locX(), this.locY(), this.locZ()));
+            }
+
+            Vec3D vec3d = this.getMot();
+
+            nbttagcompound.set("Motion", this.a(vec3d.x, vec3d.y, vec3d.z));
+
+            // CraftBukkit start - Checking for NaN pitch/yaw and resetting to zero
+            // TODO: make sure this is the best way to address this.
+            if (Float.isNaN(this.yaw)) {
+                this.yaw = 0;
+            }
+
+            if (Float.isNaN(this.pitch)) {
+                this.pitch = 0;
+            }
+            // CraftBukkit end
+
+            nbttagcompound.set("Rotation", this.a(this.yaw, this.pitch));
+            nbttagcompound.setFloat("FallDistance", this.fallDistance);
+            nbttagcompound.setShort("Fire", (short) this.fireTicks);
+            nbttagcompound.setShort("Air", (short) this.getAirTicks());
+            nbttagcompound.setBoolean("OnGround", this.onGround);
+            nbttagcompound.setBoolean("Invulnerable", this.invulnerable);
+            nbttagcompound.setInt("PortalCooldown", this.portalCooldown);
+            nbttagcompound.a("UUID", this.getUniqueID());
+            // CraftBukkit start
+            // PAIL: Check above UUID reads 1.8 properly, ie: UUIDMost / UUIDLeast
+            nbttagcompound.setLong("WorldUUIDLeast", ((WorldServer) this.world).getWorld().getUID().getLeastSignificantBits());
+            nbttagcompound.setLong("WorldUUIDMost", ((WorldServer) this.world).getWorld().getUID().getMostSignificantBits());
+            nbttagcompound.setInt("Bukkit.updateLevel", CURRENT_LEVEL);
+            if (!this.persist) {
+                nbttagcompound.setBoolean("Bukkit.persist", this.persist);
+            }
+            if (this.persistentInvisibility) {
+                nbttagcompound.setBoolean("Bukkit.invisible", this.persistentInvisibility);
+            }
+            // CraftBukkit end
+            IChatBaseComponent ichatbasecomponent = this.getCustomName();
+
+            if (ichatbasecomponent != null) {
+                nbttagcompound.setString("CustomName", IChatBaseComponent.ChatSerializer.a(ichatbasecomponent));
+            }
+
+            if (this.getCustomNameVisible()) {
+                nbttagcompound.setBoolean("CustomNameVisible", this.getCustomNameVisible());
+            }
+
+            if (this.isSilent()) {
+                nbttagcompound.setBoolean("Silent", this.isSilent());
+            }
+
+            if (this.isNoGravity()) {
+                nbttagcompound.setBoolean("NoGravity", this.isNoGravity());
+            }
+
+            if (this.glowing) {
+                nbttagcompound.setBoolean("Glowing", this.glowing);
+            }
+
+            int i = this.bM();
+
+            if (i > 0) {
+                nbttagcompound.setInt("TicksFrozen", this.bM());
+            }
+
+            NBTTagList nbttaglist;
+            Iterator iterator;
+
+            if (!this.av.isEmpty()) {
+                nbttaglist = new NBTTagList();
+                iterator = this.av.iterator();
+
+                while (iterator.hasNext()) {
+                    String s = (String) iterator.next();
+
+                    nbttaglist.add(NBTTagString.a(s));
+                }
+
+                nbttagcompound.set("Tags", nbttaglist);
+            }
+
+            this.saveData(nbttagcompound);
+            if (this.isVehicle()) {
+                nbttaglist = new NBTTagList();
+                iterator = this.getPassengers().iterator();
+
+                while (iterator.hasNext()) {
+                    Entity entity = (Entity) iterator.next();
+                    NBTTagCompound nbttagcompound1 = new NBTTagCompound();
+
+                    if (entity.d(nbttagcompound1)) {
+                        nbttaglist.add(nbttagcompound1);
+                    }
+                }
+
+                if (!nbttaglist.isEmpty()) {
+                    nbttagcompound.set("Passengers", nbttaglist);
+                }
+            }
+
+            // CraftBukkit start - stores eventually existing bukkit values
+            if (this.bukkitEntity != null) {
+                this.bukkitEntity.storeBukkitValues(nbttagcompound);
+            }
+            // CraftBukkit end
+            return nbttagcompound;
+        } catch (Throwable throwable) {
+            CrashReport crashreport = CrashReport.a(throwable, "Saving entity NBT");
+            CrashReportSystemDetails crashreportsystemdetails = crashreport.a("Entity being saved");
+
+            this.appendEntityCrashDetails(crashreportsystemdetails);
+            throw new ReportedException(crashreport);
+        }
+    }
+
+    public void load(NBTTagCompound nbttagcompound) {
+        try {
+            NBTTagList nbttaglist = nbttagcompound.getList("Pos", 6);
+            NBTTagList nbttaglist1 = nbttagcompound.getList("Motion", 6);
+            NBTTagList nbttaglist2 = nbttagcompound.getList("Rotation", 5);
+            double d0 = nbttaglist1.h(0);
+            double d1 = nbttaglist1.h(1);
+            double d2 = nbttaglist1.h(2);
+
+            this.setMot(Math.abs(d0) > 10.0D ? 0.0D : d0, Math.abs(d1) > 10.0D ? 0.0D : d1, Math.abs(d2) > 10.0D ? 0.0D : d2);
+            this.g(nbttaglist.h(0), nbttaglist.h(1), nbttaglist.h(2));
+            this.yaw = nbttaglist2.i(0);
+            this.pitch = nbttaglist2.i(1);
+            this.lastYaw = this.yaw;
+            this.lastPitch = this.pitch;
+            this.setHeadRotation(this.yaw);
+            this.n(this.yaw);
+            this.fallDistance = nbttagcompound.getFloat("FallDistance");
+            this.fireTicks = nbttagcompound.getShort("Fire");
+            this.i(nbttagcompound.getShort("Air"));
+            this.onGround = nbttagcompound.getBoolean("OnGround");
+            this.invulnerable = nbttagcompound.getBoolean("Invulnerable");
+            this.portalCooldown = nbttagcompound.getInt("PortalCooldown");
+            if (nbttagcompound.b("UUID")) {
+                this.uniqueID = nbttagcompound.a("UUID");
+                this.Y = this.uniqueID.toString();
+            }
+
+            if (Double.isFinite(this.locX()) && Double.isFinite(this.locY()) && Double.isFinite(this.locZ())) {
+                if (Double.isFinite((double) this.yaw) && Double.isFinite((double) this.pitch)) {
+                    this.af();
+                    this.setYawPitch(this.yaw, this.pitch);
+                    if (nbttagcompound.hasKeyOfType("CustomName", 8)) {
+                        String s = nbttagcompound.getString("CustomName");
+
+                        try {
+                            this.setCustomName(IChatBaseComponent.ChatSerializer.a(s));
+                        } catch (Exception exception) {
+                            Entity.LOGGER.warn("Failed to parse entity custom name {}", s, exception);
+                        }
+                    }
+
+                    this.setCustomNameVisible(nbttagcompound.getBoolean("CustomNameVisible"));
+                    this.setSilent(nbttagcompound.getBoolean("Silent"));
+                    this.setNoGravity(nbttagcompound.getBoolean("NoGravity"));
+                    this.h(nbttagcompound.getBoolean("Glowing"));
+                    this.setAirTicks(nbttagcompound.getInt("TicksFrozen"));
+                    if (nbttagcompound.hasKeyOfType("Tags", 9)) {
+                        this.av.clear();
+                        NBTTagList nbttaglist3 = nbttagcompound.getList("Tags", 8);
+                        int i = Math.min(nbttaglist3.size(), 1024);
+
+                        for (int j = 0; j < i; ++j) {
+                            this.av.add(nbttaglist3.getString(j));
+                        }
+                    }
+
+                    this.loadData(nbttagcompound);
+                    if (this.aX()) {
+                        this.af();
+                    }
+
+                } else {
+                    throw new IllegalStateException("Entity has invalid rotation");
+                }
+            } else {
+                throw new IllegalStateException("Entity has invalid position");
+            }
+
+            // CraftBukkit start
+            if (this instanceof EntityLiving) {
+                EntityLiving entity = (EntityLiving) this;
+
+                // Reset the persistence for tamed animals
+                if (entity instanceof EntityTameableAnimal && !isLevelAtLeast(nbttagcompound, 2) && !nbttagcompound.getBoolean("PersistenceRequired")) {
+                    EntityInsentient entityinsentient = (EntityInsentient) entity;
+                    entityinsentient.persistent = !entityinsentient.isTypeNotPersistent(0);
+                }
+            }
+            this.persist = !nbttagcompound.hasKey("Bukkit.persist") || nbttagcompound.getBoolean("Bukkit.persist");
+            // CraftBukkit end
+
+            // CraftBukkit start - Reset world
+            if (this instanceof EntityPlayer) {
+                Server server = Bukkit.getServer();
+                org.bukkit.World bworld = null;
+
+                // TODO: Remove World related checks, replaced with WorldUID
+                String worldName = nbttagcompound.getString("world");
+
+                if (nbttagcompound.hasKey("WorldUUIDMost") && nbttagcompound.hasKey("WorldUUIDLeast")) {
+                    UUID uid = new UUID(nbttagcompound.getLong("WorldUUIDMost"), nbttagcompound.getLong("WorldUUIDLeast"));
+                    bworld = server.getWorld(uid);
+                } else {
+                    bworld = server.getWorld(worldName);
+                }
+
+                if (bworld == null) {
+                    bworld = ((org.bukkit.craftbukkit.CraftServer) server).getServer().getWorldServer(World.OVERWORLD).getWorld();
+                }
+
+                spawnIn(bworld == null ? null : ((CraftWorld) bworld).getHandle());
+            }
+            this.getBukkitEntity().readBukkitValues(nbttagcompound);
+            if (nbttagcompound.hasKey("Bukkit.invisible")) {
+                boolean bukkitInvisible = nbttagcompound.getBoolean("Bukkit.invisible");
+                this.setInvisible(bukkitInvisible);
+                this.persistentInvisibility = bukkitInvisible;
+            }
+            // CraftBukkit end
+
+        } catch (Throwable throwable) {
+            CrashReport crashreport = CrashReport.a(throwable, "Loading entity NBT");
+            CrashReportSystemDetails crashreportsystemdetails = crashreport.a("Entity being loaded");
+
+            this.appendEntityCrashDetails(crashreportsystemdetails);
+            throw new ReportedException(crashreport);
+        }
+    }
+
+    protected boolean aX() {
+        return true;
+    }
+
+    @Nullable
+    public final String getSaveID() {
+        EntityTypes<?> entitytypes = this.getEntityType();
+        MinecraftKey minecraftkey = EntityTypes.getName(entitytypes);
+
+        return entitytypes.b() && minecraftkey != null ? minecraftkey.toString() : null;
+    }
+
+    protected abstract void loadData(NBTTagCompound nbttagcompound);
+
+    protected abstract void saveData(NBTTagCompound nbttagcompound);
+
+    protected NBTTagList a(double... adouble) {
+        NBTTagList nbttaglist = new NBTTagList();
+        double[] adouble1 = adouble;
+        int i = adouble.length;
+
+        for (int j = 0; j < i; ++j) {
+            double d0 = adouble1[j];
+
+            nbttaglist.add(NBTTagDouble.a(d0));
+        }
+
+        return nbttaglist;
+    }
+
+    protected NBTTagList a(float... afloat) {
+        NBTTagList nbttaglist = new NBTTagList();
+        float[] afloat1 = afloat;
+        int i = afloat.length;
+
+        for (int j = 0; j < i; ++j) {
+            float f = afloat1[j];
+
+            nbttaglist.add(NBTTagFloat.a(f));
+        }
+
+        return nbttaglist;
+    }
+
+    @Nullable
+    public EntityItem a(IMaterial imaterial) {
+        return this.a(imaterial, 0);
+    }
+
+    @Nullable
+    public EntityItem a(IMaterial imaterial, int i) {
+        return this.a(new ItemStack(imaterial), (float) i);
+    }
+
+    @Nullable
+    public EntityItem a(ItemStack itemstack) {
+        return this.a(itemstack, 0.0F);
+    }
+
+    @Nullable
+    public EntityItem a(ItemStack itemstack, float f) {
+        if (itemstack.isEmpty()) {
+            return null;
+        } else if (this.world.isClientSide) {
+            return null;
+        } else {
+            // CraftBukkit start - Capture drops for death event
+            if (this instanceof EntityLiving && !((EntityLiving) this).forceDrops) {
+                ((EntityLiving) this).drops.add(org.bukkit.craftbukkit.inventory.CraftItemStack.asBukkitCopy(itemstack));
+                return null;
+            }
+            // CraftBukkit end
+            EntityItem entityitem = new EntityItem(this.world, this.locX(), this.locY() + (double) f, this.locZ(), itemstack);
+
+            entityitem.defaultPickupDelay();
+            // CraftBukkit start
+            EntityDropItemEvent event = new EntityDropItemEvent(this.getBukkitEntity(), (org.bukkit.entity.Item) entityitem.getBukkitEntity());
+            Bukkit.getPluginManager().callEvent(event);
+            if (event.isCancelled()) {
+                return null;
+            }
+            // CraftBukkit end
+            this.world.addEntity(entityitem);
+            return entityitem;
+        }
+    }
+
+    public boolean isAlive() {
+        return !this.cW();
+    }
+
+    public boolean inBlock() {
+        if (this.noclip) {
+            return false;
+        } else {
+            float f = 0.1F;
+            float f1 = this.size.width * 0.8F;
+            AxisAlignedBB axisalignedbb = AxisAlignedBB.g((double) f1, 0.10000000149011612D, (double) f1).d(this.locX(), this.getHeadY(), this.locZ());
+
+            return this.world.b(this, axisalignedbb, (iblockdata, blockposition) -> {
+                return iblockdata.o(this.world, blockposition);
+            }).findAny().isPresent();
+        }
+    }
+
+    public EnumInteractionResult a(EntityHuman entityhuman, EnumHand enumhand) {
+        return EnumInteractionResult.PASS;
+    }
+
+    public boolean j(Entity entity) {
+        return entity.bb() && !this.isSameVehicle(entity);
+    }
+
+    public boolean bb() {
+        return false;
+    }
+
+    public void passengerTick() {
+        this.setMot(Vec3D.ORIGIN);
+        this.tick();
+        if (this.isPassenger()) {
+            this.getVehicle().k(this);
+        }
+    }
+
+    public void k(Entity entity) {
+        this.a(entity, Entity::setPosition);
+    }
+
+    private void a(Entity entity, Entity.a entity_a) {
+        if (this.w(entity)) {
+            double d0 = this.locY() + this.be() + entity.bd();
+
+            entity_a.accept(entity, this.locX(), d0, this.locZ());
+        }
+    }
+
+    public double bd() {
+        return 0.0D;
+    }
+
+    public double be() {
+        return (double) this.size.height * 0.75D;
+    }
+
+    public boolean startRiding(Entity entity) {
+        return this.a(entity, false);
+    }
+
+    public boolean a(Entity entity, boolean flag) {
+        for (Entity entity1 = entity; entity1.vehicle != null; entity1 = entity1.vehicle) {
+            if (entity1.vehicle == this) {
+                return false;
+            }
+        }
+
+        if (!flag && (!this.n(entity) || !entity.q(this))) {
+            return false;
+        } else {
+            if (this.isPassenger()) {
+                this.stopRiding();
+            }
+
+            this.setPose(EntityPose.STANDING);
+            this.vehicle = entity;
+            if (!this.vehicle.addPassenger(this)) this.vehicle = null; // CraftBukkit
+            return true;
+        }
+    }
+
+    protected boolean n(Entity entity) {
+        return !this.bw() && this.j <= 0;
+    }
+
+    protected boolean c(EntityPose entitypose) {
+        return this.world.getCubes(this, this.d(entitypose).shrink(1.0E-7D));
+    }
+
+    public void ejectPassengers() {
+        for (int i = this.passengers.size() - 1; i >= 0; --i) {
+            ((Entity) this.passengers.get(i)).stopRiding();
+        }
+
+    }
+
+    public void bh() {
+        if (this.vehicle != null) {
+            Entity entity = this.vehicle;
+
+            this.vehicle = null;
+            if (!entity.removePassenger(this)) this.vehicle = entity; // CraftBukkit
+        }
+
+    }
+
+    public void stopRiding() {
+        this.bh();
+    }
+
+    protected boolean addPassenger(Entity entity) { // CraftBukkit
+        if (entity.getVehicle() != this) {
+            throw new IllegalStateException("Use x.startRiding(y), not y.addPassenger(x)");
+        } else {
+            // CraftBukkit start
+            com.google.common.base.Preconditions.checkState(!entity.passengers.contains(this), "Circular entity riding! %s %s", this, entity);
+
+            CraftEntity craft = (CraftEntity) entity.getBukkitEntity().getVehicle();
+            Entity orig = craft == null ? null : craft.getHandle();
+            if (getBukkitEntity() instanceof Vehicle && entity.getBukkitEntity() instanceof LivingEntity) {
+                VehicleEnterEvent event = new VehicleEnterEvent(
+                        (Vehicle) getBukkitEntity(),
+                        entity.getBukkitEntity()
+                );
+                // Suppress during worldgen
+                if (this.valid) {
+                    Bukkit.getPluginManager().callEvent(event);
+                }
+                CraftEntity craftn = (CraftEntity) entity.getBukkitEntity().getVehicle();
+                Entity n = craftn == null ? null : craftn.getHandle();
+                if (event.isCancelled() || n != orig) {
+                    return false;
+                }
+            }
+            // CraftBukkit end
+            if (this.passengers.isEmpty()) {
+                this.passengers = ImmutableList.of(entity);
+            } else {
+                List<Entity> list = Lists.newArrayList(this.passengers);
+
+                if (!this.world.isClientSide && entity instanceof EntityHuman && !(this.getRidingPassenger() instanceof EntityHuman)) {
+                    list.add(0, entity);
+                } else {
+                    list.add(entity);
+                }
+
+                this.passengers = ImmutableList.copyOf(list);
+            }
+
+        }
+        return true; // CraftBukkit
+    }
+
+    protected boolean removePassenger(Entity entity) { // CraftBukkit
+        if (entity.getVehicle() == this) {
+            throw new IllegalStateException("Use x.stopRiding(y), not y.removePassenger(x)");
+        } else {
+            // CraftBukkit start
+            CraftEntity craft = (CraftEntity) entity.getBukkitEntity().getVehicle();
+            Entity orig = craft == null ? null : craft.getHandle();
+            if (getBukkitEntity() instanceof Vehicle && entity.getBukkitEntity() instanceof LivingEntity) {
+                VehicleExitEvent event = new VehicleExitEvent(
+                        (Vehicle) getBukkitEntity(),
+                        (LivingEntity) entity.getBukkitEntity()
+                );
+                // Suppress during worldgen
+                if (this.valid) {
+                    Bukkit.getPluginManager().callEvent(event);
+                }
+                CraftEntity craftn = (CraftEntity) entity.getBukkitEntity().getVehicle();
+                Entity n = craftn == null ? null : craftn.getHandle();
+                if (event.isCancelled() || n != orig) {
+                    return false;
+                }
+            }
+            // CraftBukkit end
+            if (this.passengers.size() == 1 && this.passengers.get(0) == entity) {
+                this.passengers = ImmutableList.of();
+            } else {
+                this.passengers = (ImmutableList) this.passengers.stream().filter((entity1) -> {
+                    return entity1 != entity;
+                }).collect(ImmutableList.toImmutableList());
+            }
+
+            entity.j = 60;
+        }
+        return true; // CraftBukkit
+    }
+
+    protected boolean q(Entity entity) {
+        return this.passengers.isEmpty();
+    }
+
+    public float bi() {
+        return 0.0F;
+    }
+
+    public Vec3D getLookDirection() {
+        return this.c(this.pitch, this.yaw);
+    }
+
+    public Vec2F bk() {
+        return new Vec2F(this.pitch, this.yaw);
+    }
+
+    public void d(BlockPosition blockposition) {
+        if (this.aj()) {
+            this.ai();
+        } else {
+            if (!this.world.isClientSide && !blockposition.equals(this.W)) {
+                this.W = blockposition.immutableCopy();
+            }
+
+            this.inPortal = true;
+        }
+    }
+
+    protected void doPortalTick() {
+        if (this.world instanceof WorldServer) {
+            int i = this.ak();
+            WorldServer worldserver = (WorldServer) this.world;
+
+            if (this.inPortal) {
+                MinecraftServer minecraftserver = worldserver.getMinecraftServer();
+                ResourceKey<World> resourcekey = this.world.getDimensionKey() == World.THE_NETHER ? World.OVERWORLD : World.THE_NETHER;
+                WorldServer worldserver1 = minecraftserver.getWorldServer(resourcekey);
+
+                if (true && !this.isPassenger() && this.portalTicks++ >= i) { // CraftBukkit
+                    this.world.getMethodProfiler().enter("portal");
+                    this.portalTicks = i;
+                    this.ai();
+                    // CraftBukkit start
+                    if (this instanceof EntityPlayer) {
+                        ((EntityPlayer) this).b(worldserver1, PlayerTeleportEvent.TeleportCause.NETHER_PORTAL);
+                    } else {
+                        this.b(worldserver1);
+                    }
+                    // CraftBukkit end
+                    this.world.getMethodProfiler().exit();
+                }
+
+                this.inPortal = false;
+            } else {
+                if (this.portalTicks > 0) {
+                    this.portalTicks -= 4;
+                }
+
+                if (this.portalTicks < 0) {
+                    this.portalTicks = 0;
+                }
+            }
+
+            this.E();
+        }
+    }
+
+    public int getDefaultPortalCooldown() {
+        return 300;
+    }
+
+    public Iterable<ItemStack> bp() {
+        return Entity.c;
+    }
+
+    public Iterable<ItemStack> getArmorItems() {
+        return Entity.c;
+    }
+
+    public Iterable<ItemStack> br() {
+        return Iterables.concat(this.bp(), this.getArmorItems());
+    }
+
+    public void setSlot(EnumItemSlot enumitemslot, ItemStack itemstack) {}
+
+    public boolean isBurning() {
+        boolean flag = this.world != null && this.world.isClientSide;
+
+        return !this.isFireProof() && (this.fireTicks > 0 || flag && this.getFlag(0));
+    }
+
+    public boolean isPassenger() {
+        return this.getVehicle() != null;
+    }
+
+    public boolean isVehicle() {
+        return !this.passengers.isEmpty();
+    }
+
+    public boolean bv() {
+        return true;
+    }
+
+    public void setSneaking(boolean flag) {
+        this.setFlag(1, flag);
+    }
+
+    public boolean bw() {
+        return this.getFlag(1);
+    }
+
+    public boolean bx() {
+        return this.bw();
+    }
+
+    public boolean by() {
+        return this.bw();
+    }
+
+    public boolean bz() {
+        return this.bw();
+    }
+
+    public boolean bA() {
+        return this.bw();
+    }
+
+    public boolean isSneaking() {
+        return this.getPose() == EntityPose.CROUCHING;
+    }
+
+    public boolean isSprinting() {
+        return this.getFlag(3);
+    }
+
+    public void setSprinting(boolean flag) {
+        this.setFlag(3, flag);
+    }
+
+    public boolean isSwimming() {
+        return this.getFlag(4);
+    }
+
+    public boolean bE() {
+        return this.getPose() == EntityPose.SWIMMING;
+    }
+
+    public void setSwimming(boolean flag) {
+        // CraftBukkit start
+        if (this.isSwimming() != flag && this instanceof EntityLiving) {
+            if (CraftEventFactory.callToggleSwimEvent((EntityLiving) this, flag).isCancelled()) {
+                return;
+            }
+        }
+        // CraftBukkit end
+        this.setFlag(4, flag);
+    }
+
+    public boolean bG() {
+        return this.glowing || this.world.isClientSide && this.getFlag(6);
+    }
+
+    public void h(boolean flag) {
+        this.glowing = flag;
+        if (!this.world.isClientSide) {
+            this.setFlag(6, this.glowing);
+        }
+
+    }
+
+    public boolean isInvisible() {
+        return this.getFlag(5);
+    }
+
+    @Nullable
+    public clc bI() {
+        return null;
+    }
+
+    @Nullable
+    public ScoreboardTeamBase getScoreboardTeam() {
+        return this.world.getScoreboard().getPlayerTeam(this.getName());
+    }
+
+    public boolean r(Entity entity) {
+        return this.a(entity.getScoreboardTeam());
+    }
+
+    public boolean a(ScoreboardTeamBase scoreboardteambase) {
+        return this.getScoreboardTeam() != null ? this.getScoreboardTeam().isAlly(scoreboardteambase) : false;
+    }
+
+    public void setInvisible(boolean flag) {
+        // CraftBukkit start
+        if (!this.persistentInvisibility) { // Prevent Minecraft from removing our invisibility flag
+            this.setFlag(5, flag);
+        }
+        // CraftBukkit end
+    }
+
+    public boolean getFlag(int i) {
+        return ((Byte) this.datawatcher.get(Entity.Q) & 1 << i) != 0;
+    }
+
+    public void setFlag(int i, boolean flag) {
+        byte b0 = (Byte) this.datawatcher.get(Entity.Q);
+
+        if (flag) {
+            this.datawatcher.set(Entity.Q, (byte) (b0 | 1 << i));
+        } else {
+            this.datawatcher.set(Entity.Q, (byte) (b0 & ~(1 << i)));
+        }
+
+    }
+
+    public int bK() {
+        return 300;
+    }
+
+    public int getAirTicks() {
+        return (Integer) this.datawatcher.get(Entity.al);
+    }
+
+    public void i(int i) {
+        this.datawatcher.set(Entity.al, i);
+    }
+
+    public int bM() {
+        return (Integer) this.datawatcher.get(Entity.AIR_TICKS);
+    }
+
+    public void setAirTicks(int i) {
+        // CraftBukkit start
+        EntityAirChangeEvent event = new EntityAirChangeEvent(this.getBukkitEntity(), i);
+        // Suppress during worldgen
+        if (this.valid) {
+            event.getEntity().getServer().getPluginManager().callEvent(event);
+        }
+        if (event.isCancelled()) {
+            return;
+        }
+        this.datawatcher.set(Entity.AIR_TICKS, event.getAmount());
+        // CraftBukkit end
+    }
+
+    public float bN() {
+        int i = this.bP();
+
+        return (float) Math.min(this.bM(), i) / (float) i;
+    }
+
+    public boolean bO() {
+        return this.bM() >= this.bP();
+    }
+
+    public int bP() {
+        return 300;
+    }
+
+    public void onLightningStrike(WorldServer worldserver, EntityLightning entitylightning) {
+        this.setFireTicks(this.fireTicks + 1);
+        // CraftBukkit start
+        final org.bukkit.entity.Entity thisBukkitEntity = this.getBukkitEntity();
+        final org.bukkit.entity.Entity stormBukkitEntity = entitylightning.getBukkitEntity();
+        final PluginManager pluginManager = Bukkit.getPluginManager();
+        // CraftBukkit end
+
+        if (this.fireTicks == 0) {
+            // CraftBukkit start - Call a combust event when lightning strikes
+            EntityCombustByEntityEvent entityCombustEvent = new EntityCombustByEntityEvent(stormBukkitEntity, thisBukkitEntity, 8);
+            pluginManager.callEvent(entityCombustEvent);
+            if (!entityCombustEvent.isCancelled()) {
+                this.setOnFire(entityCombustEvent.getDuration(), false);
+            }
+            // CraftBukkit end
+        }
+
+        // CraftBukkit start
+        if (thisBukkitEntity instanceof Hanging) {
+            HangingBreakByEntityEvent hangingEvent = new HangingBreakByEntityEvent((Hanging) thisBukkitEntity, stormBukkitEntity);
+            pluginManager.callEvent(hangingEvent);
+
+            if (hangingEvent.isCancelled()) {
+                return;
+            }
+        }
+
+        if (this.isFireProof()) {
+            return;
+        }
+        CraftEventFactory.entityDamage = entitylightning;
+        if (!this.damageEntity(DamageSource.LIGHTNING, 5.0F)) {
+            CraftEventFactory.entityDamage = null;
+            return;
+        }
+        // CraftBukkit end
+    }
+
+    public void j(boolean flag) {
+        Vec3D vec3d = this.getMot();
+        double d0;
+
+        if (flag) {
+            d0 = Math.max(-0.9D, vec3d.y - 0.03D);
+        } else {
+            d0 = Math.min(1.8D, vec3d.y + 0.1D);
+        }
+
+        this.setMot(vec3d.x, d0, vec3d.z);
+    }
+
+    public void k(boolean flag) {
+        Vec3D vec3d = this.getMot();
+        double d0;
+
+        if (flag) {
+            d0 = Math.max(-0.3D, vec3d.y - 0.03D);
+        } else {
+            d0 = Math.min(0.7D, vec3d.y + 0.06D);
+        }
+
+        this.setMot(vec3d.x, d0, vec3d.z);
+        this.fallDistance = 0.0F;
+    }
+
+    public void a(WorldServer worldserver, EntityLiving entityliving) {}
+
+    protected void l(double d0, double d1, double d2) {
+        BlockPosition blockposition = new BlockPosition(d0, d1, d2);
+        Vec3D vec3d = new Vec3D(d0 - (double) blockposition.getX(), d1 - (double) blockposition.getY(), d2 - (double) blockposition.getZ());
+        BlockPosition.MutableBlockPosition blockposition_mutableblockposition = new BlockPosition.MutableBlockPosition();
+        EnumDirection enumdirection = EnumDirection.UP;
+        double d3 = Double.MAX_VALUE;
+        EnumDirection[] aenumdirection = new EnumDirection[]{EnumDirection.NORTH, EnumDirection.SOUTH, EnumDirection.WEST, EnumDirection.EAST, EnumDirection.UP};
+        int i = aenumdirection.length;
+
+        for (int j = 0; j < i; ++j) {
+            EnumDirection enumdirection1 = aenumdirection[j];
+
+            blockposition_mutableblockposition.a((BaseBlockPosition) blockposition, enumdirection1);
+            if (!this.world.getType(blockposition_mutableblockposition).r(this.world, blockposition_mutableblockposition)) {
+                double d4 = vec3d.a(enumdirection1.n());
+                double d5 = enumdirection1.e() == EnumDirection.EnumAxisDirection.POSITIVE ? 1.0D - d4 : d4;
+
+                if (d5 < d3) {
+                    d3 = d5;
+                    enumdirection = enumdirection1;
+                }
+            }
+        }
+
+        float f = this.random.nextFloat() * 0.2F + 0.1F;
+        float f1 = (float) enumdirection.e().a();
+        Vec3D vec3d1 = this.getMot().a(0.75D);
+
+        if (enumdirection.n() == EnumDirection.EnumAxis.X) {
+            this.setMot((double) (f1 * f), vec3d1.y, vec3d1.z);
+        } else if (enumdirection.n() == EnumDirection.EnumAxis.Y) {
+            this.setMot(vec3d1.x, (double) (f1 * f), vec3d1.z);
+        } else if (enumdirection.n() == EnumDirection.EnumAxis.Z) {
+            this.setMot(vec3d1.x, vec3d1.y, (double) (f1 * f));
+        }
+
+    }
+
+    public void a(IBlockData iblockdata, Vec3D vec3d) {
+        this.fallDistance = 0.0F;
+        this.w = vec3d;
+    }
+
+    private static IChatBaseComponent b(IChatBaseComponent ichatbasecomponent) {
+        IChatMutableComponent ichatmutablecomponent = ichatbasecomponent.g().setChatModifier(ichatbasecomponent.getChatModifier().setChatClickable((ChatClickable) null));
+        Iterator iterator = ichatbasecomponent.getSiblings().iterator();
+
+        while (iterator.hasNext()) {
+            IChatBaseComponent ichatbasecomponent1 = (IChatBaseComponent) iterator.next();
+
+            ichatmutablecomponent.addSibling(b(ichatbasecomponent1));
+        }
+
+        return ichatmutablecomponent;
+    }
+
+    @Override
+    public IChatBaseComponent getDisplayName() {
+        IChatBaseComponent ichatbasecomponent = this.getCustomName();
+
+        return ichatbasecomponent != null ? b(ichatbasecomponent) : this.bQ();
+    }
+
+    protected IChatBaseComponent bQ() {
+        return this.f.h();
+    }
+
+    public boolean s(Entity entity) {
+        return this == entity;
+    }
+
+    public float getHeadRotation() {
+        return 0.0F;
+    }
+
+    public void setHeadRotation(float f) {}
+
+    public void n(float f) {}
+
+    public boolean bS() {
+        return true;
+    }
+
+    public boolean t(Entity entity) {
+        return false;
+    }
+
+    public String toString() {
+        return String.format(Locale.ROOT, "%s['%s'/%d, l='%s', x=%.2f, y=%.2f, z=%.2f]", this.getClass().getSimpleName(), this.getDisplayName().getString(), this.id, this.world == null ? "~NULL~" : this.world.toString(), this.locX(), this.locY(), this.locZ());
+    }
+
+    public boolean isInvulnerable(DamageSource damagesource) {
+        return this.invulnerable && damagesource != DamageSource.OUT_OF_WORLD && !damagesource.x();
+    }
+
+    public boolean isInvulnerable() {
+        return this.invulnerable;
+    }
+
+    public void setInvulnerable(boolean flag) {
+        this.invulnerable = flag;
+    }
+
+    public void u(Entity entity) {
+        this.setPositionRotation(entity.locX(), entity.locY(), entity.locZ(), entity.yaw, entity.pitch);
+    }
+
+    public void v(Entity entity) {
+        NBTTagCompound nbttagcompound = entity.save(new NBTTagCompound());
+
+        nbttagcompound.remove("Dimension");
+        this.load(nbttagcompound);
+        this.portalCooldown = entity.portalCooldown;
+        this.W = entity.W;
+    }
+
+    @Nullable
+    public Entity b(WorldServer worldserver) {
+        // CraftBukkit start
+        return teleportTo(worldserver, null);
+    }
+
+    @Nullable
+    public Entity teleportTo(WorldServer worldserver, BlockPosition location) {
+        // CraftBukkit end
+        if (this.world instanceof WorldServer && !this.cW()) {
+            this.world.getMethodProfiler().enter("changeDimension");
+            // CraftBukkit start
+            // this.decouple();
+            if (worldserver == null) {
+                return null;
+            }
+            // CraftBukkit end
+            this.world.getMethodProfiler().enter("reposition");
+            ShapeDetectorShape shapedetectorshape = (location == null) ? this.a(worldserver) : new ShapeDetectorShape(new Vec3D(location.getX(), location.getY(), location.getZ()), Vec3D.ORIGIN, this.yaw, this.pitch, worldserver, null); // CraftBukkit
+            if (shapedetectorshape == null) {
+                return null;
+            } else {
+                // CraftBukkit start
+                worldserver = shapedetectorshape.world;
+                this.decouple();
+                // CraftBukkit end
+
+                this.world.getMethodProfiler().exitEnter("reloading");
+                Entity entity = this.getEntityType().a((World) worldserver);
+
+                if (entity != null) {
+                    entity.v(this);
+                    entity.setPositionRotation(shapedetectorshape.position.x, shapedetectorshape.position.y, shapedetectorshape.position.z, shapedetectorshape.yaw, entity.pitch);
+                    entity.setMot(shapedetectorshape.velocity);
+                    worldserver.addEntityTeleport(entity);
+                    if (worldserver.getTypeKey() == DimensionManager.THE_END) { // CraftBukkit
+                        WorldServer.a(worldserver, this); // CraftBukkit
+                    }
+                    // CraftBukkit start - Forward the CraftEntity to the new entity
+                    this.getBukkitEntity().setHandle(entity);
+                    entity.bukkitEntity = this.getBukkitEntity();
+
+                    if (this instanceof EntityInsentient) {
+                        ((EntityInsentient) this).unleash(true, false); // Unleash to prevent duping of leads.
+                    }
+                    // CraftBukkit end
+                }
+
+                this.bU();
+                this.world.getMethodProfiler().exit();
+                ((WorldServer) this.world).resetEmptyTime();
+                worldserver.resetEmptyTime();
+                this.world.getMethodProfiler().exit();
+                return entity;
+            }
+        } else {
+            return null;
+        }
+    }
+
+    protected void bU() {
+        this.die(Entity.RemovalReason.CHANGED_DIMENSION);
+    }
+
+    @Nullable
+    protected ShapeDetectorShape a(WorldServer worldserver) {
+        // CraftBukkit start
+        if (worldserver == null) {
+            return null;
+        }
+        boolean flag = this.world.getTypeKey() == DimensionManager.THE_END && worldserver.getTypeKey() == DimensionManager.OVERWORLD; // fromEndToOverworld
+        boolean flag1 = worldserver.getTypeKey() == DimensionManager.THE_END; // targetIsEnd
+        // CraftBukkit end
+
+        if (!flag && !flag1) {
+            boolean flag2 = worldserver.getTypeKey() == DimensionManager.THE_NETHER; // CraftBukkit
+
+            if (this.world.getTypeKey() != DimensionManager.THE_NETHER && !flag2) {
+                return null;
+            } else {
+                WorldBorder worldborder = worldserver.getWorldBorder();
+                double d0 = Math.max(-2.9999872E7D, worldborder.e() + 16.0D);
+                double d1 = Math.max(-2.9999872E7D, worldborder.f() + 16.0D);
+                double d2 = Math.min(2.9999872E7D, worldborder.g() - 16.0D);
+                double d3 = Math.min(2.9999872E7D, worldborder.h() - 16.0D);
+                double d4 = DimensionManager.a(this.world.getDimensionManager(), worldserver.getDimensionManager());
+                BlockPosition blockposition = new BlockPosition(MathHelper.a(this.locX() * d4, d0, d2), this.locY(), MathHelper.a(this.locZ() * d4, d1, d3));
+                // CraftBukkit start
+                CraftPortalEvent event = callPortalEvent(this, worldserver, blockposition, PlayerTeleportEvent.TeleportCause.NETHER_PORTAL, flag2 ? 16 : 128, 16);
+                if (event == null) {
+                    return null;
+                }
+                final WorldServer worldserverFinal = worldserver = ((CraftWorld) event.getTo().getWorld()).getHandle();
+                blockposition = new BlockPosition(event.getTo().getX(), event.getTo().getY(), event.getTo().getZ());
+
+                return (ShapeDetectorShape) this.a(worldserver, blockposition, flag2, event.getSearchRadius(), event.getCanCreatePortal(), event.getCreationRadius()).map((blockutil_rectangle) -> {
+                    // CraftBukkit end
+                    IBlockData iblockdata = this.world.getType(this.W);
+                    EnumDirection.EnumAxis enumdirection_enumaxis;
+                    Vec3D vec3d;
+
+                    if (iblockdata.b(BlockProperties.E)) {
+                        enumdirection_enumaxis = (EnumDirection.EnumAxis) iblockdata.get(BlockProperties.E);
+                        BlockUtil.Rectangle blockutil_rectangle1 = BlockUtil.a(this.W, enumdirection_enumaxis, 21, EnumDirection.EnumAxis.Y, 21, (blockposition1) -> {
+                            return this.world.getType(blockposition1) == iblockdata;
+                        });
+
+                        vec3d = this.a(enumdirection_enumaxis, blockutil_rectangle1);
+                    } else {
+                        enumdirection_enumaxis = EnumDirection.EnumAxis.X;
+                        vec3d = new Vec3D(0.5D, 0.0D, 0.0D);
+                    }
+
+                    return BlockPortalShape.a(worldserverFinal, blockutil_rectangle, enumdirection_enumaxis, vec3d, this.a(this.getPose()), this.getMot(), this.yaw, this.pitch, event); // CraftBukkit
+                }).orElse(null); // CraftBuukkit - decompile error
+            }
+        } else {
+            BlockPosition blockposition1;
+
+            if (flag1) {
+                blockposition1 = WorldServer.a;
+            } else {
+                blockposition1 = worldserver.getHighestBlockYAt(HeightMap.Type.MOTION_BLOCKING_NO_LEAVES, worldserver.getSpawn());
+            }
+            // CraftBukkit start
+            CraftPortalEvent event = callPortalEvent(this, worldserver, blockposition1, PlayerTeleportEvent.TeleportCause.END_PORTAL, 0, 0);
+            if (event == null) {
+                return null;
+            }
+            blockposition1 = new BlockPosition(event.getTo().getX(), event.getTo().getY(), event.getTo().getZ());
+
+            return new ShapeDetectorShape(new Vec3D((double) blockposition1.getX() + 0.5D, (double) blockposition1.getY(), (double) blockposition1.getZ() + 0.5D), this.getMot(), this.yaw, this.pitch, ((CraftWorld) event.getTo().getWorld()).getHandle(), event);
+            // CraftBukkit end
+        }
+    }
+
+    protected Vec3D a(EnumDirection.EnumAxis enumdirection_enumaxis, BlockUtil.Rectangle blockutil_rectangle) {
+        return BlockPortalShape.a(blockutil_rectangle, enumdirection_enumaxis, this.getPositionVector(), this.a(this.getPose()));
+    }
+
+    // CraftBukkit start
+    protected CraftPortalEvent callPortalEvent(Entity entity, WorldServer exitWorldServer, BlockPosition exitPosition, PlayerTeleportEvent.TeleportCause cause, int searchRadius, int creationRadius) {
+        org.bukkit.entity.Entity bukkitEntity = entity.getBukkitEntity();
+        Location enter = bukkitEntity.getLocation();
+        Location exit = new Location(exitWorldServer.getWorld(), exitPosition.getX(), exitPosition.getY(), exitPosition.getZ());
+
+        EntityPortalEvent event = new EntityPortalEvent(bukkitEntity, enter, exit, searchRadius);
+        event.getEntity().getServer().getPluginManager().callEvent(event);
+        if (event.isCancelled() || event.getTo() == null || event.getTo().getWorld() == null || !entity.isAlive()) {
+            return null;
+        }
+        return new CraftPortalEvent(event);
+    }
+
+    protected Optional<BlockUtil.Rectangle> a(WorldServer worldserver, BlockPosition blockposition, boolean flag, int searchRadius, boolean canCreatePortal, int createRadius) { // PAIL rename findOrCreatePortal
+        return worldserver.getTravelAgent().findPortal(blockposition, searchRadius);
+        // CraftBukkit end
+    }
+
+    public boolean canPortal() {
+        return true;
+    }
+
+    public float a(Explosion explosion, IBlockAccess iblockaccess, BlockPosition blockposition, IBlockData iblockdata, Fluid fluid, float f) {
+        return f;
+    }
+
+    public boolean a(Explosion explosion, IBlockAccess iblockaccess, BlockPosition blockposition, IBlockData iblockdata, float f) {
+        return true;
+    }
+
+    public int bW() {
+        return 3;
+    }
+
+    public boolean isIgnoreBlockTrigger() {
+        return false;
+    }
+
+    public void appendEntityCrashDetails(CrashReportSystemDetails crashreportsystemdetails) {
+        crashreportsystemdetails.a("Entity Type", () -> {
+            return EntityTypes.getName(this.getEntityType()) + " (" + this.getClass().getCanonicalName() + ")";
+        });
+        crashreportsystemdetails.a("Entity ID", (Object) this.id);
+        crashreportsystemdetails.a("Entity Name", () -> {
+            return this.getDisplayName().getString();
+        });
+        crashreportsystemdetails.a("Entity's Exact location", (Object) String.format(Locale.ROOT, "%.2f, %.2f, %.2f", this.locX(), this.locY(), this.locZ()));
+        crashreportsystemdetails.a("Entity's Block location", (Object) CrashReportSystemDetails.a(this.world, MathHelper.floor(this.locX()), MathHelper.floor(this.locY()), MathHelper.floor(this.locZ())));
+        Vec3D vec3d = this.getMot();
+
+        crashreportsystemdetails.a("Entity's Momentum", (Object) String.format(Locale.ROOT, "%.2f, %.2f, %.2f", vec3d.x, vec3d.y, vec3d.z));
+        crashreportsystemdetails.a("Entity's Passengers", () -> {
+            return this.getPassengers().toString();
+        });
+        crashreportsystemdetails.a("Entity's Vehicle", () -> {
+            return this.getVehicle().toString();
+        });
+    }
+
+    public void a_(UUID uuid) {
+        this.uniqueID = uuid;
+        this.Y = this.uniqueID.toString();
+    }
+
+    public UUID getUniqueID() {
+        return this.uniqueID;
+    }
+
+    @Override public UUID bZ() { return getUniqueID(); } // PAIL getUniqueID (should've worked, but it didn't work)
+
+    public String getUniqueIDString() {
+        return this.Y;
+    }
+
+    public String getName() {
+        return this.Y;
+    }
+
+    public boolean cc() {
+        return true;
+    }
+
+    @Override
+    public IChatBaseComponent getScoreboardDisplayName() {
+        return ScoreboardTeam.a(this.getScoreboardTeam(), this.getDisplayName()).format((chatmodifier) -> {
+            return chatmodifier.setChatHoverable(this.ci()).setInsertion(this.getUniqueIDString());
+        });
+    }
+
+    public void setCustomName(@Nullable IChatBaseComponent ichatbasecomponent) {
+        this.datawatcher.set(Entity.am, Optional.ofNullable(ichatbasecomponent));
+    }
+
+    @Nullable
+    @Override
+    public IChatBaseComponent getCustomName() {
+        return (IChatBaseComponent) ((Optional) this.datawatcher.get(Entity.am)).orElse((Object) null);
+    }
+
+    @Override
+    public boolean hasCustomName() {
+        return ((Optional) this.datawatcher.get(Entity.am)).isPresent();
+    }
+
+    public void setCustomNameVisible(boolean flag) {
+        this.datawatcher.set(Entity.an, flag);
+    }
+
+    public boolean getCustomNameVisible() {
+        return (Boolean) this.datawatcher.get(Entity.an);
+    }
+
+    public final void enderTeleportAndLoad(double d0, double d1, double d2) {
+        if (this.world instanceof WorldServer) {
+            ChunkCoordIntPair chunkcoordintpair = new ChunkCoordIntPair(new BlockPosition(d0, d1, d2));
+
+            ((WorldServer) this.world).getChunkProvider().addTicket(TicketType.POST_TELEPORT, chunkcoordintpair, 0, this.getId());
+            this.world.getChunkAt(chunkcoordintpair.x, chunkcoordintpair.z);
+            this.enderTeleportTo(d0, d1, d2);
+        }
+    }
+
+    public void enderTeleportTo(double d0, double d1, double d2) {
+        if (this.world instanceof WorldServer) {
+            WorldServer worldserver = (WorldServer) this.world;
+
+            this.setPositionRotation(d0, d1, d2, this.yaw, this.pitch);
+            this.cu().forEach((entity) -> {
+                UnmodifiableIterator unmodifiableiterator = entity.passengers.iterator();
+
+                while (unmodifiableiterator.hasNext()) {
+                    Entity entity1 = (Entity) unmodifiableiterator.next();
+
+                    entity.a(entity1, Entity::teleportAndSync);
+                }
+
+            });
+        }
+    }
+
+    public void a(DataWatcherObject<?> datawatcherobject) {
+        if (Entity.POSE.equals(datawatcherobject)) {
+            this.updateSize();
+        }
+
+    }
+
+    public void updateSize() {
+        EntitySize entitysize = this.size;
+        EntityPose entitypose = this.getPose();
+        EntitySize entitysize1 = this.a(entitypose);
+
+        this.size = entitysize1;
+        this.headHeight = this.getHeadHeight(entitypose, entitysize1);
+        if (entitysize1.width < entitysize.width) {
+            double d0 = (double) entitysize1.width / 2.0D;
+
+            this.a(new AxisAlignedBB(this.locX() - d0, this.locY(), this.locZ() - d0, this.locX() + d0, this.locY() + (double) entitysize1.height, this.locZ() + d0));
+        } else {
+            AxisAlignedBB axisalignedbb = this.getBoundingBox();
+
+            this.a(new AxisAlignedBB(axisalignedbb.minX, axisalignedbb.minY, axisalignedbb.minZ, axisalignedbb.minX + (double) entitysize1.width, axisalignedbb.minY + (double) entitysize1.height, axisalignedbb.minZ + (double) entitysize1.width));
+            if (entitysize1.width > entitysize.width && !this.justCreated && !this.world.isClientSide) {
+                float f = entitysize.width - entitysize1.width;
+
+                this.move(EnumMoveType.SELF, new Vec3D((double) f, 0.0D, (double) f));
+            }
+
+        }
+    }
+
+    public EnumDirection getDirection() {
+        return EnumDirection.fromAngle((double) this.yaw);
+    }
+
+    public EnumDirection getAdjustedDirection() {
+        return this.getDirection();
+    }
+
+    protected ChatHoverable ci() {
+        return new ChatHoverable(ChatHoverable.EnumHoverAction.SHOW_ENTITY, new ChatHoverable.b(this.getEntityType(), this.getUniqueID(), this.getDisplayName()));
+    }
+
+    public boolean a(EntityPlayer entityplayer) {
+        return true;
+    }
+
+    @Override
+    public AxisAlignedBB getBoundingBox() {
+        return this.boundingBox;
+    }
+
+    protected AxisAlignedBB d(EntityPose entitypose) {
+        EntitySize entitysize = this.a(entitypose);
+        float f = entitysize.width / 2.0F;
+        Vec3D vec3d = new Vec3D(this.locX() - (double) f, this.locY(), this.locZ() - (double) f);
+        Vec3D vec3d1 = new Vec3D(this.locX() + (double) f, this.locY() + (double) entitysize.height, this.locZ() + (double) f);
+
+        return new AxisAlignedBB(vec3d, vec3d1);
+    }
+
+    public void a(AxisAlignedBB axisalignedbb) {
+        // CraftBukkit start - block invalid bounding boxes
+        double minX = axisalignedbb.minX,
+                minY = axisalignedbb.minY,
+                minZ = axisalignedbb.minZ,
+                maxX = axisalignedbb.maxX,
+                maxY = axisalignedbb.maxY,
+                maxZ = axisalignedbb.maxZ;
+        double len = axisalignedbb.maxX - axisalignedbb.minX;
+        if (len < 0) maxX = minX;
+        if (len > 64) maxX = minX + 64.0;
+
+        len = axisalignedbb.maxY - axisalignedbb.minY;
+        if (len < 0) maxY = minY;
+        if (len > 64) maxY = minY + 64.0;
+
+        len = axisalignedbb.maxZ - axisalignedbb.minZ;
+        if (len < 0) maxZ = minZ;
+        if (len > 64) maxZ = minZ + 64.0;
+        this.boundingBox = new AxisAlignedBB(minX, minY, minZ, maxX, maxY, maxZ);
+        // CraftBukkit end
+    }
+
+    protected float getHeadHeight(EntityPose entitypose, EntitySize entitysize) {
+        return entitysize.height * 0.85F;
+    }
+
+    public final float getHeadHeight() {
+        return this.headHeight;
+    }
+
+    public SlotAccess k(int i) {
+        return SlotAccess.a;
+    }
+
+    @Override
+    public void sendMessage(IChatBaseComponent ichatbasecomponent, UUID uuid) {}
+
+    public World getWorld() {
+        return this.world;
+    }
+
+    @Nullable
+    public MinecraftServer getMinecraftServer() {
+        return this.world.getMinecraftServer();
+    }
+
+    public EnumInteractionResult a(EntityHuman entityhuman, Vec3D vec3d, EnumHand enumhand) {
+        return EnumInteractionResult.PASS;
+    }
+
+    public boolean cp() {
+        return false;
+    }
+
+    public void a(EntityLiving entityliving, Entity entity) {
+        if (entity instanceof EntityLiving) {
+            EnchantmentManager.a((EntityLiving) entity, (Entity) entityliving);
+        }
+
+        EnchantmentManager.b(entityliving, entity);
+    }
+
+    public void b(EntityPlayer entityplayer) {}
+
+    public void c(EntityPlayer entityplayer) {}
+
+    public float a(EnumBlockRotation enumblockrotation) {
+        float f = MathHelper.g(this.yaw);
+
+        switch (enumblockrotation) {
+            case CLOCKWISE_180:
+                return f + 180.0F;
+            case COUNTERCLOCKWISE_90:
+                return f + 270.0F;
+            case CLOCKWISE_90:
+                return f + 90.0F;
+            default:
+                return f;
+        }
+    }
+
+    public float a(EnumBlockMirror enumblockmirror) {
+        float f = MathHelper.g(this.yaw);
+
+        switch (enumblockmirror) {
+            case LEFT_RIGHT:
+                return -f;
+            case FRONT_BACK:
+                return 180.0F - f;
+            default:
+                return f;
+        }
+    }
+
+    public boolean cq() {
+        return false;
+    }
+
+    @Nullable
+    public Entity getRidingPassenger() {
+        return null;
+    }
+
+    public final List<Entity> getPassengers() {
+        return this.passengers;
+    }
+
+    @Nullable
+    public Entity ct() {
+        return this.passengers.isEmpty() ? null : (Entity) this.passengers.get(0);
+    }
+
+    public boolean w(Entity entity) {
+        return this.passengers.contains(entity);
+    }
+
+    public boolean a(Predicate<Entity> predicate) {
+        UnmodifiableIterator unmodifiableiterator = this.passengers.iterator();
+
+        Entity entity;
+
+        do {
+            if (!unmodifiableiterator.hasNext()) {
+                return false;
+            }
+
+            entity = (Entity) unmodifiableiterator.next();
+        } while (!predicate.test(entity));
+
+        return true;
+    }
+
+    private Stream<Entity> n() {
+        return this.passengers.stream().flatMap(Entity::cu);
+    }
+
+    public Stream<Entity> cu() {
+        return Stream.concat(Stream.of(this), this.n());
+    }
+
+    @Override
+    public Stream<Entity> cv() {
+        return Stream.concat(this.passengers.stream().flatMap(Entity::cv), Stream.of(this));
+    }
+
+    public Iterable<Entity> getAllPassengers() {
+        return () -> {
+            return this.n().iterator();
+        };
+    }
+
+    public boolean hasSinglePlayerPassenger() {
+        return this.n().filter((entity) -> {
+            return entity instanceof EntityHuman;
+        }).count() == 1L;
+    }
+
+    public Entity getRootVehicle() {
+        Entity entity;
+
+        for (entity = this; entity.isPassenger(); entity = entity.getVehicle()) {
+            ;
+        }
+
+        return entity;
+    }
+
+    public boolean isSameVehicle(Entity entity) {
+        return this.getRootVehicle() == entity.getRootVehicle();
+    }
+
+    public boolean cz() {
+        Entity entity = this.getRidingPassenger();
+
+        return entity instanceof EntityHuman ? ((EntityHuman) entity).eU() : !this.world.isClientSide;
+    }
+
+    protected static Vec3D a(double d0, double d1, float f) {
+        double d2 = (d0 + d1 + 9.999999747378752E-6D) / 2.0D;
+        float f1 = -MathHelper.sin(f * 0.017453292F);
+        float f2 = MathHelper.cos(f * 0.017453292F);
+        float f3 = Math.max(Math.abs(f1), Math.abs(f2));
+
+        return new Vec3D((double) f1 * d2 / (double) f3, 0.0D, (double) f2 * d2 / (double) f3);
+    }
+
+    public Vec3D b(EntityLiving entityliving) {
+        return new Vec3D(this.locX(), this.getBoundingBox().maxY, this.locZ());
+    }
+
+    @Nullable
+    public Entity getVehicle() {
+        return this.vehicle;
+    }
+
+    public EnumPistonReaction getPushReaction() {
+        return EnumPistonReaction.NORMAL;
+    }
+
+    public SoundCategory getSoundCategory() {
+        return SoundCategory.NEUTRAL;
+    }
+
+    public int getMaxFireTicks() {
+        return 1;
+    }
+
+    public CommandListenerWrapper getCommandListener() {
+        return new CommandListenerWrapper(this, this.getPositionVector(), this.bk(), this.world instanceof WorldServer ? (WorldServer) this.world : null, this.y(), this.getDisplayName().getString(), this.getScoreboardDisplayName(), this.world.getMinecraftServer(), this);
+    }
+
+    protected int y() {
+        return 0;
+    }
+
+    public boolean l(int i) {
+        return this.y() >= i;
+    }
+
+    @Override
+    public boolean shouldSendSuccess() {
+        return this.world.getGameRules().getBoolean(GameRules.SEND_COMMAND_FEEDBACK);
+    }
+
+    @Override
+    public boolean shouldSendFailure() {
+        return true;
+    }
+
+    @Override
+    public boolean shouldBroadcastCommands() {
+        return true;
+    }
+
+    public void a(ArgumentAnchor.Anchor argumentanchor_anchor, Vec3D vec3d) {
+        Vec3D vec3d1 = argumentanchor_anchor.a(this);
+        double d0 = vec3d.x - vec3d1.x;
+        double d1 = vec3d.y - vec3d1.y;
+        double d2 = vec3d.z - vec3d1.z;
+        double d3 = (double) MathHelper.sqrt(d0 * d0 + d2 * d2);
+
+        this.pitch = MathHelper.g((float) (-(MathHelper.d(d1, d3) * 57.2957763671875D)));
+        this.yaw = MathHelper.g((float) (MathHelper.d(d2, d0) * 57.2957763671875D) - 90.0F);
+        this.setHeadRotation(this.yaw);
+        this.lastPitch = this.pitch;
+        this.lastYaw = this.yaw;
+    }
+
+    public boolean a(Tag<FluidType> tag, double d0) {
+        AxisAlignedBB axisalignedbb = this.getBoundingBox().shrink(0.001D);
+        int i = MathHelper.floor(axisalignedbb.minX);
+        int j = MathHelper.f(axisalignedbb.maxX);
+        int k = MathHelper.floor(axisalignedbb.minY);
+        int l = MathHelper.f(axisalignedbb.maxY);
+        int i1 = MathHelper.floor(axisalignedbb.minZ);
+        int j1 = MathHelper.f(axisalignedbb.maxZ);
+
+        if (!this.world.isAreaLoaded(i, k, i1, j, l, j1)) {
+            return false;
+        } else {
+            double d1 = 0.0D;
+            boolean flag = this.cc();
+            boolean flag1 = false;
+            Vec3D vec3d = Vec3D.ORIGIN;
+            int k1 = 0;
+            BlockPosition.MutableBlockPosition blockposition_mutableblockposition = new BlockPosition.MutableBlockPosition();
+
+            for (int l1 = i; l1 < j; ++l1) {
+                for (int i2 = k; i2 < l; ++i2) {
+                    for (int j2 = i1; j2 < j1; ++j2) {
+                        blockposition_mutableblockposition.d(l1, i2, j2);
+                        Fluid fluid = this.world.getFluid(blockposition_mutableblockposition);
+
+                        if (fluid.a(tag)) {
+                            double d2 = (double) ((float) i2 + fluid.getHeight(this.world, blockposition_mutableblockposition));
+
+                            if (d2 >= axisalignedbb.minY) {
+                                flag1 = true;
+                                d1 = Math.max(d2 - axisalignedbb.minY, d1);
+                                if (flag) {
+                                    Vec3D vec3d1 = fluid.c(this.world, blockposition_mutableblockposition);
+
+                                    if (d1 < 0.4D) {
+                                        vec3d1 = vec3d1.a(d1);
+                                    }
+
+                                    vec3d = vec3d.e(vec3d1);
+                                    ++k1;
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+
+            if (vec3d.f() > 0.0D) {
+                if (k1 > 0) {
+                    vec3d = vec3d.a(1.0D / (double) k1);
+                }
+
+                if (!(this instanceof EntityHuman)) {
+                    vec3d = vec3d.d();
+                }
+
+                Vec3D vec3d2 = this.getMot();
+
+                vec3d = vec3d.a(d0 * 1.0D);
+                double d3 = 0.003D;
+
+                if (Math.abs(vec3d2.x) < 0.003D && Math.abs(vec3d2.z) < 0.003D && vec3d.f() < 0.0045000000000000005D) {
+                    vec3d = vec3d.d().a(0.0045000000000000005D);
+                }
+
+                this.setMot(this.getMot().e(vec3d));
+            }
+
+            this.K.put(tag, d1);
+            return flag1;
+        }
+    }
+
+    public double b(Tag<FluidType> tag) {
+        return this.K.getDouble(tag);
+    }
+
+    public double cE() {
+        return (double) this.getHeadHeight() < 0.4D ? 0.0D : 0.4D;
+    }
+
+    public final float getWidth() {
+        return this.size.width;
+    }
+
+    public final float getHeight() {
+        return this.size.height;
+    }
+
+    public abstract Packet<?> P();
+
+    public EntitySize a(EntityPose entitypose) {
+        return this.f.m();
+    }
+
+    public Vec3D getPositionVector() {
+        return this.loc;
+    }
+
+    @Override
+    public BlockPosition getChunkCoordinates() {
+        return this.locBlock;
+    }
+
+    public ChunkCoordIntPair chunkPosition() {
+        return new ChunkCoordIntPair(this.locBlock);
+    }
+
+    public Vec3D getMot() {
+        return this.mot;
+    }
+
+    public void setMot(Vec3D vec3d) {
+        this.mot = vec3d;
+    }
+
+    public void setMot(double d0, double d1, double d2) {
+        this.setMot(new Vec3D(d0, d1, d2));
+    }
+
+    public final int cL() {
+        return this.locBlock.getX();
+    }
+
+    public final double locX() {
+        return this.loc.x;
+    }
+
+    public double c(double d0) {
+        return this.loc.x + (double) this.getWidth() * d0;
+    }
+
+    public double d(double d0) {
+        return this.c((2.0D * this.random.nextDouble() - 1.0D) * d0);
+    }
+
+    public final int cN() {
+        return this.locBlock.getY();
+    }
+
+    public final double locY() {
+        return this.loc.y;
+    }
+
+    public double e(double d0) {
+        return this.loc.y + (double) this.getHeight() * d0;
+    }
+
+    public double cP() {
+        return this.e(this.random.nextDouble());
+    }
+
+    public double getHeadY() {
+        return this.loc.y + (double) this.headHeight;
+    }
+
+    public final int cR() {
+        return this.locBlock.getZ();
+    }
+
+    public final double locZ() {
+        return this.loc.z;
+    }
+
+    public double f(double d0) {
+        return this.loc.z + (double) this.getWidth() * d0;
+    }
+
+    public double g(double d0) {
+        return this.f((2.0D * this.random.nextDouble() - 1.0D) * d0);
+    }
+
+    public void setPositionRaw(double d0, double d1, double d2) {
+        if (this.loc.x != d0 || this.loc.y != d1 || this.loc.z != d2) {
+            this.loc = new Vec3D(d0, d1, d2);
+            int i = MathHelper.floor(d0);
+            int j = MathHelper.floor(d1);
+            int k = MathHelper.floor(d2);
+
+            if (i != this.locBlock.getX() || j != this.locBlock.getY() || k != this.locBlock.getZ()) {
+                this.locBlock = new BlockPosition(i, j, k);
+            }
+
+            this.ar.a();
+            clc clc = this.bI();
+
+            if (clc != null) {
+                clc.b(this.world);
+            }
+        }
+
+    }
+
+    public void checkDespawn() {}
+
+    public void n(boolean flag) {
+        this.aa = flag;
+    }
+
+    public boolean cV() {
+        return false;
+    }
+
+    public final boolean cW() {
+        return this.dead != null;
+    }
+
+    @Override
+    public void die(Entity.RemovalReason entity_removalreason) {
+        if (this.dead == null) {
+            this.dead = entity_removalreason;
+        }
+
+        this.getPassengers().forEach(Entity::stopRiding);
+        this.ar.a(entity_removalreason);
+    }
+
+    protected void cY() {
+        this.dead = null;
+    }
+
+    @Override
+    public void a(EntityInWorldCallback entityinworldcallback) {
+        this.ar = entityinworldcallback;
+    }
+
+    @Override
+    public boolean cZ() {
+        return this.dead != null && !this.dead.b() ? false : (this.isPassenger() ? false : !this.isVehicle() || !this.hasSinglePlayerPassenger());
+    }
+
+    @Override
+    public boolean da() {
+        return false;
+    }
+
+    public static enum RemovalReason {
+
+        KILLED(true, false), DISCARDED(true, false), UNLOADED_TO_CHUNK(false, true), UNLOADED_WITH_PLAYER(false, false), CHANGED_DIMENSION(false, false);
+
+        private final boolean f;
+        private final boolean g;
+
+        private RemovalReason(boolean flag, boolean flag1) {
+            this.f = flag;
+            this.g = flag1;
+        }
+
+        public boolean a() {
+            return this.f;
+        }
+
+        public boolean b() {
+            return this.g;
+        }
+    }
+
+    @FunctionalInterface
+    public interface a {
+
+        void accept(Entity entity, double d0, double d1, double d2);
+    }
+}
diff --git a/src/main/java/net/minecraft/server/EntityAgeable.java b/src/main/java/net/minecraft/server/EntityAgeable.java
new file mode 100644
index 00000000..8c720fa5
--- /dev/null
+++ b/src/main/java/net/minecraft/server/EntityAgeable.java
@@ -0,0 +1,212 @@
+package net.minecraft.server;
+
+import javax.annotation.Nullable;
+
+public abstract class EntityAgeable extends EntityCreature {
+
+    private static final DataWatcherObject<Boolean> bj = DataWatcher.a(EntityAgeable.class, DataWatcherRegistry.i);
+    protected int b;
+    protected int c;
+    protected int d;
+    public boolean ageLocked; // CraftBukkit
+
+    protected EntityAgeable(EntityTypes<? extends EntityAgeable> entitytypes, World world) {
+        super(entitytypes, world);
+    }
+
+    // Spigot start
+    @Override
+    public void inactiveTick()
+    {
+        super.inactiveTick();
+        if ( this.world.isClientSide || this.ageLocked )
+        { // CraftBukkit
+            this.updateSize();
+        } else
+        {
+            int i = this.getAge();
+
+            if ( i < 0 )
+            {
+                ++i;
+                this.setAgeRaw( i );
+            } else if ( i > 0 )
+            {
+                --i;
+                this.setAgeRaw( i );
+            }
+        }
+    }
+    // Spigot end
+
+    @Override
+    public GroupDataEntity prepare(WorldAccess worldaccess, DifficultyDamageScaler difficultydamagescaler, EnumMobSpawn enummobspawn, @Nullable GroupDataEntity groupdataentity, @Nullable NBTTagCompound nbttagcompound) {
+        if (groupdataentity == null) {
+            groupdataentity = new a(true);
+        }
+
+        a entityageable_a = (a) groupdataentity;
+
+        if (entityageable_a.c() && entityageable_a.a() > 0 && this.random.nextFloat() <= entityageable_a.d()) {
+            this.setAgeRaw(-24000);
+        }
+
+        entityageable_a.b();
+        return super.prepare(worldaccess, difficultydamagescaler, enummobspawn, (GroupDataEntity) groupdataentity, nbttagcompound);
+    }
+
+    @Nullable
+    public abstract EntityAgeable createChild(WorldServer worldserver, EntityAgeable entityageable);
+
+    @Override
+    protected void initDatawatcher() {
+        super.initDatawatcher();
+        this.datawatcher.register(EntityAgeable.bj, false);
+    }
+
+    public boolean canBreed() {
+        return false;
+    }
+
+    public int getAge() {
+        return this.world.isClientSide ? ((Boolean) this.datawatcher.get(EntityAgeable.bj) ? -1 : 1) : this.b;
+    }
+
+    public void setAge(int i, boolean flag) {
+        int j = this.getAge();
+        int k = j;
+
+        j += i * 20;
+        if (j > 0) {
+            j = 0;
+        }
+
+        int l = j - k;
+
+        this.setAgeRaw(j);
+        if (flag) {
+            this.c += l;
+            if (this.d == 0) {
+                this.d = 40;
+            }
+        }
+
+        if (this.getAge() == 0) {
+            this.setAgeRaw(this.c);
+        }
+
+    }
+
+    public void setAge(int i) {
+        this.setAge(i, false);
+    }
+
+    public void setAgeRaw(int i) {
+        int j = this.b;
+
+        this.b = i;
+        if (j < 0 && i >= 0 || j >= 0 && i < 0) {
+            this.datawatcher.set(EntityAgeable.bj, i < 0);
+            this.m();
+        }
+
+    }
+
+    @Override
+    public void saveData(NBTTagCompound nbttagcompound) {
+        super.saveData(nbttagcompound);
+        nbttagcompound.setInt("Age", this.getAge());
+        nbttagcompound.setInt("ForcedAge", this.c);
+        nbttagcompound.setBoolean("AgeLocked", this.ageLocked); // CraftBukkit
+    }
+
+    @Override
+    public void loadData(NBTTagCompound nbttagcompound) {
+        super.loadData(nbttagcompound);
+        this.setAgeRaw(nbttagcompound.getInt("Age"));
+        this.c = nbttagcompound.getInt("ForcedAge");
+        this.ageLocked = nbttagcompound.getBoolean("AgeLocked"); // CraftBukkit
+    }
+
+    @Override
+    public void a(DataWatcherObject<?> datawatcherobject) {
+        if (EntityAgeable.bj.equals(datawatcherobject)) {
+            this.updateSize();
+        }
+
+        super.a(datawatcherobject);
+    }
+
+    @Override
+    public void movementTick() {
+        super.movementTick();
+        if (this.world.isClientSide || ageLocked) { // CraftBukkit
+            if (this.d > 0) {
+                if (this.d % 4 == 0) {
+                    this.world.addParticle(Particles.HAPPY_VILLAGER, this.d(1.0D), this.cP() + 0.5D, this.g(1.0D), 0.0D, 0.0D, 0.0D);
+                }
+
+                --this.d;
+            }
+        } else if (this.isAlive()) {
+            int i = this.getAge();
+
+            if (i < 0) {
+                ++i;
+                this.setAgeRaw(i);
+            } else if (i > 0) {
+                --i;
+                this.setAgeRaw(i);
+            }
+        }
+
+    }
+
+    protected void m() {}
+
+    @Override
+    public boolean isBaby() {
+        return this.getAge() < 0;
+    }
+
+    @Override
+    public void setBaby(boolean flag) {
+        this.setAgeRaw(flag ? -24000 : 0);
+    }
+
+    public static class a implements GroupDataEntity {
+
+        private int a;
+        private final boolean b;
+        private final float c;
+
+        private a(boolean flag, float f) {
+            this.b = flag;
+            this.c = f;
+        }
+
+        public a(boolean flag) {
+            this(flag, 0.05F);
+        }
+
+        public a(float f) {
+            this(true, f);
+        }
+
+        public int a() {
+            return this.a;
+        }
+
+        public void b() {
+            ++this.a;
+        }
+
+        public boolean c() {
+            return this.b;
+        }
+
+        public float d() {
+            return this.c;
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/server/EntityAreaEffectCloud.java b/src/main/java/net/minecraft/server/EntityAreaEffectCloud.java
new file mode 100644
index 00000000..148e523a
--- /dev/null
+++ b/src/main/java/net/minecraft/server/EntityAreaEffectCloud.java
@@ -0,0 +1,477 @@
+package net.minecraft.server;
+
+import com.google.common.collect.Lists;
+import com.google.common.collect.Maps;
+import com.mojang.brigadier.StringReader;
+import com.mojang.brigadier.exceptions.CommandSyntaxException;
+import java.util.Collection;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.UUID;
+import javax.annotation.Nullable;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+// CraftBukkit start
+import org.bukkit.craftbukkit.entity.CraftLivingEntity;
+import org.bukkit.entity.LivingEntity;
+// CraftBukkit end
+
+public class EntityAreaEffectCloud extends Entity {
+
+    private static final Logger LOGGER = LogManager.getLogger();
+    private static final DataWatcherObject<Float> c = DataWatcher.a(EntityAreaEffectCloud.class, DataWatcherRegistry.c);
+    private static final DataWatcherObject<Integer> COLOR = DataWatcher.a(EntityAreaEffectCloud.class, DataWatcherRegistry.b);
+    private static final DataWatcherObject<Boolean> e = DataWatcher.a(EntityAreaEffectCloud.class, DataWatcherRegistry.i);
+    private static final DataWatcherObject<ParticleParam> f = DataWatcher.a(EntityAreaEffectCloud.class, DataWatcherRegistry.j);
+    private PotionRegistry potionRegistry;
+    public List<MobEffect> effects;
+    private final Map<Entity, Integer> affectedEntities;
+    private int duration;
+    public int waitTime;
+    public int reapplicationDelay;
+    private boolean hasColor;
+    public int durationOnUse;
+    public float radiusOnUse;
+    public float radiusPerTick;
+    @Nullable
+    private EntityLiving ak;
+    @Nullable
+    private UUID al;
+
+    public EntityAreaEffectCloud(EntityTypes<? extends EntityAreaEffectCloud> entitytypes, World world) {
+        super(entitytypes, world);
+        this.potionRegistry = Potions.EMPTY;
+        this.effects = Lists.newArrayList();
+        this.affectedEntities = Maps.newHashMap();
+        this.duration = 600;
+        this.waitTime = 20;
+        this.reapplicationDelay = 20;
+        this.noclip = true;
+        this.setRadius(3.0F);
+    }
+
+    public EntityAreaEffectCloud(World world, double d0, double d1, double d2) {
+        this(EntityTypes.AREA_EFFECT_CLOUD, world);
+        this.setPosition(d0, d1, d2);
+    }
+
+    @Override
+    protected void initDatawatcher() {
+        this.getDataWatcher().register(EntityAreaEffectCloud.COLOR, 0);
+        this.getDataWatcher().register(EntityAreaEffectCloud.c, 0.5F);
+        this.getDataWatcher().register(EntityAreaEffectCloud.e, false);
+        this.getDataWatcher().register(EntityAreaEffectCloud.f, Particles.ENTITY_EFFECT);
+    }
+
+    public void setRadius(float f) {
+        if (!this.world.isClientSide) {
+            this.getDataWatcher().set(EntityAreaEffectCloud.c, f);
+        }
+
+    }
+
+    @Override
+    public void updateSize() {
+        double d0 = this.locX();
+        double d1 = this.locY();
+        double d2 = this.locZ();
+
+        super.updateSize();
+        this.setPosition(d0, d1, d2);
+    }
+
+    public float getRadius() {
+        return (Float) this.getDataWatcher().get(EntityAreaEffectCloud.c);
+    }
+
+    public void a(PotionRegistry potionregistry) {
+        this.potionRegistry = potionregistry;
+        if (!this.hasColor) {
+            this.u();
+        }
+
+    }
+
+    private void u() {
+        if (this.potionRegistry == Potions.EMPTY && this.effects.isEmpty()) {
+            this.getDataWatcher().set(EntityAreaEffectCloud.COLOR, 0);
+        } else {
+            this.getDataWatcher().set(EntityAreaEffectCloud.COLOR, PotionUtil.a((Collection) PotionUtil.a(this.potionRegistry, (Collection) this.effects)));
+        }
+
+    }
+
+    public void addEffect(MobEffect mobeffect) {
+        this.effects.add(mobeffect);
+        if (!this.hasColor) {
+            this.u();
+        }
+
+    }
+
+    // CraftBukkit start accessor methods
+    public void refreshEffects() {
+        if (!this.hasColor) {
+            this.getDataWatcher().set(EntityAreaEffectCloud.COLOR, PotionUtil.a((Collection) PotionUtil.a(this.potionRegistry, (Collection) this.effects))); // PAIL: rename
+        }
+    }
+
+    public String getType() {
+        return ((MinecraftKey) IRegistry.POTION.getKey(this.potionRegistry)).toString();
+    }
+
+    public void setType(String string) {
+        a(IRegistry.POTION.get(new MinecraftKey(string)));
+    }
+    // CraftBukkit end
+
+    public int getColor() {
+        return (Integer) this.getDataWatcher().get(EntityAreaEffectCloud.COLOR);
+    }
+
+    public void setColor(int i) {
+        this.hasColor = true;
+        this.getDataWatcher().set(EntityAreaEffectCloud.COLOR, i);
+    }
+
+    public ParticleParam getParticle() {
+        return (ParticleParam) this.getDataWatcher().get(EntityAreaEffectCloud.f);
+    }
+
+    public void setParticle(ParticleParam particleparam) {
+        this.getDataWatcher().set(EntityAreaEffectCloud.f, particleparam);
+    }
+
+    protected void a(boolean flag) {
+        this.getDataWatcher().set(EntityAreaEffectCloud.e, flag);
+    }
+
+    public boolean k() {
+        return (Boolean) this.getDataWatcher().get(EntityAreaEffectCloud.e);
+    }
+
+    public int getDuration() {
+        return this.duration;
+    }
+
+    public void setDuration(int i) {
+        this.duration = i;
+    }
+
+    // Spigot start - copied from below
+    @Override
+    public void inactiveTick() {
+        super.inactiveTick();
+
+        if (this.ticksLived >= this.waitTime + this.duration) {
+            this.die();
+            return;
+        }
+    }
+    // Spigot end
+
+    @Override
+    public void tick() {
+        super.tick();
+        boolean flag = this.k();
+        float f = this.getRadius();
+
+        if (this.world.isClientSide) {
+            ParticleParam particleparam = this.getParticle();
+            float f1;
+            float f2;
+            float f3;
+            int i;
+            int j;
+            int k;
+
+            if (flag) {
+                if (this.random.nextBoolean()) {
+                    for (int l = 0; l < 2; ++l) {
+                        float f4 = this.random.nextFloat() * 6.2831855F;
+
+                        f1 = MathHelper.c(this.random.nextFloat()) * 0.2F;
+                        f2 = MathHelper.cos(f4) * f1;
+                        f3 = MathHelper.sin(f4) * f1;
+                        if (particleparam.getParticle() == Particles.ENTITY_EFFECT) {
+                            int i1 = this.random.nextBoolean() ? 16777215 : this.getColor();
+
+                            i = i1 >> 16 & 255;
+                            j = i1 >> 8 & 255;
+                            k = i1 & 255;
+                            this.world.b(particleparam, this.locX() + (double) f2, this.locY(), this.locZ() + (double) f3, (double) ((float) i / 255.0F), (double) ((float) j / 255.0F), (double) ((float) k / 255.0F));
+                        } else {
+                            this.world.b(particleparam, this.locX() + (double) f2, this.locY(), this.locZ() + (double) f3, 0.0D, 0.0D, 0.0D);
+                        }
+                    }
+                }
+            } else {
+                float f5 = 3.1415927F * f * f;
+
+                for (int j1 = 0; (float) j1 < f5; ++j1) {
+                    f1 = this.random.nextFloat() * 6.2831855F;
+                    f2 = MathHelper.c(this.random.nextFloat()) * f;
+                    f3 = MathHelper.cos(f1) * f2;
+                    float f6 = MathHelper.sin(f1) * f2;
+
+                    if (particleparam.getParticle() == Particles.ENTITY_EFFECT) {
+                        i = this.getColor();
+                        j = i >> 16 & 255;
+                        k = i >> 8 & 255;
+                        int k1 = i & 255;
+
+                        this.world.b(particleparam, this.locX() + (double) f3, this.locY(), this.locZ() + (double) f6, (double) ((float) j / 255.0F), (double) ((float) k / 255.0F), (double) ((float) k1 / 255.0F));
+                    } else {
+                        this.world.b(particleparam, this.locX() + (double) f3, this.locY(), this.locZ() + (double) f6, (0.5D - this.random.nextDouble()) * 0.15D, 0.009999999776482582D, (0.5D - this.random.nextDouble()) * 0.15D);
+                    }
+                }
+            }
+        } else {
+            if (this.ticksLived >= this.waitTime + this.duration) {
+                this.ab();
+                return;
+            }
+
+            boolean flag1 = this.ticksLived < this.waitTime;
+
+            if (flag != flag1) {
+                this.a(flag1);
+            }
+
+            if (flag1) {
+                return;
+            }
+
+            if (this.radiusPerTick != 0.0F) {
+                f += this.radiusPerTick;
+                if (f < 0.5F) {
+                    this.ab();
+                    return;
+                }
+
+                this.setRadius(f);
+            }
+
+            if (this.ticksLived % 5 == 0) {
+                this.affectedEntities.entrySet().removeIf((entry) -> {
+                    return this.ticksLived >= (Integer) entry.getValue();
+                });
+                List<MobEffect> list = Lists.newArrayList();
+                Iterator iterator = this.potionRegistry.a().iterator();
+
+                while (iterator.hasNext()) {
+                    MobEffect mobeffect = (MobEffect) iterator.next();
+
+                    list.add(new MobEffect(mobeffect.getMobEffect(), mobeffect.getDuration() / 4, mobeffect.getAmplifier(), mobeffect.isAmbient(), mobeffect.isShowParticles()));
+                }
+
+                list.addAll(this.effects);
+                if (list.isEmpty()) {
+                    this.affectedEntities.clear();
+                } else {
+                    List<EntityLiving> list1 = this.world.a(EntityLiving.class, this.getBoundingBox());
+
+                    if (!list1.isEmpty()) {
+                        Iterator iterator1 = list1.iterator();
+
+                        List<LivingEntity> entities = new java.util.ArrayList<LivingEntity>(); // CraftBukkit
+                        while (iterator1.hasNext()) {
+                            EntityLiving entityliving = (EntityLiving) iterator1.next();
+
+                            if (!this.affectedEntities.containsKey(entityliving) && entityliving.eC()) {
+                                double d0 = entityliving.locX() - this.locX();
+                                double d1 = entityliving.locZ() - this.locZ();
+                                double d2 = d0 * d0 + d1 * d1;
+
+                                if (d2 <= (double) (f * f)) {
+                                    // CraftBukkit start
+                                    entities.add((LivingEntity) entityliving.getBukkitEntity());
+                                }
+                            }
+                        }
+                        org.bukkit.event.entity.AreaEffectCloudApplyEvent event = org.bukkit.craftbukkit.event.CraftEventFactory.callAreaEffectCloudApplyEvent(this, entities);
+                        if (!event.isCancelled()) {
+                            for (LivingEntity entity : event.getAffectedEntities()) {
+                                if (entity instanceof CraftLivingEntity) {
+                                    EntityLiving entityliving = ((CraftLivingEntity) entity).getHandle();
+                                    // CraftBukkit end
+                                    this.affectedEntities.put(entityliving, this.ticksLived + this.reapplicationDelay);
+                                    Iterator iterator2 = list.iterator();
+
+                                    while (iterator2.hasNext()) {
+                                        MobEffect mobeffect1 = (MobEffect) iterator2.next();
+
+                                        if (mobeffect1.getMobEffect().isInstant()) {
+                                            mobeffect1.getMobEffect().applyInstantEffect(this, this.getSource(), entityliving, mobeffect1.getAmplifier(), 0.5D);
+                                        } else {
+                                            entityliving.addEffect(new MobEffect(mobeffect1), org.bukkit.event.entity.EntityPotionEffectEvent.Cause.AREA_EFFECT_CLOUD); // CraftBukkit
+                                        }
+                                    }
+
+                                    if (this.radiusOnUse != 0.0F) {
+                                        f += this.radiusOnUse;
+                                        if (f < 0.5F) {
+                                            this.ab();
+                                            return;
+                                        }
+
+                                        this.setRadius(f);
+                                    }
+
+                                    if (this.durationOnUse != 0) {
+                                        this.duration += this.durationOnUse;
+                                        if (this.duration <= 0) {
+                                            this.ab();
+                                            return;
+                                        }
+                                    }
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+        }
+
+    }
+
+
+    public void setRadiusOnUse(float f) {
+        this.radiusOnUse = f;
+    }
+
+    public void setRadiusPerTick(float f) {
+        this.radiusPerTick = f;
+    }
+
+    public void setWaitTime(int i) {
+        this.waitTime = i;
+    }
+
+    public void setSource(@Nullable EntityLiving entityliving) {
+        this.ak = entityliving;
+        this.al = entityliving == null ? null : entityliving.getUniqueID();
+    }
+
+    @Nullable
+    public EntityLiving getSource() {
+        if (this.ak == null && this.al != null && this.world instanceof WorldServer) {
+            Entity entity = ((WorldServer) this.world).getEntity(this.al);
+
+            if (entity instanceof EntityLiving) {
+                this.ak = (EntityLiving) entity;
+            }
+        }
+
+        return this.ak;
+    }
+
+    @Override
+    protected void loadData(NBTTagCompound nbttagcompound) {
+        this.ticksLived = nbttagcompound.getInt("Age");
+        this.duration = nbttagcompound.getInt("Duration");
+        this.waitTime = nbttagcompound.getInt("WaitTime");
+        this.reapplicationDelay = nbttagcompound.getInt("ReapplicationDelay");
+        this.durationOnUse = nbttagcompound.getInt("DurationOnUse");
+        this.radiusOnUse = nbttagcompound.getFloat("RadiusOnUse");
+        this.radiusPerTick = nbttagcompound.getFloat("RadiusPerTick");
+        this.setRadius(nbttagcompound.getFloat("Radius"));
+        if (nbttagcompound.b("Owner")) {
+            this.al = nbttagcompound.a("Owner");
+        }
+
+        if (nbttagcompound.hasKeyOfType("Particle", 8)) {
+            try {
+                this.setParticle(ArgumentParticle.b(new StringReader(nbttagcompound.getString("Particle"))));
+            } catch (CommandSyntaxException commandsyntaxexception) {
+                EntityAreaEffectCloud.LOGGER.warn("Couldn't load custom particle {}", nbttagcompound.getString("Particle"), commandsyntaxexception);
+            }
+        }
+
+        if (nbttagcompound.hasKeyOfType("Color", 99)) {
+            this.setColor(nbttagcompound.getInt("Color"));
+        }
+
+        if (nbttagcompound.hasKeyOfType("Potion", 8)) {
+            this.a(PotionUtil.c(nbttagcompound));
+        }
+
+        if (nbttagcompound.hasKeyOfType("Effects", 9)) {
+            NBTTagList nbttaglist = nbttagcompound.getList("Effects", 10);
+
+            this.effects.clear();
+
+            for (int i = 0; i < nbttaglist.size(); ++i) {
+                MobEffect mobeffect = MobEffect.b(nbttaglist.getCompound(i));
+
+                if (mobeffect != null) {
+                    this.addEffect(mobeffect);
+                }
+            }
+        }
+
+    }
+
+    @Override
+    protected void saveData(NBTTagCompound nbttagcompound) {
+        nbttagcompound.setInt("Age", this.ticksLived);
+        nbttagcompound.setInt("Duration", this.duration);
+        nbttagcompound.setInt("WaitTime", this.waitTime);
+        nbttagcompound.setInt("ReapplicationDelay", this.reapplicationDelay);
+        nbttagcompound.setInt("DurationOnUse", this.durationOnUse);
+        nbttagcompound.setFloat("RadiusOnUse", this.radiusOnUse);
+        nbttagcompound.setFloat("RadiusPerTick", this.radiusPerTick);
+        nbttagcompound.setFloat("Radius", this.getRadius());
+        nbttagcompound.setString("Particle", this.getParticle().a());
+        if (this.al != null) {
+            nbttagcompound.a("Owner", this.al);
+        }
+
+        if (this.hasColor) {
+            nbttagcompound.setInt("Color", this.getColor());
+        }
+
+        if (this.potionRegistry != Potions.EMPTY) {
+            nbttagcompound.setString("Potion", IRegistry.POTION.getKey(this.potionRegistry).toString());
+        }
+
+        if (!this.effects.isEmpty()) {
+            NBTTagList nbttaglist = new NBTTagList();
+            Iterator iterator = this.effects.iterator();
+
+            while (iterator.hasNext()) {
+                MobEffect mobeffect = (MobEffect) iterator.next();
+
+                nbttaglist.add(mobeffect.a(new NBTTagCompound()));
+            }
+
+            nbttagcompound.set("Effects", nbttaglist);
+        }
+
+    }
+
+    @Override
+    public void a(DataWatcherObject<?> datawatcherobject) {
+        if (EntityAreaEffectCloud.c.equals(datawatcherobject)) {
+            this.updateSize();
+        }
+
+        super.a(datawatcherobject);
+    }
+
+    @Override
+    public EnumPistonReaction getPushReaction() {
+        return EnumPistonReaction.IGNORE;
+    }
+
+    @Override
+    public Packet<?> P() {
+        return new PacketPlayOutSpawnEntity(this);
+    }
+
+    @Override
+    public EntitySize a(EntityPose entitypose) {
+        return EntitySize.b(this.getRadius() * 2.0F, 0.5F);
+    }
+}
diff --git a/src/main/java/net/minecraft/server/EntityArrow.java b/src/main/java/net/minecraft/server/EntityArrow.java
new file mode 100644
index 00000000..debd9459
--- /dev/null
+++ b/src/main/java/net/minecraft/server/EntityArrow.java
@@ -0,0 +1,626 @@
+package net.minecraft.server;
+
+import com.google.common.collect.Lists;
+import it.unimi.dsi.fastutil.ints.IntOpenHashSet;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Iterator;
+import java.util.List;
+import javax.annotation.Nullable;
+
+// CraftBukkit start
+import org.bukkit.event.entity.EntityCombustByEntityEvent;
+import org.bukkit.event.player.PlayerPickupArrowEvent;
+// CraftBukkit end
+
+public abstract class EntityArrow extends IProjectile {
+
+    private static final DataWatcherObject<Byte> f = DataWatcher.a(EntityArrow.class, DataWatcherRegistry.a);
+    private static final DataWatcherObject<Byte> g = DataWatcher.a(EntityArrow.class, DataWatcherRegistry.a);
+    @Nullable
+    private IBlockData ab;
+    public boolean inGround;
+    protected int c;
+    public EntityArrow.PickupStatus fromPlayer;
+    public int shake;
+    public int despawnCounter;
+    private double damage;
+    public int knockbackStrength;
+    private SoundEffect af;
+    private IntOpenHashSet ag;
+    private List<Entity> ah;
+
+    // Spigot Start
+    @Override
+    public void inactiveTick()
+    {
+        if ( this.inGround )
+        {
+            this.despawnCounter += 1;
+        }
+        super.inactiveTick();
+    }
+    // Spigot End
+
+    protected EntityArrow(EntityTypes<? extends EntityArrow> entitytypes, World world) {
+        super(entitytypes, world);
+        this.fromPlayer = EntityArrow.PickupStatus.DISALLOWED;
+        this.damage = 2.0D;
+        this.af = this.h();
+    }
+
+    protected EntityArrow(EntityTypes<? extends EntityArrow> entitytypes, double d0, double d1, double d2, World world) {
+        this(entitytypes, world);
+        this.setPosition(d0, d1, d2);
+    }
+
+    protected EntityArrow(EntityTypes<? extends EntityArrow> entitytypes, EntityLiving entityliving, World world) {
+        this(entitytypes, entityliving.locX(), entityliving.getHeadY() - 0.10000000149011612D, entityliving.locZ(), world);
+        this.setShooter(entityliving);
+        if (entityliving instanceof EntityHuman) {
+            this.fromPlayer = EntityArrow.PickupStatus.ALLOWED;
+        }
+
+    }
+
+    public void a(SoundEffect soundeffect) {
+        this.af = soundeffect;
+    }
+
+    @Override
+    protected void initDatawatcher() {
+        this.datawatcher.register(EntityArrow.f, (byte) 0);
+        this.datawatcher.register(EntityArrow.g, (byte) 0);
+    }
+
+    @Override
+    public void shoot(double d0, double d1, double d2, float f, float f1) {
+        super.shoot(d0, d1, d2, f, f1);
+        this.despawnCounter = 0;
+    }
+
+    @Override
+    public void tick() {
+        super.tick();
+        boolean flag = this.s();
+        Vec3D vec3d = this.getMot();
+
+        if (this.lastPitch == 0.0F && this.lastYaw == 0.0F) {
+            float f = MathHelper.sqrt(c(vec3d));
+
+            this.yaw = (float) (MathHelper.d(vec3d.x, vec3d.z) * 57.2957763671875D);
+            this.pitch = (float) (MathHelper.d(vec3d.y, (double) f) * 57.2957763671875D);
+            this.lastYaw = this.yaw;
+            this.lastPitch = this.pitch;
+        }
+
+        BlockPosition blockposition = this.getChunkCoordinates();
+        IBlockData iblockdata = this.world.getType(blockposition);
+        Vec3D vec3d1;
+
+        if (!iblockdata.isAir() && !flag) {
+            VoxelShape voxelshape = iblockdata.getCollisionShape(this.world, blockposition);
+
+            if (!voxelshape.isEmpty()) {
+                vec3d1 = this.getPositionVector();
+                Iterator iterator = voxelshape.d().iterator();
+
+                while (iterator.hasNext()) {
+                    AxisAlignedBB axisalignedbb = (AxisAlignedBB) iterator.next();
+
+                    if (axisalignedbb.a(blockposition).d(vec3d1)) {
+                        this.inGround = true;
+                        break;
+                    }
+                }
+            }
+        }
+
+        if (this.shake > 0) {
+            --this.shake;
+        }
+
+        if (this.isInWaterOrRain()) {
+            this.extinguish();
+        }
+
+        if (this.inGround && !flag) {
+            if (this.ab != iblockdata && this.u()) {
+                this.x();
+            } else if (!this.world.isClientSide) {
+                this.g();
+            }
+
+            ++this.c;
+        } else {
+            this.c = 0;
+            Vec3D vec3d2 = this.getPositionVector();
+
+            vec3d1 = vec3d2.e(vec3d);
+            Object object = this.world.rayTrace(new RayTrace(vec3d2, vec3d1, RayTrace.BlockCollisionOption.COLLIDER, RayTrace.FluidCollisionOption.NONE, this));
+
+            if (((MovingObjectPosition) object).getType() != MovingObjectPosition.EnumMovingObjectType.MISS) {
+                vec3d1 = ((MovingObjectPosition) object).getPos();
+            }
+
+            while (!this.cW()) {
+                MovingObjectPositionEntity movingobjectpositionentity = this.a(vec3d2, vec3d1);
+
+                if (movingobjectpositionentity != null) {
+                    object = movingobjectpositionentity;
+                }
+
+                if (object != null && ((MovingObjectPosition) object).getType() == MovingObjectPosition.EnumMovingObjectType.ENTITY) {
+                    Entity entity = ((MovingObjectPositionEntity) object).getEntity();
+                    Entity entity1 = this.getShooter();
+
+                    if (entity instanceof EntityHuman && entity1 instanceof EntityHuman && !((EntityHuman) entity1).a((EntityHuman) entity)) {
+                        object = null;
+                        movingobjectpositionentity = null;
+                    }
+                }
+
+                if (object != null && !flag) {
+                    this.a((MovingObjectPosition) object);
+                    this.impulse = true;
+                }
+
+                if (movingobjectpositionentity == null || this.getPierceLevel() <= 0) {
+                    break;
+                }
+
+                object = null;
+            }
+
+            vec3d = this.getMot();
+            double d0 = vec3d.x;
+            double d1 = vec3d.y;
+            double d2 = vec3d.z;
+
+            if (this.isCritical()) {
+                for (int i = 0; i < 4; ++i) {
+                    this.world.addParticle(Particles.CRIT, this.locX() + d0 * (double) i / 4.0D, this.locY() + d1 * (double) i / 4.0D, this.locZ() + d2 * (double) i / 4.0D, -d0, -d1 + 0.2D, -d2);
+                }
+            }
+
+            double d3 = this.locX() + d0;
+            double d4 = this.locY() + d1;
+            double d5 = this.locZ() + d2;
+            float f1 = MathHelper.sqrt(c(vec3d));
+
+            if (flag) {
+                this.yaw = (float) (MathHelper.d(-d0, -d2) * 57.2957763671875D);
+            } else {
+                this.yaw = (float) (MathHelper.d(d0, d2) * 57.2957763671875D);
+            }
+
+            this.pitch = (float) (MathHelper.d(d1, (double) f1) * 57.2957763671875D);
+            this.pitch = e(this.lastPitch, this.pitch);
+            this.yaw = e(this.lastYaw, this.yaw);
+            float f2 = 0.99F;
+            float f3 = 0.05F;
+
+            if (this.isInWater()) {
+                for (int j = 0; j < 4; ++j) {
+                    float f4 = 0.25F;
+
+                    this.world.addParticle(Particles.BUBBLE, d3 - d0 * 0.25D, d4 - d1 * 0.25D, d5 - d2 * 0.25D, d0, d1, d2);
+                }
+
+                f2 = this.r();
+            }
+
+            this.setMot(vec3d.a((double) f2));
+            if (!this.isNoGravity() && !flag) {
+                Vec3D vec3d3 = this.getMot();
+
+                this.setMot(vec3d3.x, vec3d3.y - 0.05000000074505806D, vec3d3.z);
+            }
+
+            this.setPosition(d3, d4, d5);
+            this.checkBlockCollisions();
+        }
+    }
+
+    private boolean u() {
+        return this.inGround && this.world.b((new AxisAlignedBB(this.getPositionVector(), this.getPositionVector())).g(0.06D));
+    }
+
+    private void x() {
+        this.inGround = false;
+        Vec3D vec3d = this.getMot();
+
+        this.setMot(vec3d.d((double) (this.random.nextFloat() * 0.2F), (double) (this.random.nextFloat() * 0.2F), (double) (this.random.nextFloat() * 0.2F)));
+        this.despawnCounter = 0;
+    }
+
+    @Override
+    public void move(EnumMoveType enummovetype, Vec3D vec3d) {
+        super.move(enummovetype, vec3d);
+        if (enummovetype != EnumMoveType.SELF && this.u()) {
+            this.x();
+        }
+
+    }
+
+    protected void g() {
+        ++this.despawnCounter;
+        if (this.despawnCounter >= 1200) {
+            this.ab();
+        }
+
+    }
+
+    private void z() {
+        if (this.ah != null) {
+            this.ah.clear();
+        }
+
+        if (this.ag != null) {
+            this.ag.clear();
+        }
+
+    }
+
+    @Override
+    protected void a(MovingObjectPositionEntity movingobjectpositionentity) {
+        super.a(movingobjectpositionentity);
+        Entity entity = movingobjectpositionentity.getEntity();
+        float f = (float) this.getMot().f();
+        int i = MathHelper.f(MathHelper.a((double) f * this.damage, 0.0D, 2.147483647E9D));
+
+        if (this.getPierceLevel() > 0) {
+            if (this.ag == null) {
+                this.ag = new IntOpenHashSet(5);
+            }
+
+            if (this.ah == null) {
+                this.ah = Lists.newArrayListWithCapacity(5);
+            }
+
+            if (this.ag.size() >= this.getPierceLevel() + 1) {
+                this.ab();
+                return;
+            }
+
+            this.ag.add(entity.getId());
+        }
+
+        if (this.isCritical()) {
+            long j = (long) this.random.nextInt(i / 2 + 2);
+
+            i = (int) Math.min(j + (long) i, 2147483647L);
+        }
+
+        Entity entity1 = this.getShooter();
+        DamageSource damagesource;
+
+        if (entity1 == null) {
+            damagesource = DamageSource.arrow(this, this);
+        } else {
+            damagesource = DamageSource.arrow(this, entity1);
+            if (entity1 instanceof EntityLiving) {
+                ((EntityLiving) entity1).z(entity);
+            }
+        }
+
+        boolean flag = entity.getEntityType() == EntityTypes.ENDERMAN;
+        int k = entity.getFireTicks();
+
+        if (this.isBurning() && !flag) {
+            // CraftBukkit start
+            EntityCombustByEntityEvent combustEvent = new EntityCombustByEntityEvent(this.getBukkitEntity(), entity.getBukkitEntity(), 5);
+            org.bukkit.Bukkit.getPluginManager().callEvent(combustEvent);
+            if (!combustEvent.isCancelled()) {
+                entity.setOnFire(combustEvent.getDuration(), false);
+            }
+            // CraftBukkit end
+        }
+
+        if (entity.damageEntity(damagesource, (float) i)) {
+            if (flag) {
+                return;
+            }
+
+            if (entity instanceof EntityLiving) {
+                EntityLiving entityliving = (EntityLiving) entity;
+
+                if (!this.world.isClientSide && this.getPierceLevel() <= 0) {
+                    entityliving.q(entityliving.getArrowCount() + 1);
+                }
+
+                if (this.knockbackStrength > 0) {
+                    Vec3D vec3d = this.getMot().d(1.0D, 0.0D, 1.0D).d().a((double) this.knockbackStrength * 0.6D);
+
+                    if (vec3d.g() > 0.0D) {
+                        entityliving.i(vec3d.x, 0.1D, vec3d.z);
+                    }
+                }
+
+                if (!this.world.isClientSide && entity1 instanceof EntityLiving) {
+                    EnchantmentManager.a(entityliving, entity1);
+                    EnchantmentManager.b((EntityLiving) entity1, (Entity) entityliving);
+                }
+
+                this.a(entityliving);
+                if (entity1 != null && entityliving != entity1 && entityliving instanceof EntityHuman && entity1 instanceof EntityPlayer && !this.isSilent()) {
+                    ((EntityPlayer) entity1).playerConnection.sendPacket(new PacketPlayOutGameStateChange(PacketPlayOutGameStateChange.g, 0.0F));
+                }
+
+                if (!entity.isAlive() && this.ah != null) {
+                    this.ah.add(entityliving);
+                }
+
+                if (!this.world.isClientSide && entity1 instanceof EntityPlayer) {
+                    EntityPlayer entityplayer = (EntityPlayer) entity1;
+
+                    if (this.ah != null && this.isShotFromCrossbow()) {
+                        CriterionTriggers.G.a(entityplayer, (Collection) this.ah);
+                    } else if (!entity.isAlive() && this.isShotFromCrossbow()) {
+                        CriterionTriggers.G.a(entityplayer, (Collection) Arrays.asList(entity));
+                    }
+                }
+            }
+
+            this.playSound(this.af, 1.0F, 1.2F / (this.random.nextFloat() * 0.2F + 0.9F));
+            if (this.getPierceLevel() <= 0) {
+                this.ab();
+            }
+        } else {
+            entity.setFireTicks(k);
+            this.setMot(this.getMot().a(-0.1D));
+            this.yaw += 180.0F;
+            this.lastYaw += 180.0F;
+            if (!this.world.isClientSide && this.getMot().g() < 1.0E-7D) {
+                if (this.fromPlayer == EntityArrow.PickupStatus.ALLOWED) {
+                    this.a(this.getItemStack(), 0.1F);
+                }
+
+                this.ab();
+            }
+        }
+
+    }
+
+    @Override
+    protected void a(MovingObjectPositionBlock movingobjectpositionblock) {
+        this.ab = this.world.getType(movingobjectpositionblock.getBlockPosition());
+        super.a(movingobjectpositionblock);
+        Vec3D vec3d = movingobjectpositionblock.getPos().a(this.locX(), this.locY(), this.locZ());
+
+        this.setMot(vec3d);
+        Vec3D vec3d1 = vec3d.d().a(0.05000000074505806D);
+
+        this.setPositionRaw(this.locX() - vec3d1.x, this.locY() - vec3d1.y, this.locZ() - vec3d1.z);
+        this.playSound(this.getSoundHit(), 1.0F, 1.2F / (this.random.nextFloat() * 0.2F + 0.9F));
+        this.inGround = true;
+        this.shake = 7;
+        this.setCritical(false);
+        this.setPierceLevel((byte) 0);
+        this.a(SoundEffects.ARROW_HIT);
+        this.setShotFromCrossbow(false);
+        this.z();
+    }
+
+    protected SoundEffect h() {
+        return SoundEffects.ARROW_HIT;
+    }
+
+    protected final SoundEffect getSoundHit() {
+        return this.af;
+    }
+
+    protected void a(EntityLiving entityliving) {}
+
+    @Nullable
+    protected MovingObjectPositionEntity a(Vec3D vec3d, Vec3D vec3d1) {
+        return ProjectileHelper.a(this.world, this, vec3d, vec3d1, this.getBoundingBox().b(this.getMot()).g(1.0D), this::a);
+    }
+
+    @Override
+    protected boolean a(Entity entity) {
+        return super.a(entity) && (this.ag == null || !this.ag.contains(entity.getId()));
+    }
+
+    @Override
+    public void saveData(NBTTagCompound nbttagcompound) {
+        super.saveData(nbttagcompound);
+        nbttagcompound.setShort("life", (short) this.despawnCounter);
+        if (this.ab != null) {
+            nbttagcompound.set("inBlockState", GameProfileSerializer.a(this.ab));
+        }
+
+        nbttagcompound.setByte("shake", (byte) this.shake);
+        nbttagcompound.setBoolean("inGround", this.inGround);
+        nbttagcompound.setByte("pickup", (byte) this.fromPlayer.ordinal());
+        nbttagcompound.setDouble("damage", this.damage);
+        nbttagcompound.setBoolean("crit", this.isCritical());
+        nbttagcompound.setByte("PierceLevel", this.getPierceLevel());
+        nbttagcompound.setString("SoundEvent", IRegistry.SOUND_EVENT.getKey(this.af).toString());
+        nbttagcompound.setBoolean("ShotFromCrossbow", this.isShotFromCrossbow());
+    }
+
+    @Override
+    public void loadData(NBTTagCompound nbttagcompound) {
+        super.loadData(nbttagcompound);
+        this.despawnCounter = nbttagcompound.getShort("life");
+        if (nbttagcompound.hasKeyOfType("inBlockState", 10)) {
+            this.ab = GameProfileSerializer.c(nbttagcompound.getCompound("inBlockState"));
+        }
+
+        this.shake = nbttagcompound.getByte("shake") & 255;
+        this.inGround = nbttagcompound.getBoolean("inGround");
+        if (nbttagcompound.hasKeyOfType("damage", 99)) {
+            this.damage = nbttagcompound.getDouble("damage");
+        }
+
+        if (nbttagcompound.hasKeyOfType("pickup", 99)) {
+            this.fromPlayer = EntityArrow.PickupStatus.a(nbttagcompound.getByte("pickup"));
+        } else if (nbttagcompound.hasKeyOfType("player", 99)) {
+            this.fromPlayer = nbttagcompound.getBoolean("player") ? EntityArrow.PickupStatus.ALLOWED : EntityArrow.PickupStatus.DISALLOWED;
+        }
+
+        this.setCritical(nbttagcompound.getBoolean("crit"));
+        this.setPierceLevel(nbttagcompound.getByte("PierceLevel"));
+        if (nbttagcompound.hasKeyOfType("SoundEvent", 8)) {
+            this.af = (SoundEffect) IRegistry.SOUND_EVENT.getOptional(new MinecraftKey(nbttagcompound.getString("SoundEvent"))).orElse(this.h());
+        }
+
+        this.setShotFromCrossbow(nbttagcompound.getBoolean("ShotFromCrossbow"));
+    }
+
+    @Override
+    public void setShooter(@Nullable Entity entity) {
+        super.setShooter(entity);
+        if (entity instanceof EntityHuman) {
+            this.fromPlayer = ((EntityHuman) entity).eX().canInstantlyBuild ? EntityArrow.PickupStatus.CREATIVE_ONLY : EntityArrow.PickupStatus.ALLOWED;
+        }
+
+    }
+
+    @Override
+    public void pickup(EntityHuman entityhuman) {
+        if (!this.world.isClientSide && (this.inGround || this.s()) && this.shake <= 0) {
+            // CraftBukkit start
+            ItemStack itemstack = this.getItemStack();
+            if (this.fromPlayer == PickupStatus.ALLOWED && !itemstack.isEmpty() && entityhuman.inventory.canHold(itemstack) > 0) {
+                EntityItem item = new EntityItem(this.world, this.locX(), this.locY(), this.locZ(), itemstack);
+                PlayerPickupArrowEvent event = new PlayerPickupArrowEvent((org.bukkit.entity.Player) entityhuman.getBukkitEntity(), new org.bukkit.craftbukkit.entity.CraftItem(this.world.getServer(), this, item), (org.bukkit.entity.AbstractArrow) this.getBukkitEntity());
+                // event.setCancelled(!entityhuman.canPickUpLoot); TODO
+                this.world.getServer().getPluginManager().callEvent(event);
+
+                if (event.isCancelled()) {
+                    return;
+                }
+                itemstack = item.getItemStack();
+            }
+            boolean flag = this.fromPlayer == EntityArrow.PickupStatus.ALLOWED || this.fromPlayer == EntityArrow.PickupStatus.CREATIVE_ONLY && entityhuman.eX().canInstantlyBuild || this.s() && this.getShooter().getUniqueID() == entityhuman.getUniqueID();
+
+            if (this.fromPlayer == EntityArrow.PickupStatus.ALLOWED && !entityhuman.inventory.pickup(itemstack)) {
+                // CraftBukkit end
+                flag = false;
+            }
+
+            if (flag) {
+                entityhuman.receive(this, 1);
+                this.ab();
+            }
+
+        }
+    }
+
+    protected abstract ItemStack getItemStack();
+
+    @Override
+    protected boolean playStepSound() {
+        return false;
+    }
+
+    public void setDamage(double d0) {
+        this.damage = d0;
+    }
+
+    public double getDamage() {
+        return this.damage;
+    }
+
+    public void setKnockbackStrength(int i) {
+        this.knockbackStrength = i;
+    }
+
+    @Override
+    public boolean bS() {
+        return false;
+    }
+
+    @Override
+    protected float getHeadHeight(EntityPose entitypose, EntitySize entitysize) {
+        return 0.13F;
+    }
+
+    public void setCritical(boolean flag) {
+        this.a(1, flag);
+    }
+
+    public void setPierceLevel(byte b0) {
+        this.datawatcher.set(EntityArrow.g, b0);
+    }
+
+    private void a(int i, boolean flag) {
+        byte b0 = (Byte) this.datawatcher.get(EntityArrow.f);
+
+        if (flag) {
+            this.datawatcher.set(EntityArrow.f, (byte) (b0 | i));
+        } else {
+            this.datawatcher.set(EntityArrow.f, (byte) (b0 & ~i));
+        }
+
+    }
+
+    public boolean isCritical() {
+        byte b0 = (Byte) this.datawatcher.get(EntityArrow.f);
+
+        return (b0 & 1) != 0;
+    }
+
+    public boolean isShotFromCrossbow() {
+        byte b0 = (Byte) this.datawatcher.get(EntityArrow.f);
+
+        return (b0 & 4) != 0;
+    }
+
+    public byte getPierceLevel() {
+        return (Byte) this.datawatcher.get(EntityArrow.g);
+    }
+
+    public void a(EntityLiving entityliving, float f) {
+        int i = EnchantmentManager.a(Enchantments.ARROW_DAMAGE, entityliving);
+        int j = EnchantmentManager.a(Enchantments.ARROW_KNOCKBACK, entityliving);
+
+        this.setDamage((double) (f * 2.0F) + this.random.nextGaussian() * 0.25D + (double) ((float) this.world.getDifficulty().a() * 0.11F));
+        if (i > 0) {
+            this.setDamage(this.getDamage() + (double) i * 0.5D + 0.5D);
+        }
+
+        if (j > 0) {
+            this.setKnockbackStrength(j);
+        }
+
+        if (EnchantmentManager.a(Enchantments.ARROW_FIRE, entityliving) > 0) {
+            this.setOnFire(100);
+        }
+
+    }
+
+    protected float r() {
+        return 0.6F;
+    }
+
+    public void o(boolean flag) {
+        this.noclip = flag;
+        this.a(2, flag);
+    }
+
+    public boolean s() {
+        return !this.world.isClientSide ? this.noclip : ((Byte) this.datawatcher.get(EntityArrow.f) & 2) != 0;
+    }
+
+    public void setShotFromCrossbow(boolean flag) {
+        this.a(4, flag);
+    }
+
+    public static enum PickupStatus {
+
+        DISALLOWED, ALLOWED, CREATIVE_ONLY;
+
+        private PickupStatus() {}
+
+        public static EntityArrow.PickupStatus a(int i) {
+            if (i < 0 || i > values().length) {
+                i = 0;
+            }
+
+            return values()[i];
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/server/EntityFireworks.java b/src/main/java/net/minecraft/server/EntityFireworks.java
new file mode 100644
index 00000000..d2c87d02
--- /dev/null
+++ b/src/main/java/net/minecraft/server/EntityFireworks.java
@@ -0,0 +1,288 @@
+package net.minecraft.server;
+
+import org.bukkit.craftbukkit.event.CraftEventFactory;
+
+import javax.annotation.Nullable;
+import java.util.Iterator;
+import java.util.List;
+import java.util.OptionalInt;
+
+public class EntityFireworks extends IProjectile {
+
+    public static final DataWatcherObject<ItemStack> FIREWORK_ITEM = DataWatcher.a(EntityFireworks.class, DataWatcherRegistry.g);
+    private static final DataWatcherObject<OptionalInt> c = DataWatcher.a(EntityFireworks.class, DataWatcherRegistry.r);
+    public static final DataWatcherObject<Boolean> SHOT_AT_ANGLE = DataWatcher.a(EntityFireworks.class, DataWatcherRegistry.i);
+    private int ticksFlown;
+    public int expectedLifespan;
+    private EntityLiving ridingEntity;
+
+    public EntityFireworks(EntityTypes<? extends EntityFireworks> entitytypes, World world) {
+        super(entitytypes, world);
+    }
+
+    public EntityFireworks(World world, double d0, double d1, double d2, ItemStack itemstack) {
+        super(EntityTypes.FIREWORK_ROCKET, world);
+        this.ticksFlown = 0;
+        this.setPosition(d0, d1, d2);
+        int i = 1;
+
+        if (!itemstack.isEmpty() && itemstack.hasTag()) {
+            this.datawatcher.set(EntityFireworks.FIREWORK_ITEM, itemstack.cloneItemStack());
+            i += itemstack.a("Fireworks").getByte("Flight");
+        }
+
+        this.setMot(this.random.nextGaussian() * 0.001D, 0.05D, this.random.nextGaussian() * 0.001D);
+        this.expectedLifespan = 10 * i + this.random.nextInt(6) + this.random.nextInt(7);
+    }
+
+    public EntityFireworks(World world, @Nullable Entity entity, double d0, double d1, double d2, ItemStack itemstack) {
+        this(world, d0, d1, d2, itemstack);
+        this.setShooter(entity);
+    }
+
+    public EntityFireworks(World world, ItemStack itemstack, EntityLiving entityliving) {
+        this(world, entityliving, entityliving.locX(), entityliving.locY(), entityliving.locZ(), itemstack);
+        this.datawatcher.set(EntityFireworks.c, OptionalInt.of(entityliving.getId()));
+        this.ridingEntity = entityliving;
+    }
+
+    public EntityFireworks(World world, ItemStack itemstack, double d0, double d1, double d2, boolean flag) {
+        this(world, d0, d1, d2, itemstack);
+        this.datawatcher.set(EntityFireworks.SHOT_AT_ANGLE, flag);
+    }
+
+    public EntityFireworks(World world, ItemStack itemstack, Entity entity, double d0, double d1, double d2, boolean flag) {
+        this(world, itemstack, d0, d1, d2, flag);
+        this.setShooter(entity);
+    }
+
+    // Spigot Start - copied from tick
+    @Override
+    public void inactiveTick() {
+        this.ticksFlown += 1;
+
+        if (!this.world.isClientSide && this.ticksFlown > this.expectedLifespan) {
+            // CraftBukkit start
+            if (!org.bukkit.craftbukkit.event.CraftEventFactory.callFireworkExplodeEvent(this).isCancelled()) {
+                this.explode();
+            }
+            // CraftBukkit end
+        }
+        super.inactiveTick();
+    }
+    // Spigot End
+
+    @Override
+    protected void initDatawatcher() {
+        this.datawatcher.register(EntityFireworks.FIREWORK_ITEM, ItemStack.b);
+        this.datawatcher.register(EntityFireworks.c, OptionalInt.empty());
+        this.datawatcher.register(EntityFireworks.SHOT_AT_ANGLE, false);
+    }
+
+    @Override
+    public void tick() {
+        super.tick();
+        Vec3D vec3d;
+
+        if (this.n()) {
+            if (this.ridingEntity == null) {
+                ((OptionalInt) this.datawatcher.get(EntityFireworks.c)).ifPresent((i) -> {
+                    Entity entity = this.world.getEntity(i);
+
+                    if (entity instanceof EntityLiving) {
+                        this.ridingEntity = (EntityLiving) entity;
+                    }
+
+                });
+            }
+
+            if (this.ridingEntity != null) {
+                if (this.ridingEntity.isGliding()) {
+                    vec3d = this.ridingEntity.getLookDirection();
+                    double d0 = 1.5D;
+                    double d1 = 0.1D;
+                    Vec3D vec3d1 = this.ridingEntity.getMot();
+
+                    this.ridingEntity.setMot(vec3d1.add(vec3d.x * 0.1D + (vec3d.x * 1.5D - vec3d1.x) * 0.5D, vec3d.y * 0.1D + (vec3d.y * 1.5D - vec3d1.y) * 0.5D, vec3d.z * 0.1D + (vec3d.z * 1.5D - vec3d1.z) * 0.5D));
+                }
+
+                this.setPosition(this.ridingEntity.locX(), this.ridingEntity.locY(), this.ridingEntity.locZ());
+                this.setMot(this.ridingEntity.getMot());
+            }
+        } else {
+            if (!this.isShotAtAngle()) {
+                double d2 = this.positionChanged ? 1.0D : 1.15D;
+
+                this.setMot(this.getMot().d(d2, 1.0D, d2).add(0.0D, 0.04D, 0.0D));
+            }
+
+            vec3d = this.getMot();
+            this.move(EnumMoveType.SELF, vec3d);
+            this.setMot(vec3d);
+        }
+
+        MovingObjectPosition movingobjectposition = ProjectileHelper.a((Entity) this, this::a);
+
+        if (!this.noclip) {
+            this.a(movingobjectposition);
+            this.impulse = true;
+        }
+
+        this.w();
+        if (this.ticksFlown == 0 && !this.isSilent()) {
+            this.world.playSound((EntityHuman) null, this.locX(), this.locY(), this.locZ(), SoundEffects.FIREWORK_ROCKET_LAUNCH, SoundCategory.AMBIENT, 3.0F, 1.0F);
+        }
+
+        ++this.ticksFlown;
+        if (this.world.isClientSide && this.ticksFlown % 2 < 2) {
+            this.world.addParticle(Particles.FIREWORK, this.locX(), this.locY() - 0.3D, this.locZ(), this.random.nextGaussian() * 0.05D, -this.getMot().y * 0.5D, this.random.nextGaussian() * 0.05D);
+        }
+
+        if (!this.world.isClientSide && this.ticksFlown > this.expectedLifespan) {
+            // CraftBukkit start
+            if (!CraftEventFactory.callFireworkExplodeEvent(this).isCancelled()) {
+                this.explode();
+            }
+            // CraftBukkit end
+        }
+
+    }
+
+    private void explode() {
+        this.world.broadcastEntityEffect(this, (byte) 17);
+        this.a(this.getShooter(), ckz.x);
+        this.m();
+        this.ab();
+    }
+
+    @Override
+    protected void a(MovingObjectPositionEntity movingobjectpositionentity) {
+        super.a(movingobjectpositionentity);
+        if (!this.world.isClientSide) {
+            // CraftBukkit start
+            if (!CraftEventFactory.callFireworkExplodeEvent(this).isCancelled()) {
+                this.explode();
+            }
+            // CraftBukkit end
+        }
+    }
+
+    @Override
+    protected void a(MovingObjectPositionBlock movingobjectpositionblock) {
+        BlockPosition blockposition = new BlockPosition(movingobjectpositionblock.getBlockPosition());
+
+        this.world.getType(blockposition).a(this.world, blockposition, (Entity) this);
+        if (!this.world.g() && this.hasExplosions()) {
+            // CraftBukkit start
+            if (!CraftEventFactory.callFireworkExplodeEvent(this).isCancelled()) {
+                this.explode();
+            }
+            // CraftBukkit end
+        }
+
+        super.a(movingobjectpositionblock);
+    }
+
+    private boolean hasExplosions() {
+        ItemStack itemstack = (ItemStack) this.datawatcher.get(EntityFireworks.FIREWORK_ITEM);
+        NBTTagCompound nbttagcompound = itemstack.isEmpty() ? null : itemstack.b("Fireworks");
+        NBTTagList nbttaglist = nbttagcompound != null ? nbttagcompound.getList("Explosions", 10) : null;
+
+        return nbttaglist != null && !nbttaglist.isEmpty();
+    }
+
+    private void m() {
+        float f = 0.0F;
+        ItemStack itemstack = (ItemStack) this.datawatcher.get(EntityFireworks.FIREWORK_ITEM);
+        NBTTagCompound nbttagcompound = itemstack.isEmpty() ? null : itemstack.b("Fireworks");
+        NBTTagList nbttaglist = nbttagcompound != null ? nbttagcompound.getList("Explosions", 10) : null;
+
+        if (nbttaglist != null && !nbttaglist.isEmpty()) {
+            f = 5.0F + (float) (nbttaglist.size() * 2);
+        }
+
+        if (f > 0.0F) {
+            if (this.ridingEntity != null) {
+                CraftEventFactory.entityDamage = this; // CraftBukkit
+                this.ridingEntity.damageEntity(DamageSource.a(this, this.getShooter()), 5.0F + (float) (nbttaglist.size() * 2));
+                CraftEventFactory.entityDamage = null; // CraftBukkit
+            }
+
+            double d0 = 5.0D;
+            Vec3D vec3d = this.getPositionVector();
+            List<EntityLiving> list = this.world.a(EntityLiving.class, this.getBoundingBox().g(5.0D));
+            Iterator iterator = list.iterator();
+
+            while (iterator.hasNext()) {
+                EntityLiving entityliving = (EntityLiving) iterator.next();
+
+                if (entityliving != this.ridingEntity && this.h(entityliving) <= 25.0D) {
+                    boolean flag = false;
+
+                    for (int i = 0; i < 2; ++i) {
+                        Vec3D vec3d1 = new Vec3D(entityliving.locX(), entityliving.e(0.5D * (double) i), entityliving.locZ());
+                        MovingObjectPositionBlock movingobjectpositionblock = this.world.rayTrace(new RayTrace(vec3d, vec3d1, RayTrace.BlockCollisionOption.COLLIDER, RayTrace.FluidCollisionOption.NONE, this));
+
+                        if (movingobjectpositionblock.getType() == MovingObjectPosition.EnumMovingObjectType.MISS) {
+                            flag = true;
+                            break;
+                        }
+                    }
+
+                    if (flag) {
+                        float f1 = f * (float) Math.sqrt((5.0D - (double) this.g((Entity) entityliving)) / 5.0D);
+
+                        CraftEventFactory.entityDamage = this; // CraftBukkit
+                        entityliving.damageEntity(DamageSource.a(this, this.getShooter()), f1);
+                        CraftEventFactory.entityDamage = null; // CraftBukkit
+                    }
+                }
+            }
+        }
+
+    }
+
+    private boolean n() {
+        return ((OptionalInt) this.datawatcher.get(EntityFireworks.c)).isPresent();
+    }
+
+    public boolean isShotAtAngle() {
+        return (Boolean) this.datawatcher.get(EntityFireworks.SHOT_AT_ANGLE);
+    }
+
+    @Override
+    public void saveData(NBTTagCompound nbttagcompound) {
+        super.saveData(nbttagcompound);
+        nbttagcompound.setInt("Life", this.ticksFlown);
+        nbttagcompound.setInt("LifeTime", this.expectedLifespan);
+        ItemStack itemstack = (ItemStack) this.datawatcher.get(EntityFireworks.FIREWORK_ITEM);
+
+        if (!itemstack.isEmpty()) {
+            nbttagcompound.set("FireworksItem", itemstack.save(new NBTTagCompound()));
+        }
+
+        nbttagcompound.setBoolean("ShotAtAngle", (Boolean) this.datawatcher.get(EntityFireworks.SHOT_AT_ANGLE));
+    }
+
+    @Override
+    public void loadData(NBTTagCompound nbttagcompound) {
+        super.loadData(nbttagcompound);
+        this.ticksFlown = nbttagcompound.getInt("Life");
+        this.expectedLifespan = nbttagcompound.getInt("LifeTime");
+        ItemStack itemstack = ItemStack.a(nbttagcompound.getCompound("FireworksItem"));
+
+        if (!itemstack.isEmpty()) {
+            this.datawatcher.set(EntityFireworks.FIREWORK_ITEM, itemstack);
+        }
+
+        if (nbttagcompound.hasKey("ShotAtAngle")) {
+            this.datawatcher.set(EntityFireworks.SHOT_AT_ANGLE, nbttagcompound.getBoolean("ShotAtAngle"));
+        }
+
+    }
+
+    @Override
+    public boolean bS() {
+        return false;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/EntityItem.java b/src/main/java/net/minecraft/server/EntityItem.java
index a1681eab..4e7ebb00 100644
--- a/src/main/java/net/minecraft/server/EntityItem.java
+++ b/src/main/java/net/minecraft/server/EntityItem.java
@@ -39,6 +39,28 @@ public class EntityItem extends Entity {
         this.setItemStack(itemstack);
     }
 
+    // Spigot start - copied from above
+    @Override
+    public void inactiveTick() {
+        // CraftBukkit start - Use wall time for pickup and despawn timers
+        int elapsedTicks = MinecraftServer.currentTick - this.lastTick;
+        if (this.pickupDelay != 32767) this.pickupDelay -= elapsedTicks;
+        if (this.age != -32768) this.age += elapsedTicks;
+        this.lastTick = MinecraftServer.currentTick;
+        // CraftBukkit end
+
+        if (!this.world.isClientSide && this.age >= world.spigotConfig.itemDespawnRate) { // Spigot
+            // CraftBukkit start - fire ItemDespawnEvent
+            if (org.bukkit.craftbukkit.event.CraftEventFactory.callItemDespawnEvent(this).isCancelled()) {
+                this.age = 0;
+                return;
+            }
+            // CraftBukkit end
+            this.die();
+        }
+    }
+    // Spigot end
+
     @Override
     public boolean isOccludesVibrations() {
         return TagsItem.ai.isTagged(this.getItemStack().getItem());
diff --git a/src/main/java/net/minecraft/server/EntityLiving.java b/src/main/java/net/minecraft/server/EntityLiving.java
new file mode 100644
index 00000000..c1c85d18
--- /dev/null
+++ b/src/main/java/net/minecraft/server/EntityLiving.java
@@ -0,0 +1,3504 @@
+package net.minecraft.server;
+
+import com.google.common.base.Objects;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.Lists;
+import com.google.common.collect.Maps;
+import com.mojang.datafixers.util.Pair;
+import com.mojang.serialization.DataResult;
+import com.mojang.serialization.Dynamic;
+import com.mojang.serialization.DynamicOps;
+import java.util.Collection;
+import java.util.ConcurrentModificationException;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Optional;
+import java.util.Random;
+import java.util.UUID;
+import java.util.function.Predicate;
+import javax.annotation.Nullable;
+import org.apache.logging.log4j.Logger;
+
+// CraftBukkit start
+import java.util.ArrayList;
+import java.util.HashSet;
+import java.util.Set;
+import com.google.common.base.Function;
+import org.bukkit.Location;
+import org.bukkit.craftbukkit.attribute.CraftAttributeMap;
+import org.bukkit.craftbukkit.event.CraftEventFactory;
+import org.bukkit.craftbukkit.inventory.CraftItemStack;
+import org.bukkit.entity.LivingEntity;
+import org.bukkit.entity.Player;
+import org.bukkit.event.entity.ArrowBodyCountChangeEvent;
+import org.bukkit.event.entity.EntityDamageEvent;
+import org.bukkit.event.entity.EntityDamageEvent.DamageModifier;
+import org.bukkit.event.entity.EntityPotionEffectEvent;
+import org.bukkit.event.entity.EntityRegainHealthEvent;
+import org.bukkit.event.entity.EntityResurrectEvent;
+import org.bukkit.event.entity.EntityTeleportEvent;
+import org.bukkit.event.player.PlayerItemConsumeEvent;
+// CraftBukkit end
+
+import org.bukkit.craftbukkit.SpigotTimings; // Spigot
+
+public abstract class EntityLiving extends Entity {
+
+    private static final UUID b = UUID.fromString("662A6B8D-DA3E-4C1C-8813-96EA6097278D");
+    private static final UUID c = UUID.fromString("87f46a96-686f-4796-b035-22e16ee9e038");
+    private static final UUID d = UUID.fromString("1eaf83ff-7207-4596-b37a-d7a07b3ec4ce");
+    private static final AttributeModifier SPRINTING_SPEED_BOOST = new AttributeModifier(EntityLiving.b, "Sprinting speed boost", 0.30000001192092896D, AttributeModifier.Operation.MULTIPLY_TOTAL);
+    protected static final DataWatcherObject<Byte> ab = DataWatcher.a(EntityLiving.class, DataWatcherRegistry.a);
+    public static final DataWatcherObject<Float> HEALTH = DataWatcher.a(EntityLiving.class, DataWatcherRegistry.c);
+    private static final DataWatcherObject<Integer> g = DataWatcher.a(EntityLiving.class, DataWatcherRegistry.b);
+    private static final DataWatcherObject<Boolean> bc = DataWatcher.a(EntityLiving.class, DataWatcherRegistry.i);
+    private static final DataWatcherObject<Integer> bd = DataWatcher.a(EntityLiving.class, DataWatcherRegistry.b);
+    public static final DataWatcherObject<Integer> ARROWS_IN_BODY = DataWatcher.a(EntityLiving.class, DataWatcherRegistry.b);
+    private static final DataWatcherObject<Optional<BlockPosition>> bf = DataWatcher.a(EntityLiving.class, DataWatcherRegistry.m);
+    protected static final EntitySize ac = EntitySize.c(0.2F, 0.2F);
+    private final AttributeMapBase attributeMap;
+    public CombatTracker combatTracker = new CombatTracker(this);
+    public final Map<MobEffectList, MobEffect> effects = Maps.newHashMap();
+    private final NonNullList<ItemStack> bj;
+    private final NonNullList<ItemStack> bk;
+    public boolean ad;
+    public EnumHand ae;
+    public int af;
+    public int arrowCooldown;
+    public int ah;
+    public int hurtTimestamp;
+    public int hurtDuration;
+    public float ak;
+    public int deathTicks;
+    public float am;
+    public float an;
+    protected int ao;
+    public float ap;
+    public float aq;
+    public float ar;
+    public int maxNoDamageTicks;
+    public final float at;
+    public final float au;
+    public float av;
+    public float aw;
+    public float ax;
+    public float ay;
+    public float az;
+    @Nullable
+    public EntityHuman killer;
+    protected int lastDamageByPlayerTime;
+    protected boolean killed;
+    protected int ticksFarFromPlayer;
+    protected float aE;
+    protected float aF;
+    protected float aG;
+    protected float aH;
+    protected float aI;
+    protected int aJ;
+    public float lastDamage;
+    protected boolean jumping;
+    public float aM;
+    public float aN;
+    public float aO;
+    protected int aP;
+    protected double aQ;
+    protected double aR;
+    protected double aS;
+    protected double aT;
+    protected double aU;
+    protected double aV;
+    protected int aW;
+    public boolean updateEffects;
+    @Nullable
+    public EntityLiving lastDamager;
+    private int bn;
+    private EntityLiving bo;
+    private int bp;
+    private float bq;
+    private int jumpTicks;
+    private float bs;
+    protected ItemStack activeItem;
+    protected int aY;
+    protected int aZ;
+    private BlockPosition bt;
+    private Optional<BlockPosition> bu;
+    @Nullable
+    private DamageSource bv;
+    private long bw;
+    protected int ba;
+    private float bx;
+    private float by;
+    protected BehaviorController<?> bb;
+    // CraftBukkit start
+    public int expToDrop;
+    public int maxAirTicks = 300;
+    boolean forceDrops;
+    ArrayList<org.bukkit.inventory.ItemStack> drops = new ArrayList<org.bukkit.inventory.ItemStack>();
+    public final org.bukkit.craftbukkit.attribute.CraftAttributeMap craftAttributes;
+    public boolean collides = true;
+    public Set<UUID> collidableExemptions = new HashSet<>();
+    public boolean canPickUpLoot;
+
+    @Override
+    public float getBukkitYaw() {
+        return getHeadRotation();
+    }
+    // CraftBukkit end
+    // Spigot start
+    public void inactiveTick()
+    {
+        super.inactiveTick();
+        ++this.ticksFarFromPlayer; // Above all the floats
+    }
+    // Spigot end
+
+    protected EntityLiving(EntityTypes<? extends EntityLiving> entitytypes, World world) {
+        super(entitytypes, world);
+        this.bj = NonNullList.a(2, ItemStack.b);
+        this.bk = NonNullList.a(4, ItemStack.b);
+        this.maxNoDamageTicks = 20;
+        this.az = 0.02F;
+        this.updateEffects = true;
+        this.activeItem = ItemStack.b;
+        this.bu = Optional.empty();
+        this.attributeMap = new AttributeMapBase(AttributeDefaults.a(entitytypes));
+        this.craftAttributes = new CraftAttributeMap(attributeMap); // CraftBukkit
+        // CraftBukkit - setHealth(getMaxHealth()) inlined and simplified to skip the instanceof check for EntityPlayer, as getBukkitEntity() is not initialized in constructor
+        this.datawatcher.set(EntityLiving.HEALTH, (float) this.getAttributeInstance(GenericAttributes.MAX_HEALTH).getValue());
+        this.i = true;
+        this.au = (float) ((Math.random() + 1.0D) * 0.009999999776482582D);
+        this.af();
+        this.at = (float) Math.random() * 12398.0F;
+        this.yaw = (float) (Math.random() * 6.2831854820251465D);
+        this.ax = this.yaw;
+        this.E = 0.6F;
+        DynamicOpsNBT dynamicopsnbt = DynamicOpsNBT.a;
+
+        this.bb = this.a(new Dynamic(dynamicopsnbt, dynamicopsnbt.createMap((Map) ImmutableMap.of(dynamicopsnbt.createString("memories"), dynamicopsnbt.emptyMap()))));
+    }
+
+    public BehaviorController<?> getBehaviorController() {
+        return this.bb;
+    }
+
+    protected BehaviorController.b<?> dc() {
+        return BehaviorController.a((Collection) ImmutableList.of(), (Collection) ImmutableList.of());
+    }
+
+    protected BehaviorController<?> a(Dynamic<?> dynamic) {
+        return this.dc().a(dynamic);
+    }
+
+    @Override
+    public void killEntity() {
+        this.damageEntity(DamageSource.OUT_OF_WORLD, Float.MAX_VALUE);
+    }
+
+    public boolean a(EntityTypes<?> entitytypes) {
+        return true;
+    }
+
+    @Override
+    protected void initDatawatcher() {
+        this.datawatcher.register(EntityLiving.ab, (byte) 0);
+        this.datawatcher.register(EntityLiving.g, 0);
+        this.datawatcher.register(EntityLiving.bc, false);
+        this.datawatcher.register(EntityLiving.bd, 0);
+        this.datawatcher.register(EntityLiving.ARROWS_IN_BODY, 0);
+        this.datawatcher.register(EntityLiving.HEALTH, 1.0F);
+        this.datawatcher.register(EntityLiving.bf, Optional.empty());
+    }
+
+    public static AttributeProvider.Builder dd() {
+        return AttributeProvider.a().a(GenericAttributes.MAX_HEALTH).a(GenericAttributes.KNOCKBACK_RESISTANCE).a(GenericAttributes.MOVEMENT_SPEED).a(GenericAttributes.ARMOR).a(GenericAttributes.ARMOR_TOUGHNESS);
+    }
+
+    @Override
+    protected void a(double d0, boolean flag, IBlockData iblockdata, BlockPosition blockposition) {
+        if (!this.isInWater()) {
+            this.aN();
+        }
+
+        if (!this.world.isClientSide && flag && this.fallDistance > 0.0F) {
+            this.di();
+            this.dj();
+        }
+
+        if (!this.world.isClientSide && this.fallDistance > 3.0F && flag) {
+            float f = (float) MathHelper.f(this.fallDistance - 3.0F);
+
+            if (!iblockdata.isAir()) {
+                double d1 = Math.min((double) (0.2F + f / 15.0F), 2.5D);
+                int i = (int) (150.0D * d1);
+
+                // CraftBukkit start - visiblity api
+                if (this instanceof EntityPlayer) {
+                    ((WorldServer) this.world).sendParticles((EntityPlayer) this, new ParticleParamBlock(Particles.BLOCK, iblockdata), this.locX(), this.locY(), this.locZ(), i, 0.0D, 0.0D, 0.0D, 0.15000000596046448D, false);
+                } else {
+                    ((WorldServer) this.world).a(new ParticleParamBlock(Particles.BLOCK, iblockdata), this.locX(), this.locY(), this.locZ(), i, 0.0D, 0.0D, 0.0D, 0.15000000596046448D);
+                }
+                // CraftBukkit end
+            }
+        }
+
+        super.a(d0, flag, iblockdata, blockposition);
+    }
+
+    public boolean de() {
+        return this.getMonsterType() == EnumMonsterType.UNDEAD;
+    }
+
+    @Override
+    public void entityBaseTick() {
+        this.am = this.an;
+        if (this.justCreated) {
+            this.getBedPosition().ifPresent(this::a);
+        }
+
+        if (this.df()) {
+            this.dg();
+        }
+
+        super.entityBaseTick();
+        this.world.getMethodProfiler().enter("livingEntityBaseTick");
+        boolean flag = this instanceof EntityHuman;
+
+        if (this.isAlive()) {
+            if (this.inBlock()) {
+                this.damageEntity(DamageSource.STUCK, 1.0F);
+            } else if (flag && !this.world.getWorldBorder().a(this.getBoundingBox())) {
+                double d0 = this.world.getWorldBorder().a((Entity) this) + this.world.getWorldBorder().getDamageBuffer();
+
+                if (d0 < 0.0D) {
+                    double d1 = this.world.getWorldBorder().getDamageAmount();
+
+                    if (d1 > 0.0D) {
+                        this.damageEntity(DamageSource.STUCK, (float) Math.max(1, MathHelper.floor(-d0 * d1)));
+                    }
+                }
+            }
+        }
+
+        if (this.isFireProof() || this.world.isClientSide) {
+            this.extinguish();
+        }
+
+        boolean flag1 = flag && ((EntityHuman) this).eX().isInvulnerable;
+
+        if (this.isAlive()) {
+            if (this.a((Tag) TagsFluid.WATER) && !this.world.getType(new BlockPosition(this.locX(), this.getHeadY(), this.locZ())).a(Blocks.BUBBLE_COLUMN)) {
+                if (!this.de() && !MobEffectUtil.c(this) && !flag1) {
+                    this.i(this.m(this.getAirTicks()));
+                    if (this.getAirTicks() == -20) {
+                        this.i(0);
+                        Vec3D vec3d = this.getMot();
+
+                        for (int i = 0; i < 8; ++i) {
+                            double d2 = this.random.nextDouble() - this.random.nextDouble();
+                            double d3 = this.random.nextDouble() - this.random.nextDouble();
+                            double d4 = this.random.nextDouble() - this.random.nextDouble();
+
+                            this.world.addParticle(Particles.BUBBLE, this.locX() + d2, this.locY() + d3, this.locZ() + d4, vec3d.x, vec3d.y, vec3d.z);
+                        }
+
+                        this.damageEntity(DamageSource.DROWN, 2.0F);
+                    }
+                }
+
+                if (!this.world.isClientSide && this.isPassenger() && this.getVehicle() != null && !this.getVehicle().bv()) {
+                    this.stopRiding();
+                }
+            } else if (this.getAirTicks() < this.bK()) {
+                this.i(this.n(this.getAirTicks()));
+            }
+
+            if (!this.world.isClientSide) {
+                BlockPosition blockposition = this.getChunkCoordinates();
+
+                if (!Objects.equal(this.bt, blockposition)) {
+                    this.bt = blockposition;
+                    this.c(blockposition);
+                }
+            }
+        }
+
+        if (this.isAlive() && (this.aI() || this.aa)) {
+            this.extinguish();
+        }
+
+        if (this.hurtTimestamp > 0) {
+            --this.hurtTimestamp;
+        }
+
+        if (this.noDamageTicks > 0 && !(this instanceof EntityPlayer)) {
+            --this.noDamageTicks;
+        }
+
+        if (this.dG()) {
+            this.do_();
+        }
+
+        if (this.lastDamageByPlayerTime > 0) {
+            --this.lastDamageByPlayerTime;
+        } else {
+            this.killer = null;
+        }
+
+        if (this.bo != null && !this.bo.isAlive()) {
+            this.bo = null;
+        }
+
+        if (this.lastDamager != null) {
+            if (!this.lastDamager.isAlive()) {
+                this.setLastDamager((EntityLiving) null);
+            } else if (this.ticksLived - this.bn > 100) {
+                this.setLastDamager((EntityLiving) null);
+            }
+        }
+
+        this.tickPotionEffects();
+        this.aH = this.aG;
+        this.aw = this.av;
+        this.ay = this.ax;
+        this.lastYaw = this.yaw;
+        this.lastPitch = this.pitch;
+        this.world.getMethodProfiler().exit();
+    }
+
+    public boolean df() {
+        return this.ticksLived % 5 == 0 && this.getMot().x != 0.0D && this.getMot().z != 0.0D && !this.isSpectator() && EnchantmentManager.j(this) && this.dh();
+    }
+
+    protected void dg() {
+        Vec3D vec3d = this.getMot();
+
+        this.world.addParticle(Particles.SOUL, this.locX() + (this.random.nextDouble() - 0.5D) * (double) this.getWidth(), this.locY() + 0.1D, this.locZ() + (this.random.nextDouble() - 0.5D) * (double) this.getWidth(), vec3d.x * -0.2D, 0.1D, vec3d.z * -0.2D);
+        float f = this.random.nextFloat() * 0.4F + this.random.nextFloat() > 0.9F ? 0.6F : 0.0F;
+
+        this.playSound(SoundEffects.SOUL_ESCAPE, f, 0.6F + this.random.nextFloat() * 0.4F);
+    }
+
+    protected boolean dh() {
+        return this.world.getType(this.at()).a((Tag) TagsBlock.SOUL_SPEED_BLOCKS);
+    }
+
+    @Override
+    protected float getBlockSpeedFactor() {
+        return this.dh() && EnchantmentManager.a(Enchantments.SOUL_SPEED, this) > 0 ? 1.0F : super.getBlockSpeedFactor();
+    }
+
+    protected boolean b(IBlockData iblockdata) {
+        return !iblockdata.isAir() || this.isGliding();
+    }
+
+    protected void di() {
+        AttributeModifiable attributemodifiable = this.getAttributeInstance(GenericAttributes.MOVEMENT_SPEED);
+
+        if (attributemodifiable != null) {
+            if (attributemodifiable.a(EntityLiving.c) != null) {
+                attributemodifiable.b(EntityLiving.c);
+            }
+
+        }
+    }
+
+    protected void dj() {
+        if (!this.aP().isAir()) {
+            int i = EnchantmentManager.a(Enchantments.SOUL_SPEED, this);
+
+            if (i > 0 && this.dh()) {
+                AttributeModifiable attributemodifiable = this.getAttributeInstance(GenericAttributes.MOVEMENT_SPEED);
+
+                if (attributemodifiable == null) {
+                    return;
+                }
+
+                attributemodifiable.b(new AttributeModifier(EntityLiving.c, "Soul speed boost", (double) (0.03F * (1.0F + (float) i * 0.35F)), AttributeModifier.Operation.ADDITION));
+                if (this.getRandom().nextFloat() < 0.04F) {
+                    ItemStack itemstack = this.getEquipment(EnumItemSlot.FEET);
+
+                    itemstack.damage(1, this, (entityliving) -> {
+                        entityliving.broadcastItemBreak(EnumItemSlot.FEET);
+                    });
+                }
+            }
+        }
+
+    }
+
+    protected void dk() {
+        AttributeModifiable attributemodifiable = this.getAttributeInstance(GenericAttributes.MOVEMENT_SPEED);
+
+        if (attributemodifiable != null) {
+            if (attributemodifiable.a(EntityLiving.d) != null) {
+                attributemodifiable.b(EntityLiving.d);
+            }
+
+        }
+    }
+
+    protected void dl() {
+        if (!this.aP().isAir()) {
+            int i = this.bM();
+
+            if (i > 0) {
+                AttributeModifiable attributemodifiable = this.getAttributeInstance(GenericAttributes.MOVEMENT_SPEED);
+
+                if (attributemodifiable == null) {
+                    return;
+                }
+
+                float f = -0.05F * this.bN();
+
+                attributemodifiable.b(new AttributeModifier(EntityLiving.d, "Powder snow slow", (double) f, AttributeModifier.Operation.ADDITION));
+            }
+        }
+
+    }
+
+    protected void c(BlockPosition blockposition) {
+        int i = EnchantmentManager.a(Enchantments.FROST_WALKER, this);
+
+        if (i > 0) {
+            EnchantmentFrostWalker.a(this, this.world, blockposition, i);
+        }
+
+        if (this.b(this.aP())) {
+            this.di();
+        }
+
+        this.dj();
+    }
+
+    public boolean isBaby() {
+        return false;
+    }
+
+    public float dm() {
+        return this.isBaby() ? 0.5F : 1.0F;
+    }
+
+    protected boolean dn() {
+        return true;
+    }
+
+    @Override
+    public boolean bv() {
+        return false;
+    }
+
+    protected void do_() {
+        ++this.deathTicks;
+        if (this.deathTicks >= 20 && this.dead == null) { // CraftBukkit - (this.deathTicks == 20) -> (this.deathTicks >= 20 && !this.dead)
+            this.a(Entity.RemovalReason.KILLED);
+
+            for (int i = 0; i < 20; ++i) {
+                double d0 = this.random.nextGaussian() * 0.02D;
+                double d1 = this.random.nextGaussian() * 0.02D;
+                double d2 = this.random.nextGaussian() * 0.02D;
+
+                this.world.addParticle(Particles.POOF, this.d(1.0D), this.cP(), this.g(1.0D), d0, d1, d2);
+            }
+        }
+
+    }
+
+    protected boolean isDropExperience() {
+        return !this.isBaby();
+    }
+
+    protected boolean dq() {
+        return !this.isBaby();
+    }
+
+    protected int m(int i) {
+        int j = EnchantmentManager.getOxygenEnchantmentLevel(this);
+
+        return j > 0 && this.random.nextInt(j + 1) > 0 ? i : i - 1;
+    }
+
+    protected int n(int i) {
+        return Math.min(i + 4, this.bK());
+    }
+
+    protected int getExpValue(EntityHuman entityhuman) {
+        return 0;
+    }
+
+    protected boolean alwaysGivesExp() {
+        return false;
+    }
+
+    public Random getRandom() {
+        return this.random;
+    }
+
+    @Nullable
+    public EntityLiving getLastDamager() {
+        return this.lastDamager;
+    }
+
+    public int du() {
+        return this.bn;
+    }
+
+    public void e(@Nullable EntityHuman entityhuman) {
+        this.killer = entityhuman;
+        this.lastDamageByPlayerTime = this.ticksLived;
+    }
+
+    public void setLastDamager(@Nullable EntityLiving entityliving) {
+        this.lastDamager = entityliving;
+        this.bn = this.ticksLived;
+    }
+
+    @Nullable
+    public EntityLiving dv() {
+        return this.bo;
+    }
+
+    public int dw() {
+        return this.bp;
+    }
+
+    public void z(Entity entity) {
+        if (entity instanceof EntityLiving) {
+            this.bo = (EntityLiving) entity;
+        } else {
+            this.bo = null;
+        }
+
+        this.bp = this.ticksLived;
+    }
+
+    public int dx() {
+        return this.ticksFarFromPlayer;
+    }
+
+    public void o(int i) {
+        this.ticksFarFromPlayer = i;
+    }
+
+    protected void b(ItemStack itemstack) {
+        SoundEffect soundeffect = itemstack.M();
+
+        if (!itemstack.isEmpty() && soundeffect != null && !this.isSpectator()) {
+            this.playSound(soundeffect, 1.0F, 1.0F);
+        }
+    }
+
+    @Override
+    public void saveData(NBTTagCompound nbttagcompound) {
+        nbttagcompound.setFloat("Health", this.getHealth());
+        nbttagcompound.setShort("HurtTime", (short) this.hurtTimestamp);
+        nbttagcompound.setInt("HurtByTimestamp", this.bn);
+        nbttagcompound.setShort("DeathTime", (short) this.deathTicks);
+        nbttagcompound.setFloat("AbsorptionAmount", this.getAbsorptionHearts());
+        nbttagcompound.set("Attributes", this.getAttributeMap().c());
+        if (!this.effects.isEmpty()) {
+            NBTTagList nbttaglist = new NBTTagList();
+            Iterator iterator = this.effects.values().iterator();
+
+            while (iterator.hasNext()) {
+                MobEffect mobeffect = (MobEffect) iterator.next();
+
+                nbttaglist.add(mobeffect.a(new NBTTagCompound()));
+            }
+
+            nbttagcompound.set("ActiveEffects", nbttaglist);
+        }
+
+        nbttagcompound.setBoolean("FallFlying", this.isGliding());
+        this.getBedPosition().ifPresent((blockposition) -> {
+            nbttagcompound.setInt("SleepingX", blockposition.getX());
+            nbttagcompound.setInt("SleepingY", blockposition.getY());
+            nbttagcompound.setInt("SleepingZ", blockposition.getZ());
+        });
+        DataResult<NBTBase> dataresult = this.bb.a((DynamicOps) DynamicOpsNBT.a);
+        Logger logger = EntityLiving.LOGGER;
+
+        logger.getClass();
+        dataresult.resultOrPartial(logger::error).ifPresent((nbtbase) -> {
+            nbttagcompound.set("Brain", nbtbase);
+        });
+    }
+
+    @Override
+    public void loadData(NBTTagCompound nbttagcompound) {
+        this.setAbsorptionHearts(nbttagcompound.getFloat("AbsorptionAmount"));
+        if (nbttagcompound.hasKeyOfType("Attributes", 9) && this.world != null && !this.world.isClientSide) {
+            this.getAttributeMap().a(nbttagcompound.getList("Attributes", 10));
+        }
+
+        if (nbttagcompound.hasKeyOfType("ActiveEffects", 9)) {
+            NBTTagList nbttaglist = nbttagcompound.getList("ActiveEffects", 10);
+
+            for (int i = 0; i < nbttaglist.size(); ++i) {
+                NBTTagCompound nbttagcompound1 = nbttaglist.getCompound(i);
+                MobEffect mobeffect = MobEffect.b(nbttagcompound1);
+
+                if (mobeffect != null) {
+                    this.effects.put(mobeffect.getMobEffect(), mobeffect);
+                }
+            }
+        }
+
+        // CraftBukkit start
+        if (nbttagcompound.hasKey("Bukkit.MaxHealth")) {
+            NBTBase nbtbase = nbttagcompound.get("Bukkit.MaxHealth");
+            if (nbtbase.getTypeId() == 5) {
+                this.getAttributeInstance(GenericAttributes.MAX_HEALTH).setValue(((NBTTagFloat) nbtbase).asDouble());
+            } else if (nbtbase.getTypeId() == 3) {
+                this.getAttributeInstance(GenericAttributes.MAX_HEALTH).setValue(((NBTTagInt) nbtbase).asDouble());
+            }
+        }
+        // CraftBukkit end
+
+        if (nbttagcompound.hasKeyOfType("Health", 99)) {
+            this.setHealth(nbttagcompound.getFloat("Health"));
+        }
+
+        this.hurtTimestamp = nbttagcompound.getShort("HurtTime");
+        this.deathTicks = nbttagcompound.getShort("DeathTime");
+        this.bn = nbttagcompound.getInt("HurtByTimestamp");
+        if (nbttagcompound.hasKeyOfType("Team", 8)) {
+            String s = nbttagcompound.getString("Team");
+            ScoreboardTeam scoreboardteam = this.world.getScoreboard().getTeam(s);
+            boolean flag = scoreboardteam != null && this.world.getScoreboard().addPlayerToTeam(this.getUniqueIDString(), scoreboardteam);
+
+            if (!flag) {
+                EntityLiving.LOGGER.warn("Unable to add mob to team \"{}\" (that team probably doesn't exist)", s);
+            }
+        }
+
+        if (nbttagcompound.getBoolean("FallFlying")) {
+            this.setFlag(7, true);
+        }
+
+        if (nbttagcompound.hasKeyOfType("SleepingX", 99) && nbttagcompound.hasKeyOfType("SleepingY", 99) && nbttagcompound.hasKeyOfType("SleepingZ", 99)) {
+            BlockPosition blockposition = new BlockPosition(nbttagcompound.getInt("SleepingX"), nbttagcompound.getInt("SleepingY"), nbttagcompound.getInt("SleepingZ"));
+
+            this.e(blockposition);
+            this.datawatcher.set(EntityLiving.POSE, EntityPose.SLEEPING);
+            if (!this.justCreated) {
+                this.a(blockposition);
+            }
+        }
+
+        if (nbttagcompound.hasKeyOfType("Brain", 10)) {
+            this.bb = this.a(new Dynamic(DynamicOpsNBT.a, nbttagcompound.get("Brain")));
+        }
+
+    }
+
+    // CraftBukkit start
+    private boolean isTickingEffects = false;
+    private List<ProcessableEffect> effectsToProcess = Lists.newArrayList();
+
+    private static class ProcessableEffect {
+
+        private MobEffectList type;
+        private MobEffect effect;
+        private final EntityPotionEffectEvent.Cause cause;
+
+        private ProcessableEffect(MobEffect effect, EntityPotionEffectEvent.Cause cause) {
+            this.effect = effect;
+            this.cause = cause;
+        }
+
+        private ProcessableEffect(MobEffectList type, EntityPotionEffectEvent.Cause cause) {
+            this.type = type;
+            this.cause = cause;
+        }
+    }
+    // CraftBukkit end
+
+    protected void tickPotionEffects() {
+        Iterator iterator = this.effects.keySet().iterator();
+
+        isTickingEffects = true; // CraftBukkit
+        try {
+            while (iterator.hasNext()) {
+                MobEffectList mobeffectlist = (MobEffectList) iterator.next();
+                MobEffect mobeffect = (MobEffect) this.effects.get(mobeffectlist);
+
+                if (!mobeffect.tick(this, () -> {
+                    this.a(mobeffect, true);
+                })) {
+                    if (!this.world.isClientSide) {
+                        // CraftBukkit start
+                        EntityPotionEffectEvent event = CraftEventFactory.callEntityPotionEffectChangeEvent(this, mobeffect, null, org.bukkit.event.entity.EntityPotionEffectEvent.Cause.EXPIRATION);
+                        if (event.isCancelled()) {
+                            continue;
+                        }
+                        // CraftBukkit end
+                        iterator.remove();
+                        this.b(mobeffect);
+                    }
+                } else if (mobeffect.getDuration() % 600 == 0) {
+                    this.a(mobeffect, false);
+                }
+            }
+        } catch (ConcurrentModificationException concurrentmodificationexception) {
+            ;
+        }
+        // CraftBukkit start
+        isTickingEffects = false;
+        for (ProcessableEffect e : effectsToProcess) {
+            if (e.effect != null) {
+                addEffect(e.effect, e.cause);
+            } else {
+                removeEffect(e.type, e.cause);
+            }
+        }
+        effectsToProcess.clear();
+        // CraftBukkit end
+
+        if (this.updateEffects) {
+            if (!this.world.isClientSide) {
+                this.C();
+            }
+
+            this.updateEffects = false;
+        }
+
+        int i = (Integer) this.datawatcher.get(EntityLiving.g);
+        boolean flag = (Boolean) this.datawatcher.get(EntityLiving.bc);
+
+        if (i > 0) {
+            boolean flag1;
+
+            if (this.isInvisible()) {
+                flag1 = this.random.nextInt(15) == 0;
+            } else {
+                flag1 = this.random.nextBoolean();
+            }
+
+            if (flag) {
+                flag1 &= this.random.nextInt(5) == 0;
+            }
+
+            if (flag1 && i > 0) {
+                double d0 = (double) (i >> 16 & 255) / 255.0D;
+                double d1 = (double) (i >> 8 & 255) / 255.0D;
+                double d2 = (double) (i >> 0 & 255) / 255.0D;
+
+                this.world.addParticle(flag ? Particles.AMBIENT_ENTITY_EFFECT : Particles.ENTITY_EFFECT, this.d(0.5D), this.cP(), this.g(0.5D), d0, d1, d2);
+            }
+        }
+
+    }
+
+    protected void C() {
+        if (this.effects.isEmpty()) {
+            this.dA();
+            this.setInvisible(false);
+        } else {
+            Collection<MobEffect> collection = this.effects.values();
+
+            this.datawatcher.set(EntityLiving.bc, c(collection));
+            this.datawatcher.set(EntityLiving.g, PotionUtil.a(collection));
+            this.setInvisible(this.hasEffect(MobEffects.INVISIBILITY));
+        }
+
+    }
+
+    public double A(@Nullable Entity entity) {
+        double d0 = 1.0D;
+
+        if (this.bz()) {
+            d0 *= 0.8D;
+        }
+
+        if (this.isInvisible()) {
+            float f = this.ea();
+
+            if (f < 0.1F) {
+                f = 0.1F;
+            }
+
+            d0 *= 0.7D * (double) f;
+        }
+
+        if (entity != null) {
+            ItemStack itemstack = this.getEquipment(EnumItemSlot.HEAD);
+            EntityTypes<?> entitytypes = entity.getEntityType();
+
+            if (entitytypes == EntityTypes.SKELETON && itemstack.a(Items.SKELETON_SKULL) || entitytypes == EntityTypes.ZOMBIE && itemstack.a(Items.ZOMBIE_HEAD) || entitytypes == EntityTypes.CREEPER && itemstack.a(Items.CREEPER_HEAD)) {
+                d0 *= 0.5D;
+            }
+        }
+
+        return d0;
+    }
+
+    public boolean c(EntityLiving entityliving) {
+        return true;
+    }
+
+    public boolean a(EntityLiving entityliving, PathfinderTargetCondition pathfindertargetcondition) {
+        return pathfindertargetcondition.a(this, entityliving);
+    }
+
+    public boolean dz() {
+        return true;
+    }
+
+    public static boolean c(Collection<MobEffect> collection) {
+        Iterator iterator = collection.iterator();
+
+        MobEffect mobeffect;
+
+        do {
+            if (!iterator.hasNext()) {
+                return true;
+            }
+
+            mobeffect = (MobEffect) iterator.next();
+        } while (mobeffect.isAmbient());
+
+        return false;
+    }
+
+    protected void dA() {
+        this.datawatcher.set(EntityLiving.bc, false);
+        this.datawatcher.set(EntityLiving.g, 0);
+    }
+
+    // CraftBukkit start
+    public boolean removeAllEffects() {
+        return removeAllEffects(org.bukkit.event.entity.EntityPotionEffectEvent.Cause.UNKNOWN);
+    }
+
+    public boolean removeAllEffects(EntityPotionEffectEvent.Cause cause) {
+        // CraftBukkit end
+        if (this.world.isClientSide) {
+            return false;
+        } else {
+            Iterator<MobEffect> iterator = this.effects.values().iterator();
+
+            boolean flag;
+
+            for (flag = false; iterator.hasNext(); flag = true) {
+                // CraftBukkit start
+                MobEffect effect = (MobEffect) iterator.next();
+                EntityPotionEffectEvent event = CraftEventFactory.callEntityPotionEffectChangeEvent(this, effect, null, cause, EntityPotionEffectEvent.Action.CLEARED);
+                if (event.isCancelled()) {
+                    continue;
+                }
+                this.b(effect);
+                // CraftBukkit end
+                iterator.remove();
+            }
+
+            return flag;
+        }
+    }
+
+    public Collection<MobEffect> getEffects() {
+        return this.effects.values();
+    }
+
+    public Map<MobEffectList, MobEffect> dD() {
+        return this.effects;
+    }
+
+    public boolean hasEffect(MobEffectList mobeffectlist) {
+        return this.effects.containsKey(mobeffectlist);
+    }
+
+    @Nullable
+    public MobEffect getEffect(MobEffectList mobeffectlist) {
+        return (MobEffect) this.effects.get(mobeffectlist);
+    }
+
+    // CraftBukkit start
+    public boolean addEffect(MobEffect mobeffect) {
+        return addEffect(mobeffect, org.bukkit.event.entity.EntityPotionEffectEvent.Cause.UNKNOWN);
+    }
+
+    public boolean addEffect(MobEffect mobeffect, EntityPotionEffectEvent.Cause cause) {
+        org.spigotmc.AsyncCatcher.catchOp("effect add"); // Spigot
+        if (isTickingEffects) {
+            effectsToProcess.add(new ProcessableEffect(mobeffect, cause));
+            return true;
+        }
+        // CraftBukkit end
+
+        if (!this.d(mobeffect)) {
+            return false;
+        } else {
+            MobEffect mobeffect1 = (MobEffect) this.effects.get(mobeffect.getMobEffect());
+
+            // CraftBukkit start
+            boolean override = false;
+            if (mobeffect1 != null) {
+                override = new MobEffect(mobeffect1).b(mobeffect);
+            }
+
+            EntityPotionEffectEvent event = CraftEventFactory.callEntityPotionEffectChangeEvent(this, mobeffect1, mobeffect, cause, override);
+            if (event.isCancelled()) {
+                return false;
+            }
+            // CraftBukkit end
+
+            if (mobeffect1 == null) {
+                this.effects.put(mobeffect.getMobEffect(), mobeffect);
+                this.a(mobeffect);
+                return true;
+                // CraftBukkit start
+            } else if (event.isOverride()) {
+                mobeffect1.b(mobeffect);
+                this.a(mobeffect1, true);
+                // CraftBukkit end
+                return true;
+            } else {
+                return false;
+            }
+        }
+    }
+
+    public boolean d(MobEffect mobeffect) {
+        if (this.getMonsterType() == EnumMonsterType.UNDEAD) {
+            MobEffectList mobeffectlist = mobeffect.getMobEffect();
+
+            if (mobeffectlist == MobEffects.REGENERATION || mobeffectlist == MobEffects.POISON) {
+                return false;
+            }
+        }
+
+        return true;
+    }
+
+    public boolean dE() {
+        return this.getMonsterType() == EnumMonsterType.UNDEAD;
+    }
+
+    // CraftBukkit start
+    @Nullable
+    public MobEffect c(@Nullable MobEffectList mobeffectlist) {
+        return c(mobeffectlist, org.bukkit.event.entity.EntityPotionEffectEvent.Cause.UNKNOWN);
+    }
+
+    @Nullable
+    public MobEffect c(@Nullable MobEffectList mobeffectlist, EntityPotionEffectEvent.Cause cause) {
+        if (isTickingEffects) {
+            effectsToProcess.add(new ProcessableEffect(mobeffectlist, cause));
+            return null;
+        }
+
+        MobEffect effect = this.effects.get(mobeffectlist);
+        if (effect == null) {
+            return null;
+        }
+
+        EntityPotionEffectEvent event = CraftEventFactory.callEntityPotionEffectChangeEvent(this, effect, null, cause);
+        if (event.isCancelled()) {
+            return null;
+        }
+
+        return (MobEffect) this.effects.remove(mobeffectlist);
+    }
+
+    public boolean removeEffect(MobEffectList mobeffectlist) {
+        return removeEffect(mobeffectlist, org.bukkit.event.entity.EntityPotionEffectEvent.Cause.UNKNOWN);
+    }
+
+    public boolean removeEffect(MobEffectList mobeffectlist, EntityPotionEffectEvent.Cause cause) {
+        MobEffect mobeffect = this.c(mobeffectlist, cause);
+        // CraftBukkit end
+
+        if (mobeffect != null) {
+            this.b(mobeffect);
+            return true;
+        } else {
+            return false;
+        }
+    }
+
+    protected void a(MobEffect mobeffect) {
+        this.updateEffects = true;
+        if (!this.world.isClientSide) {
+            mobeffect.getMobEffect().b(this, this.getAttributeMap(), mobeffect.getAmplifier());
+        }
+
+    }
+
+    protected void a(MobEffect mobeffect, boolean flag) {
+        this.updateEffects = true;
+        if (flag && !this.world.isClientSide) {
+            MobEffectList mobeffectlist = mobeffect.getMobEffect();
+
+            mobeffectlist.a(this, this.getAttributeMap(), mobeffect.getAmplifier());
+            mobeffectlist.b(this, this.getAttributeMap(), mobeffect.getAmplifier());
+        }
+
+    }
+
+    protected void b(MobEffect mobeffect) {
+        this.updateEffects = true;
+        if (!this.world.isClientSide) {
+            mobeffect.getMobEffect().a(this, this.getAttributeMap(), mobeffect.getAmplifier());
+        }
+
+    }
+
+    // CraftBukkit start - Delegate so we can handle providing a reason for health being regained
+    public void heal(float f) {
+        heal(f, EntityRegainHealthEvent.RegainReason.CUSTOM);
+    }
+
+    public void heal(float f, EntityRegainHealthEvent.RegainReason regainReason) {
+        float f1 = this.getHealth();
+
+        if (f1 > 0.0F) {
+            EntityRegainHealthEvent event = new EntityRegainHealthEvent(this.getBukkitEntity(), f, regainReason);
+            // Suppress during worldgen
+            if (this.valid) {
+                this.world.getServer().getPluginManager().callEvent(event);
+            }
+
+            if (!event.isCancelled()) {
+                this.setHealth((float) (this.getHealth() + event.getAmount()));
+            }
+            // CraftBukkit end
+        }
+
+    }
+
+    public float getHealth() {
+        // CraftBukkit start - Use unscaled health
+        if (this instanceof EntityPlayer) {
+            return (float) ((EntityPlayer) this).getBukkitEntity().getHealth();
+        }
+        // CraftBukkit end
+        return (Float) this.datawatcher.get(EntityLiving.HEALTH);
+    }
+
+    public void setHealth(float f) {
+        // CraftBukkit start - Handle scaled health
+        if (this instanceof EntityPlayer) {
+            org.bukkit.craftbukkit.entity.CraftPlayer player = ((EntityPlayer) this).getBukkitEntity();
+            // Squeeze
+            if (f < 0.0F) {
+                player.setRealHealth(0.0D);
+            } else if (f > player.getMaxHealth()) {
+                player.setRealHealth(player.getMaxHealth());
+            } else {
+                player.setRealHealth(f);
+            }
+
+            player.updateScaledHealth(false);
+            return;
+        }
+        // CraftBukkit end
+        this.datawatcher.set(EntityLiving.HEALTH, MathHelper.a(f, 0.0F, this.getMaxHealth()));
+    }
+
+    public boolean dG() {
+        return this.getHealth() <= 0.0F;
+    }
+
+    @Override
+    public boolean damageEntity(DamageSource damagesource, float f) {
+        if (this.isInvulnerable(damagesource)) {
+            return false;
+        } else if (this.world.isClientSide) {
+            return false;
+        } else if (this.dead != null || this.killed || this.getHealth() <= 0.0F) { // CraftBukkit - Don't allow entities that got set to dead/killed elsewhere to get damaged and die
+            return false;
+        } else if (damagesource.isFire() && this.hasEffect(MobEffects.FIRE_RESISTANCE)) {
+            return false;
+        } else {
+            if (this.isSleeping() && !this.world.isClientSide) {
+                this.entityWakeup();
+            }
+
+            this.ticksFarFromPlayer = 0;
+            float f1 = f;
+
+            // CraftBukkit - Moved into damageEntity0(DamageSource, float)
+            if (false && damagesource.isDamageHelmet() && !this.getEquipment(EnumItemSlot.HEAD).isEmpty()) {
+                this.getEquipment(EnumItemSlot.HEAD).damage((int) (f * 4.0F + this.random.nextFloat() * f * 2.0F), this, (entityliving) -> {
+                    entityliving.broadcastItemBreak(EnumItemSlot.HEAD);
+                });
+                f *= 0.75F;
+            }
+
+            boolean flag = f > 0.0F && this.applyBlockingModifier(damagesource); // Copied from below
+            float f2 = 0.0F;
+
+            // CraftBukkit - Moved into damageEntity0(DamageSource, float)
+            if (false && f > 0.0F && this.applyBlockingModifier(damagesource)) {
+                this.damageShield(f);
+                f2 = f;
+                f = 0.0F;
+                if (!damagesource.b()) {
+                    Entity entity = damagesource.k();
+
+                    if (entity instanceof EntityLiving) {
+                        this.shieldBlock((EntityLiving) entity);
+                    }
+                }
+
+                flag = true;
+            }
+
+            this.aq = 1.5F;
+            boolean flag1 = true;
+
+            if ((float) this.noDamageTicks > 10.0F) {
+                if (f <= this.lastDamage) {
+                    this.forceExplosionKnockback = true; // CraftBukkit - SPIGOT-949 - for vanilla consistency, cooldown does not prevent explosion knockback
+                    return false;
+                }
+
+                // CraftBukkit start
+                if (!this.damageEntity0(damagesource, f - this.lastDamage)) {
+                    return false;
+                }
+                // CraftBukkit end
+                this.lastDamage = f;
+                flag1 = false;
+            } else {
+                // CraftBukkit start
+                if (!this.damageEntity0(damagesource, f)) {
+                    return false;
+                }
+                this.lastDamage = f;
+                this.noDamageTicks = 20;
+                // this.damageEntity0(damagesource, f);
+                // CraftBukkit end
+                this.hurtDuration = 10;
+                this.hurtTimestamp = this.hurtDuration;
+            }
+
+            // CraftBukkit start
+            if (this instanceof EntityAnimal) {
+                ((EntityAnimal) this).resetLove();
+                if (this instanceof EntityTameableAnimal) {
+                    ((EntityTameableAnimal) this).setWillSit(false);
+                }
+            }
+            // CraftBukkit end
+
+            this.ak = 0.0F;
+            Entity entity1 = damagesource.getEntity();
+
+            if (entity1 != null) {
+                if (entity1 instanceof EntityLiving) {
+                    this.setLastDamager((EntityLiving) entity1);
+                }
+
+                if (entity1 instanceof EntityHuman) {
+                    this.lastDamageByPlayerTime = 100;
+                    this.killer = (EntityHuman) entity1;
+                } else if (entity1 instanceof EntityWolf) {
+                    EntityWolf entitywolf = (EntityWolf) entity1;
+
+                    if (entitywolf.isTamed()) {
+                        this.lastDamageByPlayerTime = 100;
+                        EntityLiving entityliving = entitywolf.getOwner();
+
+                        if (entityliving != null && entityliving.getEntityType() == EntityTypes.PLAYER) {
+                            this.killer = (EntityHuman) entityliving;
+                        } else {
+                            this.killer = null;
+                        }
+                    }
+                }
+            }
+
+            if (flag1) {
+                if (flag) {
+                    this.world.broadcastEntityEffect(this, (byte) 29);
+                } else if (damagesource instanceof EntityDamageSource && ((EntityDamageSource) damagesource).A()) {
+                    this.world.broadcastEntityEffect(this, (byte) 33);
+                } else {
+                    byte b0;
+
+                    if (damagesource == DamageSource.DROWN) {
+                        b0 = 36;
+                    } else if (damagesource.isFire()) {
+                        b0 = 37;
+                    } else if (damagesource == DamageSource.SWEET_BERRY_BUSH) {
+                        b0 = 44;
+                    } else if (damagesource == DamageSource.FREEZE) {
+                        b0 = 57;
+                    } else {
+                        b0 = 2;
+                    }
+
+                    this.world.broadcastEntityEffect(this, b0);
+                }
+
+                if (damagesource != DamageSource.DROWN && (!flag || f > 0.0F)) {
+                    this.velocityChanged();
+                }
+
+                if (entity1 != null) {
+                    double d0 = entity1.locX() - this.locX();
+
+                    double d1;
+
+                    for (d1 = entity1.locZ() - this.locZ(); d0 * d0 + d1 * d1 < 1.0E-4D; d1 = (Math.random() - Math.random()) * 0.01D) {
+                        d0 = (Math.random() - Math.random()) * 0.01D;
+                    }
+
+                    this.ak = (float) (MathHelper.d(d1, d0) * 57.2957763671875D - (double) this.yaw);
+                    this.a(0.4F, d0, d1);
+                } else {
+                    this.ak = (float) ((int) (Math.random() * 2.0D) * 180);
+                }
+            }
+
+            if (this.dG()) {
+                if (!this.f(damagesource)) {
+                    SoundEffect soundeffect = this.getSoundDeath();
+
+                    if (flag1 && soundeffect != null) {
+                        this.playSound(soundeffect, this.getSoundVolume(), this.ec());
+                    }
+
+                    this.die(damagesource);
+                }
+            } else if (flag1) {
+                this.c(damagesource);
+            }
+
+            boolean flag2 = !flag || f > 0.0F;
+
+            if (flag2) {
+                this.bv = damagesource;
+                this.bw = this.world.getTime();
+            }
+
+            if (this instanceof EntityPlayer) {
+                CriterionTriggers.h.a((EntityPlayer) this, damagesource, f1, f, flag);
+                if (f2 > 0.0F && f2 < 3.4028235E37F) {
+                    ((EntityPlayer) this).a(StatisticList.DAMAGE_BLOCKED_BY_SHIELD, Math.round(f2 * 10.0F));
+                }
+            }
+
+            if (entity1 instanceof EntityPlayer) {
+                CriterionTriggers.g.a((EntityPlayer) entity1, this, damagesource, f1, f, flag);
+            }
+
+            this.a(damagesource.getEntity(), ckz.i);
+            return flag2;
+        }
+    }
+
+    protected void shieldBlock(EntityLiving entityliving) {
+        entityliving.e(this);
+    }
+
+    protected void e(EntityLiving entityliving) {
+        entityliving.a(0.5F, entityliving.locX() - this.locX(), entityliving.locZ() - this.locZ());
+    }
+
+    private boolean f(DamageSource damagesource) {
+        if (damagesource.ignoresInvulnerability()) {
+            return false;
+        } else {
+            ItemStack itemstack = null;
+            EnumHand[] aenumhand = EnumHand.values();
+            int i = aenumhand.length;
+
+            // CraftBukkit start
+            ItemStack itemstack1 = ItemStack.b;
+            for (int j = 0; j < i; ++j) {
+                EnumHand enumhand = aenumhand[j];
+                itemstack1 = this.b(enumhand);
+
+                if (itemstack1.a(Items.TOTEM_OF_UNDYING)) {
+                    itemstack = itemstack1.cloneItemStack();
+                    // itemstack1.subtract(1); // CraftBukkit
+                    break;
+                }
+            }
+
+            EntityResurrectEvent event = new EntityResurrectEvent((LivingEntity) this.getBukkitEntity());
+            event.setCancelled(itemstack == null);
+            this.world.getServer().getPluginManager().callEvent(event);
+
+            if (!event.isCancelled()) {
+                if (!itemstack1.isEmpty()) {
+                    itemstack1.subtract(1);
+                }
+                if (itemstack != null && this instanceof EntityPlayer) {
+                    // CraftBukkit end
+                    EntityPlayer entityplayer = (EntityPlayer) this;
+
+                    entityplayer.b(StatisticList.ITEM_USED.b(Items.TOTEM_OF_UNDYING));
+                    CriterionTriggers.B.a(entityplayer, itemstack);
+                }
+
+                this.setHealth(1.0F);
+                // CraftBukkit start
+                this.removeAllEffects(org.bukkit.event.entity.EntityPotionEffectEvent.Cause.TOTEM);
+                this.addEffect(new MobEffect(MobEffects.REGENERATION, 900, 1), org.bukkit.event.entity.EntityPotionEffectEvent.Cause.TOTEM);
+                this.addEffect(new MobEffect(MobEffects.ABSORBTION, 100, 1), org.bukkit.event.entity.EntityPotionEffectEvent.Cause.TOTEM);
+                this.addEffect(new MobEffect(MobEffects.FIRE_RESISTANCE, 800, 0), org.bukkit.event.entity.EntityPotionEffectEvent.Cause.TOTEM);
+                // CraftBukkit end
+                this.world.broadcastEntityEffect(this, (byte) 35);
+            }
+
+            return !event.isCancelled();
+        }
+    }
+
+    @Nullable
+    public DamageSource dH() {
+        if (this.world.getTime() - this.bw > 40L) {
+            this.bv = null;
+        }
+
+        return this.bv;
+    }
+
+    protected void c(DamageSource damagesource) {
+        SoundEffect soundeffect = this.getSoundHurt(damagesource);
+
+        if (soundeffect != null) {
+            this.playSound(soundeffect, this.getSoundVolume(), this.ec());
+        }
+
+    }
+
+    private boolean applyBlockingModifier(DamageSource damagesource) {
+        Entity entity = damagesource.k();
+        boolean flag = false;
+
+        if (entity instanceof EntityArrow) {
+            EntityArrow entityarrow = (EntityArrow) entity;
+
+            if (entityarrow.getPierceLevel() > 0) {
+                flag = true;
+            }
+        }
+
+        if (!damagesource.ignoresArmor() && this.isBlocking() && !flag) {
+            Vec3D vec3d = damagesource.y();
+
+            if (vec3d != null) {
+                Vec3D vec3d1 = this.f(1.0F);
+                Vec3D vec3d2 = vec3d.a(this.getPositionVector()).d();
+
+                vec3d2 = new Vec3D(vec3d2.x, 0.0D, vec3d2.z);
+                if (vec3d2.b(vec3d1) < 0.0D) {
+                    return true;
+                }
+            }
+        }
+
+        return false;
+    }
+
+    public void die(DamageSource damagesource) {
+        if (!this.cW() && !this.killed) {
+            Entity entity = damagesource.getEntity();
+            EntityLiving entityliving = this.getKillingEntity();
+
+            if (this.aJ >= 0 && entityliving != null) {
+                entityliving.a(this, this.aJ, damagesource);
+            }
+
+            if (this.isSleeping()) {
+                this.entityWakeup();
+            }
+
+            this.killed = true;
+            this.getCombatTracker().g();
+            if (this.world instanceof WorldServer) {
+                if (entity != null) {
+                    entity.a((WorldServer) this.world, this);
+                }
+
+                this.d(damagesource);
+                this.f(entityliving);
+            }
+
+            this.world.broadcastEntityEffect(this, (byte) 3);
+            this.setPose(EntityPose.DYING);
+        }
+    }
+
+    protected void f(@Nullable EntityLiving entityliving) {
+        if (!this.world.isClientSide) {
+            boolean flag = false;
+
+            if (entityliving instanceof EntityWither) {
+                if (this.world.getGameRules().getBoolean(GameRules.MOB_GRIEFING)) {
+                    BlockPosition blockposition = this.getChunkCoordinates();
+                    IBlockData iblockdata = Blocks.WITHER_ROSE.getBlockData();
+
+                    if (this.world.getType(blockposition).isAir() && iblockdata.canPlace(this.world, blockposition)) {
+                        this.world.setTypeAndData(blockposition, iblockdata, 3);
+                        flag = true;
+                    }
+                }
+
+                if (!flag) {
+                    EntityItem entityitem = new EntityItem(this.world, this.locX(), this.locY(), this.locZ(), new ItemStack(Items.bx));
+
+                    this.world.addEntity(entityitem);
+                }
+            }
+
+        }
+    }
+
+    protected void d(DamageSource damagesource) {
+        Entity entity = damagesource.getEntity();
+        int i;
+
+        if (entity instanceof EntityHuman) {
+            i = EnchantmentManager.g((EntityLiving) entity);
+        } else {
+            i = 0;
+        }
+
+        boolean flag = this.lastDamageByPlayerTime > 0;
+
+        this.dropInventory(); // CraftBukkit - from below
+        if (/*this.isHandRaised() && */this.world.getGameRules().getBoolean(GameRules.DO_MOB_LOOT)) {
+            this.a(damagesource, flag);
+            this.dropDeathLoot(damagesource, i, flag);
+        }
+        // CraftBukkit start - Call death event
+        CraftEventFactory.callEntityDeathEvent(this, this.drops);
+        this.drops = new ArrayList<>();
+        // CraftBukkit end
+
+        // this.dropInventory(); // CraftBukkit - moved up
+        this.dropExperience();
+    }
+
+    protected void dropInventory() {}
+
+    // CraftBukkit start
+    public int getExpReward() {
+        if (this.world instanceof WorldServer && (this.alwaysGivesExp() || this.lastDamageByPlayerTime > 0 && this.isDropExperience() && this.world.getGameRules().getBoolean(GameRules.DO_MOB_LOOT))) {
+            return this.getExpValue(this.killer);
+        } else {
+            return 0;
+        }
+    }
+    // CraftBukkit end
+
+    protected void dropExperience() {
+        // CraftBukkit start - Update getExpReward() above if the removed if() changes!
+        if (true) {
+            int i = this.expToDrop;
+            while (i > 0) {
+                int j = EntityExperienceOrb.getOrbValue(i);
+
+                i -= j;
+                this.world.addEntity(new EntityExperienceOrb(this.world, this.locX(), this.locY(), this.locZ(), j));
+            }
+            this.expToDrop = 0;
+        }
+        // CraftBukkit end
+    }
+
+    protected void dropDeathLoot(DamageSource damagesource, int i, boolean flag) {}
+
+    public MinecraftKey dK() {
+        return this.getEntityType().j();
+    }
+
+    protected void a(DamageSource damagesource, boolean flag) {
+        MinecraftKey minecraftkey = this.dK();
+        LootTable loottable = this.world.getMinecraftServer().getLootTableRegistry().getLootTable(minecraftkey);
+        LootTableInfo.Builder loottableinfo_builder = this.a(flag, damagesource);
+
+        loottable.populateLoot(loottableinfo_builder.build(LootContextParameterSets.ENTITY), this::a);
+    }
+
+    protected LootTableInfo.Builder a(boolean flag, DamageSource damagesource) {
+        LootTableInfo.Builder loottableinfo_builder = (new LootTableInfo.Builder((WorldServer) this.world)).a(this.random).set(LootContextParameters.THIS_ENTITY, this).set(LootContextParameters.ORIGIN, this.getPositionVector()).set(LootContextParameters.DAMAGE_SOURCE, damagesource).setOptional(LootContextParameters.KILLER_ENTITY, damagesource.getEntity()).setOptional(LootContextParameters.DIRECT_KILLER_ENTITY, damagesource.k());
+
+        if (flag && this.killer != null) {
+            loottableinfo_builder = loottableinfo_builder.set(LootContextParameters.LAST_DAMAGE_PLAYER, this.killer).a(this.killer.fr());
+        }
+
+        return loottableinfo_builder;
+    }
+
+    public void a(float f, double d0, double d1) {
+        f = (float) ((double) f * (1.0D - this.b(GenericAttributes.KNOCKBACK_RESISTANCE)));
+        if (f > 0.0F) {
+            this.impulse = true;
+            Vec3D vec3d = this.getMot();
+            Vec3D vec3d1 = (new Vec3D(d0, 0.0D, d1)).d().a((double) f);
+
+            this.setMot(vec3d.x / 2.0D - vec3d1.x, this.onGround ? Math.min(0.4D, vec3d.y / 2.0D + (double) f) : vec3d.y, vec3d.z / 2.0D - vec3d1.z);
+        }
+    }
+
+    @Nullable
+    protected SoundEffect getSoundHurt(DamageSource damagesource) {
+        return SoundEffects.GENERIC_HURT;
+    }
+
+    @Nullable
+    protected SoundEffect getSoundDeath() {
+        return SoundEffects.GENERIC_DEATH;
+    }
+
+    protected SoundEffect getSoundFall(int i) {
+        return i > 4 ? SoundEffects.GENERIC_BIG_FALL : SoundEffects.GENERIC_SMALL_FALL;
+    }
+
+    protected SoundEffect c(ItemStack itemstack) {
+        return itemstack.K();
+    }
+
+    public SoundEffect d(ItemStack itemstack) {
+        return itemstack.L();
+    }
+
+    @Override
+    public void setOnGround(boolean flag) {
+        super.setOnGround(flag);
+        if (flag) {
+            this.bu = Optional.empty();
+        }
+
+    }
+
+    public Optional<BlockPosition> dM() {
+        return this.bu;
+    }
+
+    public boolean isClimbing() {
+        if (this.isSpectator()) {
+            return false;
+        } else {
+            BlockPosition blockposition = this.getChunkCoordinates();
+            IBlockData iblockdata = this.dN();
+
+            if (iblockdata.a((Tag) TagsBlock.CLIMBABLE)) {
+                this.bu = Optional.of(blockposition);
+                return true;
+            } else if (iblockdata.getBlock() instanceof BlockTrapdoor && this.c(blockposition, iblockdata)) {
+                this.bu = Optional.of(blockposition);
+                return true;
+            } else {
+                return false;
+            }
+        }
+    }
+
+    public IBlockData dN() {
+        return this.world.getType(this.getChunkCoordinates());
+    }
+
+    private boolean c(BlockPosition blockposition, IBlockData iblockdata) {
+        if ((Boolean) iblockdata.get(BlockTrapdoor.OPEN)) {
+            IBlockData iblockdata1 = this.world.getType(blockposition.down());
+
+            if (iblockdata1.a(Blocks.LADDER) && iblockdata1.get(BlockLadder.FACING) == iblockdata.get(BlockTrapdoor.FACING)) {
+                return true;
+            }
+        }
+
+        return false;
+    }
+
+    @Override
+    public boolean isAlive() {
+        return !this.cW() && this.getHealth() > 0.0F;
+    }
+
+    @Override
+    public boolean b(float f, float f1) {
+        boolean flag = super.b(f, f1);
+        int i = this.e(f, f1);
+
+        if (i > 0) {
+            // CraftBukkit start
+            if (!this.damageEntity(DamageSource.FALL, (float) i)) {
+                return true;
+            }
+            // CraftBukkit end
+            this.playSound(this.getSoundFall(i), 1.0F, 1.0F);
+            this.playBlockStepSound();
+            // this.damageEntity(DamageSource.FALL, (float) i); // CraftBukkit - moved up
+            return true;
+        } else {
+            return flag;
+        }
+    }
+
+    protected int e(float f, float f1) {
+        MobEffect mobeffect = this.getEffect(MobEffects.JUMP);
+        float f2 = mobeffect == null ? 0.0F : (float) (mobeffect.getAmplifier() + 1);
+
+        return MathHelper.f((f - 3.0F - f2) * f1);
+    }
+
+    protected void playBlockStepSound() {
+        if (!this.isSilent()) {
+            int i = MathHelper.floor(this.locX());
+            int j = MathHelper.floor(this.locY() - 0.20000000298023224D);
+            int k = MathHelper.floor(this.locZ());
+            IBlockData iblockdata = this.world.getType(new BlockPosition(i, j, k));
+
+            if (!iblockdata.isAir()) {
+                SoundEffectType soundeffecttype = iblockdata.getStepSound();
+
+                this.playSound(soundeffecttype.g(), soundeffecttype.a() * 0.5F, soundeffecttype.b() * 0.75F);
+            }
+
+        }
+    }
+
+    public int getArmorStrength() {
+        return MathHelper.floor(this.b(GenericAttributes.ARMOR));
+    }
+
+    protected void damageArmor(DamageSource damagesource, float f) {}
+
+    protected void damageShield(float f) {}
+
+    protected float applyArmorModifier(DamageSource damagesource, float f) {
+        if (!damagesource.ignoresArmor()) {
+            // this.damageArmor(damagesource, f); // CraftBukkit - Moved into damageEntity0(DamageSource, float)
+            f = CombatMath.a(f, (float) this.getArmorStrength(), (float) this.b(GenericAttributes.ARMOR_TOUGHNESS));
+        }
+
+        return f;
+    }
+
+    protected float applyMagicModifier(DamageSource damagesource, float f) {
+        if (damagesource.isStarvation()) {
+            return f;
+        } else {
+            int i;
+
+            // CraftBukkit - Moved to damageEntity0(DamageSource, float)
+            if (false && this.hasEffect(MobEffects.RESISTANCE) && damagesource != DamageSource.OUT_OF_WORLD) {
+                i = (this.getEffect(MobEffects.RESISTANCE).getAmplifier() + 1) * 5;
+                int j = 25 - i;
+                float f1 = f * (float) j;
+                float f2 = f;
+
+                f = Math.max(f1 / 25.0F, 0.0F);
+                float f3 = f2 - f;
+
+                if (f3 > 0.0F && f3 < 3.4028235E37F) {
+                    if (this instanceof EntityPlayer) {
+                        ((EntityPlayer) this).a(StatisticList.DAMAGE_RESISTED, Math.round(f3 * 10.0F));
+                    } else if (damagesource.getEntity() instanceof EntityPlayer) {
+                        ((EntityPlayer) damagesource.getEntity()).a(StatisticList.DAMAGE_DEALT_RESISTED, Math.round(f3 * 10.0F));
+                    }
+                }
+            }
+
+            if (f <= 0.0F) {
+                return 0.0F;
+            } else {
+                i = EnchantmentManager.a(this.getArmorItems(), damagesource);
+                if (i > 0) {
+                    f = CombatMath.a(f, (float) i);
+                }
+
+                return f;
+            }
+        }
+    }
+
+    // CraftBukkit start
+    protected boolean damageEntity0(final DamageSource damagesource, float f) { // void -> boolean, add final
+        if (!this.isInvulnerable(damagesource)) {
+            final boolean human = this instanceof EntityHuman;
+            float originalDamage = f;
+            Function<Double, Double> hardHat = new Function<Double, Double>() {
+                @Override
+                public Double apply(Double f) {
+                    if ((damagesource == DamageSource.ANVIL || damagesource == DamageSource.FALLING_BLOCK) && !EntityLiving.this.getEquipment(EnumItemSlot.HEAD).isEmpty()) {
+                        return -(f - (f * 0.75F));
+
+                    }
+                    return -0.0;
+                }
+            };
+            float hardHatModifier = hardHat.apply((double) f).floatValue();
+            f += hardHatModifier;
+
+            Function<Double, Double> blocking = new Function<Double, Double>() {
+                @Override
+                public Double apply(Double f) {
+                    return -((EntityLiving.this.applyBlockingModifier(damagesource)) ? f : 0.0);
+                }
+            };
+            float blockingModifier = blocking.apply((double) f).floatValue();
+            f += blockingModifier;
+
+            Function<Double, Double> armor = new Function<Double, Double>() {
+                @Override
+                public Double apply(Double f) {
+                    return -(f - EntityLiving.this.applyArmorModifier(damagesource, f.floatValue()));
+                }
+            };
+            float armorModifier = armor.apply((double) f).floatValue();
+            f += armorModifier;
+
+            Function<Double, Double> resistance = new Function<Double, Double>() {
+                @Override
+                public Double apply(Double f) {
+                    if (!damagesource.isStarvation() && EntityLiving.this.hasEffect(MobEffects.RESISTANCE) && damagesource != DamageSource.OUT_OF_WORLD) {
+                        int i = (EntityLiving.this.getEffect(MobEffects.RESISTANCE).getAmplifier() + 1) * 5;
+                        int j = 25 - i;
+                        float f1 = f.floatValue() * (float) j;
+                        return -(f - (f1 / 25.0F));
+                    }
+                    return -0.0;
+                }
+            };
+            float resistanceModifier = resistance.apply((double) f).floatValue();
+            f += resistanceModifier;
+
+            Function<Double, Double> magic = new Function<Double, Double>() {
+                @Override
+                public Double apply(Double f) {
+                    return -(f - EntityLiving.this.applyMagicModifier(damagesource, f.floatValue()));
+                }
+            };
+            float magicModifier = magic.apply((double) f).floatValue();
+            f += magicModifier;
+
+            Function<Double, Double> absorption = new Function<Double, Double>() {
+                @Override
+                public Double apply(Double f) {
+                    return -(Math.max(f - Math.max(f - EntityLiving.this.getAbsorptionHearts(), 0.0F), 0.0F));
+                }
+            };
+            float absorptionModifier = absorption.apply((double) f).floatValue();
+
+            EntityDamageEvent event = CraftEventFactory.handleLivingEntityDamageEvent(this, damagesource, originalDamage, hardHatModifier, blockingModifier, armorModifier, resistanceModifier, magicModifier, absorptionModifier, hardHat, blocking, armor, resistance, magic, absorption);
+            if (damagesource.getEntity() instanceof EntityHuman) {
+                ((EntityHuman) damagesource.getEntity()).resetAttackCooldown(); // Moved from EntityHuman in order to make the cooldown reset get called after the damage event is fired
+            }
+            if (event.isCancelled()) {
+                return false;
+            }
+
+            f = (float) event.getFinalDamage();
+
+            // Resistance
+            if (event.getDamage(DamageModifier.RESISTANCE) < 0) {
+                float f3 = (float) -event.getDamage(DamageModifier.RESISTANCE);
+                if (f3 > 0.0F && f3 < 3.4028235E37F) {
+                    if (this instanceof EntityPlayer) {
+                        ((EntityPlayer) this).a(StatisticList.DAMAGE_RESISTED, Math.round(f3 * 10.0F));
+                    } else if (damagesource.getEntity() instanceof EntityPlayer) {
+                        ((EntityPlayer) damagesource.getEntity()).a(StatisticList.DAMAGE_DEALT_RESISTED, Math.round(f3 * 10.0F));
+                    }
+                }
+            }
+
+            // Apply damage to helmet
+            if ((damagesource == DamageSource.ANVIL || damagesource == DamageSource.FALLING_BLOCK) && this.getEquipment(EnumItemSlot.HEAD) != null) {
+                this.getEquipment(EnumItemSlot.HEAD).damage((int) (event.getDamage() * 4.0F + this.random.nextFloat() * event.getDamage() * 2.0F), this, (entityliving) -> {
+                    entityliving.broadcastItemBreak(EnumItemSlot.HEAD);
+                });
+            }
+
+            // Apply damage to armor
+            if (!damagesource.ignoresArmor()) {
+                float armorDamage = (float) (event.getDamage() + event.getDamage(DamageModifier.BLOCKING) + event.getDamage(DamageModifier.HARD_HAT));
+                this.damageArmor(damagesource, armorDamage);
+            }
+
+            // Apply blocking code // PAIL: steal from above
+            if (event.getDamage(DamageModifier.BLOCKING) < 0) {
+                this.world.broadcastEntityEffect(this, (byte) 29); // SPIGOT-4635 - shield damage sound
+                this.damageShield((float) -event.getDamage(DamageModifier.BLOCKING));
+                Entity entity = damagesource.getEntity();
+
+                if (entity instanceof EntityLiving) {
+                    this.shieldBlock((EntityLiving) entity);
+                }
+            }
+
+            absorptionModifier = (float) -event.getDamage(DamageModifier.ABSORPTION);
+            this.setAbsorptionHearts(Math.max(this.getAbsorptionHearts() - absorptionModifier, 0.0F));
+            float f2 = absorptionModifier;
+
+            if (f2 > 0.0F && f2 < 3.4028235E37F && this instanceof EntityHuman) {
+                ((EntityHuman) this).a(StatisticList.DAMAGE_ABSORBED, Math.round(f2 * 10.0F));
+            }
+
+            if (f2 > 0.0F && f2 < 3.4028235E37F && damagesource.getEntity() instanceof EntityPlayer) {
+                ((EntityPlayer) damagesource.getEntity()).a(StatisticList.DAMAGE_DEALT_ABSORBED, Math.round(f2 * 10.0F));
+            }
+
+            if (f > 0 || !human) {
+                if (human) {
+                    // PAIL: Be sure to drag all this code from the EntityHuman subclass each update.
+                    ((EntityHuman) this).applyExhaustion(damagesource.getExhaustionCost());
+                    if (f < 3.4028235E37F) {
+                        ((EntityHuman) this).a(StatisticList.DAMAGE_TAKEN, Math.round(f * 10.0F));
+                    }
+                }
+                // CraftBukkit end
+                float f3 = this.getHealth();
+
+                this.setHealth(f3 - f);
+                this.getCombatTracker().trackDamage(damagesource, f3, f);
+                // CraftBukkit start
+                if (!human) {
+                    this.setAbsorptionHearts(this.getAbsorptionHearts() - f);
+                }
+
+                return true;
+            } else {
+                // Duplicate triggers if blocking
+                if (event.getDamage(DamageModifier.BLOCKING) < 0) {
+                    if (this instanceof EntityPlayer) {
+                        CriterionTriggers.h.a((EntityPlayer) this, damagesource, f, originalDamage, true);
+                        f2 = (float) -event.getDamage(DamageModifier.BLOCKING);
+                        if (f2 > 0.0F && f2 < 3.4028235E37F) {
+                            ((EntityPlayer) this).a(StatisticList.DAMAGE_BLOCKED_BY_SHIELD, Math.round(originalDamage * 10.0F));
+                        }
+                    }
+
+                    if (damagesource.getEntity() instanceof EntityPlayer) {
+                        CriterionTriggers.g.a((EntityPlayer) damagesource.getEntity(), this, damagesource, f, originalDamage, true);
+                    }
+
+                    return false;
+                } else {
+                    return originalDamage > 0;
+                }
+                // CraftBukkit end
+            }
+        }
+        return false; // CraftBukkit
+    }
+
+    public CombatTracker getCombatTracker() {
+        return this.combatTracker;
+    }
+
+    @Nullable
+    public EntityLiving getKillingEntity() {
+        return (EntityLiving) (this.combatTracker.c() != null ? this.combatTracker.c() : (this.killer != null ? this.killer : (this.lastDamager != null ? this.lastDamager : null)));
+    }
+
+    public final float getMaxHealth() {
+        return (float) this.b(GenericAttributes.MAX_HEALTH);
+    }
+
+    public final int getArrowCount() {
+        return (Integer) this.datawatcher.get(EntityLiving.bd);
+    }
+
+    public final void q(int i) {
+        this.datawatcher.set(EntityLiving.bd, i);
+    }
+
+    public final int dU() {
+        return (Integer) this.datawatcher.get(EntityLiving.ARROWS_IN_BODY);
+    }
+
+    public final void setArrowCount(int i) {
+        // CraftBukkit start
+        setArrowCount(i, false);
+    }
+
+    public final void setArrowCount(int i, boolean flag) {
+        ArrowBodyCountChangeEvent event = CraftEventFactory.callArrowBodyCountChangeEvent(this, getArrowCount(), i, flag);
+        if (event.isCancelled()) {
+            return;
+        }
+        this.datawatcher.set(EntityLiving.ARROWS_IN_BODY, event.getNewAmount());
+    }
+    // CraftBukkit end
+
+    private int m() {
+        return MobEffectUtil.a(this) ? 6 - (1 + MobEffectUtil.b(this)) : (this.hasEffect(MobEffects.SLOWER_DIG) ? 6 + (1 + this.getEffect(MobEffects.SLOWER_DIG).getAmplifier()) * 2 : 6);
+    }
+
+    public void swingHand(EnumHand enumhand) {
+        this.swingHand(enumhand, false);
+    }
+
+    public void swingHand(EnumHand enumhand, boolean flag) {
+        if (!this.ad || this.af >= this.m() / 2 || this.af < 0) {
+            this.af = -1;
+            this.ad = true;
+            this.ae = enumhand;
+            if (this.world instanceof WorldServer) {
+                PacketPlayOutAnimation packetplayoutanimation = new PacketPlayOutAnimation(this, enumhand == EnumHand.MAIN_HAND ? 0 : 3);
+                ChunkProviderServer chunkproviderserver = ((WorldServer) this.world).getChunkProvider();
+
+                if (flag) {
+                    chunkproviderserver.broadcastIncludingSelf(this, packetplayoutanimation);
+                } else {
+                    chunkproviderserver.broadcast(this, packetplayoutanimation);
+                }
+            }
+        }
+
+    }
+
+    @Override
+    protected void ao() {
+        this.damageEntity(DamageSource.OUT_OF_WORLD, 4.0F);
+    }
+
+    protected void dV() {
+        int i = this.m();
+
+        if (this.ad) {
+            ++this.af;
+            if (this.af >= i) {
+                this.af = 0;
+                this.ad = false;
+            }
+        } else {
+            this.af = 0;
+        }
+
+        this.an = (float) this.af / (float) i;
+    }
+
+    @Nullable
+    public AttributeModifiable getAttributeInstance(AttributeBase attributebase) {
+        return this.getAttributeMap().a(attributebase);
+    }
+
+    public double b(AttributeBase attributebase) {
+        return this.getAttributeMap().c(attributebase);
+    }
+
+    public double c(AttributeBase attributebase) {
+        return this.getAttributeMap().d(attributebase);
+    }
+
+    public AttributeMapBase getAttributeMap() {
+        return this.attributeMap;
+    }
+
+    public EnumMonsterType getMonsterType() {
+        return EnumMonsterType.UNDEFINED;
+    }
+
+    public ItemStack getItemInMainHand() {
+        return this.getEquipment(EnumItemSlot.MAINHAND);
+    }
+
+    public ItemStack getItemInOffHand() {
+        return this.getEquipment(EnumItemSlot.OFFHAND);
+    }
+
+    public boolean a(Item item) {
+        return this.b((itemstack) -> {
+            return itemstack.a(item);
+        });
+    }
+
+    public boolean b(Predicate<ItemStack> predicate) {
+        return predicate.test(this.getItemInMainHand()) || predicate.test(this.getItemInOffHand());
+    }
+
+    public ItemStack b(EnumHand enumhand) {
+        if (enumhand == EnumHand.MAIN_HAND) {
+            return this.getEquipment(EnumItemSlot.MAINHAND);
+        } else if (enumhand == EnumHand.OFF_HAND) {
+            return this.getEquipment(EnumItemSlot.OFFHAND);
+        } else {
+            throw new IllegalArgumentException("Invalid hand " + enumhand);
+        }
+    }
+
+    public void a(EnumHand enumhand, ItemStack itemstack) {
+        if (enumhand == EnumHand.MAIN_HAND) {
+            this.setSlot(EnumItemSlot.MAINHAND, itemstack);
+        } else {
+            if (enumhand != EnumHand.OFF_HAND) {
+                throw new IllegalArgumentException("Invalid hand " + enumhand);
+            }
+
+            this.setSlot(EnumItemSlot.OFFHAND, itemstack);
+        }
+
+    }
+
+    public boolean a(EnumItemSlot enumitemslot) {
+        return !this.getEquipment(enumitemslot).isEmpty();
+    }
+
+    @Override
+    public abstract Iterable<ItemStack> getArmorItems();
+
+    public abstract ItemStack getEquipment(EnumItemSlot enumitemslot);
+
+    @Override
+    public abstract void setSlot(EnumItemSlot enumitemslot, ItemStack itemstack);
+
+    public float ea() {
+        Iterable<ItemStack> iterable = this.getArmorItems();
+        int i = 0;
+        int j = 0;
+
+        for (Iterator iterator = iterable.iterator(); iterator.hasNext(); ++i) {
+            ItemStack itemstack = (ItemStack) iterator.next();
+
+            if (!itemstack.isEmpty()) {
+                ++j;
+            }
+        }
+
+        return i > 0 ? (float) j / (float) i : 0.0F;
+    }
+
+    @Override
+    public void setSprinting(boolean flag) {
+        super.setSprinting(flag);
+        AttributeModifiable attributemodifiable = this.getAttributeInstance(GenericAttributes.MOVEMENT_SPEED);
+
+        if (attributemodifiable.a(EntityLiving.b) != null) {
+            attributemodifiable.removeModifier(EntityLiving.SPRINTING_SPEED_BOOST);
+        }
+
+        if (flag) {
+            attributemodifiable.b(EntityLiving.SPRINTING_SPEED_BOOST);
+        }
+
+    }
+
+    protected float getSoundVolume() {
+        return 1.0F;
+    }
+
+    protected float ec() {
+        return this.isBaby() ? (this.random.nextFloat() - this.random.nextFloat()) * 0.2F + 1.5F : (this.random.nextFloat() - this.random.nextFloat()) * 0.2F + 1.0F;
+    }
+
+    protected boolean isFrozen() {
+        return this.dG();
+    }
+
+    @Override
+    public void collide(Entity entity) {
+        if (!this.isSleeping()) {
+            super.collide(entity);
+        }
+
+    }
+
+    private void a(Entity entity) {
+        Vec3D vec3d;
+
+        if (!entity.cW() && !this.world.getType(entity.getChunkCoordinates()).a((Tag) TagsBlock.PORTALS)) {
+            vec3d = entity.b(this);
+        } else {
+            vec3d = new Vec3D(entity.locX(), entity.locY() + (double) entity.getHeight(), entity.locZ());
+        }
+
+        this.enderTeleportTo(vec3d.x, vec3d.y, vec3d.z);
+    }
+
+    protected float ee() {
+        return 0.42F * this.getBlockJumpFactor();
+    }
+
+    protected void jump() {
+        float f = this.ee();
+
+        if (this.hasEffect(MobEffects.JUMP)) {
+            f += 0.1F * (float) (this.getEffect(MobEffects.JUMP).getAmplifier() + 1);
+        }
+
+        Vec3D vec3d = this.getMot();
+
+        this.setMot(vec3d.x, (double) f, vec3d.z);
+        if (this.isSprinting()) {
+            float f1 = this.yaw * 0.017453292F;
+
+            this.setMot(this.getMot().add((double) (-MathHelper.sin(f1) * 0.2F), 0.0D, (double) (MathHelper.cos(f1) * 0.2F)));
+        }
+
+        this.impulse = true;
+    }
+
+    protected void c(Tag<FluidType> tag) {
+        this.setMot(this.getMot().add(0.0D, 0.03999999910593033D, 0.0D));
+    }
+
+    protected float eh() {
+        return 0.8F;
+    }
+
+    public boolean a(FluidType fluidtype) {
+        return false;
+    }
+
+    public void g(Vec3D vec3d) {
+        if (this.doAITick() || this.cz()) {
+            double d0 = 0.08D;
+            boolean flag = this.getMot().y <= 0.0D;
+
+            if (flag && this.hasEffect(MobEffects.SLOW_FALLING)) {
+                d0 = 0.01D;
+                this.fallDistance = 0.0F;
+            }
+
+            Fluid fluid = this.world.getFluid(this.getChunkCoordinates());
+            double d1;
+            float f;
+
+            if (this.isInWater() && this.dn() && !this.a(fluid.getType())) {
+                d1 = this.locY();
+                f = this.isSprinting() ? 0.9F : this.eh();
+                float f1 = 0.02F;
+                float f2 = (float) EnchantmentManager.e(this);
+
+                if (f2 > 3.0F) {
+                    f2 = 3.0F;
+                }
+
+                if (!this.onGround) {
+                    f2 *= 0.5F;
+                }
+
+                if (f2 > 0.0F) {
+                    f += (0.54600006F - f) * f2 / 3.0F;
+                    f1 += (this.ei() - f1) * f2 / 3.0F;
+                }
+
+                if (this.hasEffect(MobEffects.DOLPHINS_GRACE)) {
+                    f = 0.96F;
+                }
+
+                this.a(f1, vec3d);
+                this.move(EnumMoveType.SELF, this.getMot());
+                Vec3D vec3d1 = this.getMot();
+
+                if (this.positionChanged && this.isClimbing()) {
+                    vec3d1 = new Vec3D(vec3d1.x, 0.2D, vec3d1.z);
+                }
+
+                this.setMot(vec3d1.d((double) f, 0.800000011920929D, (double) f));
+                Vec3D vec3d2 = this.a(d0, flag, this.getMot());
+
+                this.setMot(vec3d2);
+                if (this.positionChanged && this.e(vec3d2.x, vec3d2.y + 0.6000000238418579D - this.locY() + d1, vec3d2.z)) {
+                    this.setMot(vec3d2.x, 0.30000001192092896D, vec3d2.z);
+                }
+            } else if (this.aS() && this.dn() && !this.a(fluid.getType())) {
+                d1 = this.locY();
+                this.a(0.02F, vec3d);
+                this.move(EnumMoveType.SELF, this.getMot());
+                Vec3D vec3d3;
+
+                if (this.b((Tag) TagsFluid.LAVA) <= this.cE()) {
+                    this.setMot(this.getMot().d(0.5D, 0.800000011920929D, 0.5D));
+                    vec3d3 = this.a(d0, flag, this.getMot());
+                    this.setMot(vec3d3);
+                } else {
+                    this.setMot(this.getMot().a(0.5D));
+                }
+
+                if (!this.isNoGravity()) {
+                    this.setMot(this.getMot().add(0.0D, -d0 / 4.0D, 0.0D));
+                }
+
+                vec3d3 = this.getMot();
+                if (this.positionChanged && this.e(vec3d3.x, vec3d3.y + 0.6000000238418579D - this.locY() + d1, vec3d3.z)) {
+                    this.setMot(vec3d3.x, 0.30000001192092896D, vec3d3.z);
+                }
+            } else if (this.isGliding()) {
+                Vec3D vec3d4 = this.getMot();
+
+                if (vec3d4.y > -0.5D) {
+                    this.fallDistance = 1.0F;
+                }
+
+                Vec3D vec3d5 = this.getLookDirection();
+
+                f = this.pitch * 0.017453292F;
+                double d2 = Math.sqrt(vec3d5.x * vec3d5.x + vec3d5.z * vec3d5.z);
+                double d3 = Math.sqrt(c(vec3d4));
+                double d4 = vec3d5.f();
+                float f3 = MathHelper.cos(f);
+
+                f3 = (float) ((double) f3 * (double) f3 * Math.min(1.0D, d4 / 0.4D));
+                vec3d4 = this.getMot().add(0.0D, d0 * (-1.0D + (double) f3 * 0.75D), 0.0D);
+                double d5;
+
+                if (vec3d4.y < 0.0D && d2 > 0.0D) {
+                    d5 = vec3d4.y * -0.1D * (double) f3;
+                    vec3d4 = vec3d4.add(vec3d5.x * d5 / d2, d5, vec3d5.z * d5 / d2);
+                }
+
+                if (f < 0.0F && d2 > 0.0D) {
+                    d5 = d3 * (double) (-MathHelper.sin(f)) * 0.04D;
+                    vec3d4 = vec3d4.add(-vec3d5.x * d5 / d2, d5 * 3.2D, -vec3d5.z * d5 / d2);
+                }
+
+                if (d2 > 0.0D) {
+                    vec3d4 = vec3d4.add((vec3d5.x / d2 * d3 - vec3d4.x) * 0.1D, 0.0D, (vec3d5.z / d2 * d3 - vec3d4.z) * 0.1D);
+                }
+
+                this.setMot(vec3d4.d(0.9900000095367432D, 0.9800000190734863D, 0.9900000095367432D));
+                this.move(EnumMoveType.SELF, this.getMot());
+                if (this.positionChanged && !this.world.isClientSide) {
+                    d5 = Math.sqrt(c(this.getMot()));
+                    double d6 = d3 - d5;
+                    float f4 = (float) (d6 * 10.0D - 3.0D);
+
+                    if (f4 > 0.0F) {
+                        this.playSound(this.getSoundFall((int) f4), 1.0F, 1.0F);
+                        this.damageEntity(DamageSource.FLY_INTO_WALL, f4);
+                    }
+                }
+
+                if (this.onGround && !this.world.isClientSide) {
+                    if (getFlag(7) && !CraftEventFactory.callToggleGlideEvent(this, false).isCancelled()) // CraftBukkit
+                        this.setFlag(7, false);
+                }
+            } else {
+                BlockPosition blockposition = this.at();
+                float f5 = this.world.getType(blockposition).getBlock().getFrictionFactor();
+
+                f = this.onGround ? f5 * 0.91F : 0.91F;
+                Vec3D vec3d6 = this.a(vec3d, f5);
+                double d7 = vec3d6.y;
+
+                if (this.hasEffect(MobEffects.LEVITATION)) {
+                    d7 += (0.05D * (double) (this.getEffect(MobEffects.LEVITATION).getAmplifier() + 1) - vec3d6.y) * 0.2D;
+                    this.fallDistance = 0.0F;
+                } else if (this.world.isClientSide && !this.world.isLoaded(blockposition)) {
+                    if (this.locY() > (double) this.world.getMinBuildHeight()) {
+                        d7 = -0.1D;
+                    } else {
+                        d7 = 0.0D;
+                    }
+                } else if (!this.isNoGravity()) {
+                    d7 -= d0;
+                }
+
+                this.setMot(vec3d6.x * (double) f, d7 * 0.9800000190734863D, vec3d6.z * (double) f);
+            }
+        }
+
+        this.a(this, this instanceof EntityBird);
+    }
+
+    public void a(EntityLiving entityliving, boolean flag) {
+        entityliving.ap = entityliving.aq;
+        double d0 = entityliving.locX() - entityliving.lastX;
+        double d1 = flag ? entityliving.locY() - entityliving.lastY : 0.0D;
+        double d2 = entityliving.locZ() - entityliving.lastZ;
+        float f = MathHelper.sqrt(d0 * d0 + d1 * d1 + d2 * d2) * 4.0F;
+
+        if (f > 1.0F) {
+            f = 1.0F;
+        }
+
+        entityliving.aq += (f - entityliving.aq) * 0.4F;
+        entityliving.ar += entityliving.aq;
+    }
+
+    public Vec3D a(Vec3D vec3d, float f) {
+        this.a(this.t(f), vec3d);
+        this.setMot(this.i(this.getMot()));
+        this.move(EnumMoveType.SELF, this.getMot());
+        Vec3D vec3d1 = this.getMot();
+
+        if ((this.positionChanged || this.jumping) && (this.isClimbing() || this.dN().a(Blocks.POWDER_SNOW) && PowderSnowBlock.a((Entity) this))) {
+            vec3d1 = new Vec3D(vec3d1.x, 0.2D, vec3d1.z);
+        }
+
+        return vec3d1;
+    }
+
+    public Vec3D a(double d0, boolean flag, Vec3D vec3d) {
+        if (!this.isNoGravity() && !this.isSprinting()) {
+            double d1;
+
+            if (flag && Math.abs(vec3d.y - 0.005D) >= 0.003D && Math.abs(vec3d.y - d0 / 16.0D) < 0.003D) {
+                d1 = -0.003D;
+            } else {
+                d1 = vec3d.y - d0 / 16.0D;
+            }
+
+            return new Vec3D(vec3d.x, d1, vec3d.z);
+        } else {
+            return vec3d;
+        }
+    }
+
+    private Vec3D i(Vec3D vec3d) {
+        if (this.isClimbing()) {
+            this.fallDistance = 0.0F;
+            float f = 0.15F;
+            double d0 = MathHelper.a(vec3d.x, -0.15000000596046448D, 0.15000000596046448D);
+            double d1 = MathHelper.a(vec3d.z, -0.15000000596046448D, 0.15000000596046448D);
+            double d2 = Math.max(vec3d.y, -0.15000000596046448D);
+
+            if (d2 < 0.0D && !this.dN().a(Blocks.SCAFFOLDING) && this.ez() && this instanceof EntityHuman) {
+                d2 = 0.0D;
+            }
+
+            vec3d = new Vec3D(d0, d2, d1);
+        }
+
+        return vec3d;
+    }
+
+    private float t(float f) {
+        return this.onGround ? this.ei() * (0.21600002F / (f * f * f)) : this.az;
+    }
+
+    public float ei() {
+        return this.bq;
+    }
+
+    public void q(float f) {
+        this.bq = f;
+    }
+
+    public boolean attackEntity(Entity entity) {
+        this.z(entity);
+        return false;
+    }
+
+    @Override
+    public void tick() {
+        SpigotTimings.timerEntityBaseTick.startTiming(); // Spigot
+        super.tick();
+        this.u();
+        this.w();
+        if (!this.world.isClientSide) {
+            int i = this.getArrowCount();
+
+            if (i > 0) {
+                if (this.arrowCooldown <= 0) {
+                    this.arrowCooldown = 20 * (30 - i);
+                }
+
+                --this.arrowCooldown;
+                if (this.arrowCooldown <= 0) {
+                    this.q(i - 1);
+                }
+            }
+
+            int j = this.dU();
+
+            if (j > 0) {
+                if (this.ah <= 0) {
+                    this.ah = 20 * (30 - j);
+                }
+
+                --this.ah;
+                if (this.ah <= 0) {
+                    this.setArrowCount(j - 1);
+                }
+            }
+
+            this.p();
+            if (this.ticksLived % 20 == 0) {
+                this.getCombatTracker().g();
+            }
+
+            if (!this.glowing) {
+                boolean flag = this.hasEffect(MobEffects.GLOWING);
+
+                if (this.getFlag(6) != flag) {
+                    this.setFlag(6, flag);
+                }
+            }
+
+            if (this.isSleeping() && !this.x()) {
+                this.entityWakeup();
+            }
+        }
+
+        SpigotTimings.timerEntityBaseTick.stopTiming(); // Spigot
+        this.movementTick();
+        SpigotTimings.timerEntityTickRest.startTiming(); // Spigot
+        double d0 = this.locX() - this.lastX;
+        double d1 = this.locZ() - this.lastZ;
+        float f = (float) (d0 * d0 + d1 * d1);
+        float f1 = this.av;
+        float f2 = 0.0F;
+
+        this.aE = this.aF;
+        float f3 = 0.0F;
+
+        if (f > 0.0025000002F) {
+            f3 = 1.0F;
+            f2 = (float) Math.sqrt((double) f) * 3.0F;
+            float f4 = (float) MathHelper.d(d1, d0) * 57.295776F - 90.0F;
+            float f5 = MathHelper.e(MathHelper.g(this.yaw) - f4);
+
+            if (95.0F < f5 && f5 < 265.0F) {
+                f1 = f4 - 180.0F;
+            } else {
+                f1 = f4;
+            }
+        }
+
+        if (this.an > 0.0F) {
+            f1 = this.yaw;
+        }
+
+        if (!this.onGround) {
+            f3 = 0.0F;
+        }
+
+        this.aF += (f3 - this.aF) * 0.3F;
+        this.world.getMethodProfiler().enter("headTurn");
+        f2 = this.f(f1, f2);
+        this.world.getMethodProfiler().exit();
+        this.world.getMethodProfiler().enter("rangeChecks");
+
+        while (this.yaw - this.lastYaw < -180.0F) {
+            this.lastYaw -= 360.0F;
+        }
+
+        while (this.yaw - this.lastYaw >= 180.0F) {
+            this.lastYaw += 360.0F;
+        }
+
+        while (this.av - this.aw < -180.0F) {
+            this.aw -= 360.0F;
+        }
+
+        while (this.av - this.aw >= 180.0F) {
+            this.aw += 360.0F;
+        }
+
+        while (this.pitch - this.lastPitch < -180.0F) {
+            this.lastPitch -= 360.0F;
+        }
+
+        while (this.pitch - this.lastPitch >= 180.0F) {
+            this.lastPitch += 360.0F;
+        }
+
+        while (this.ax - this.ay < -180.0F) {
+            this.ay -= 360.0F;
+        }
+
+        while (this.ax - this.ay >= 180.0F) {
+            this.ay += 360.0F;
+        }
+
+        this.world.getMethodProfiler().exit();
+        this.aG += f2;
+        if (this.isGliding()) {
+            ++this.aZ;
+        } else {
+            this.aZ = 0;
+        }
+
+        if (this.isSleeping()) {
+            this.pitch = 0.0F;
+        }
+
+        SpigotTimings.timerEntityTickRest.stopTiming(); // Spigot
+    }
+
+    private void p() {
+        Map<EnumItemSlot, ItemStack> map = this.q();
+
+        if (map != null) {
+            this.a(map);
+            if (!map.isEmpty()) {
+                this.b(map);
+            }
+        }
+
+    }
+
+    @Nullable
+    private Map<EnumItemSlot, ItemStack> q() {
+        Map<EnumItemSlot, ItemStack> map = null;
+        EnumItemSlot[] aenumitemslot = EnumItemSlot.values();
+        int i = aenumitemslot.length;
+
+        for (int j = 0; j < i; ++j) {
+            EnumItemSlot enumitemslot = aenumitemslot[j];
+            ItemStack itemstack;
+
+            switch (enumitemslot.a()) {
+                case HAND:
+                    itemstack = this.e(enumitemslot);
+                    break;
+                case ARMOR:
+                    itemstack = this.d(enumitemslot);
+                    break;
+                default:
+                    continue;
+            }
+
+            ItemStack itemstack1 = this.getEquipment(enumitemslot);
+
+            if (!ItemStack.matches(itemstack1, itemstack)) {
+                if (map == null) {
+                    map = Maps.newEnumMap(EnumItemSlot.class);
+                }
+
+                map.put(enumitemslot, itemstack1);
+                if (!itemstack.isEmpty()) {
+                    this.getAttributeMap().a(itemstack.a(enumitemslot));
+                }
+
+                if (!itemstack1.isEmpty()) {
+                    this.getAttributeMap().b(itemstack1.a(enumitemslot));
+                }
+            }
+        }
+
+        return map;
+    }
+
+    private void a(Map<EnumItemSlot, ItemStack> map) {
+        ItemStack itemstack = (ItemStack) map.get(EnumItemSlot.MAINHAND);
+        ItemStack itemstack1 = (ItemStack) map.get(EnumItemSlot.OFFHAND);
+
+        if (itemstack != null && itemstack1 != null && ItemStack.matches(itemstack, this.e(EnumItemSlot.OFFHAND)) && ItemStack.matches(itemstack1, this.e(EnumItemSlot.MAINHAND))) {
+            ((WorldServer) this.world).getChunkProvider().broadcast(this, new PacketPlayOutEntityStatus(this, (byte) 55));
+            map.remove(EnumItemSlot.MAINHAND);
+            map.remove(EnumItemSlot.OFFHAND);
+            this.c(EnumItemSlot.MAINHAND, itemstack.cloneItemStack());
+            this.c(EnumItemSlot.OFFHAND, itemstack1.cloneItemStack());
+        }
+
+    }
+
+    private void b(Map<EnumItemSlot, ItemStack> map) {
+        List<Pair<EnumItemSlot, ItemStack>> list = Lists.newArrayListWithCapacity(map.size());
+
+        map.forEach((enumitemslot, itemstack) -> {
+            ItemStack itemstack1 = itemstack.cloneItemStack();
+
+            list.add(Pair.of(enumitemslot, itemstack1));
+            switch (enumitemslot.a()) {
+                case HAND:
+                    this.c(enumitemslot, itemstack1);
+                    break;
+                case ARMOR:
+                    this.b(enumitemslot, itemstack1);
+            }
+
+        });
+        ((WorldServer) this.world).getChunkProvider().broadcast(this, new PacketPlayOutEntityEquipment(this.getId(), list));
+    }
+
+    private ItemStack d(EnumItemSlot enumitemslot) {
+        return (ItemStack) this.bk.get(enumitemslot.b());
+    }
+
+    private void b(EnumItemSlot enumitemslot, ItemStack itemstack) {
+        this.bk.set(enumitemslot.b(), itemstack);
+    }
+
+    private ItemStack e(EnumItemSlot enumitemslot) {
+        return (ItemStack) this.bj.get(enumitemslot.b());
+    }
+
+    private void c(EnumItemSlot enumitemslot, ItemStack itemstack) {
+        this.bj.set(enumitemslot.b(), itemstack);
+    }
+
+    protected float f(float f, float f1) {
+        float f2 = MathHelper.g(f - this.av);
+
+        this.av += f2 * 0.3F;
+        float f3 = MathHelper.g(this.yaw - this.av);
+        boolean flag = f3 < -90.0F || f3 >= 90.0F;
+
+        if (f3 < -75.0F) {
+            f3 = -75.0F;
+        }
+
+        if (f3 >= 75.0F) {
+            f3 = 75.0F;
+        }
+
+        this.av = this.yaw - f3;
+        if (f3 * f3 > 2500.0F) {
+            this.av += f3 * 0.2F;
+        }
+
+        if (flag) {
+            f1 *= -1.0F;
+        }
+
+        return f1;
+    }
+
+    public void movementTick() {
+        if (this.jumpTicks > 0) {
+            --this.jumpTicks;
+        }
+
+        if (this.cz()) {
+            this.aP = 0;
+            this.c(this.locX(), this.locY(), this.locZ());
+        }
+
+        if (this.aP > 0) {
+            double d0 = this.locX() + (this.aQ - this.locX()) / (double) this.aP;
+            double d1 = this.locY() + (this.aR - this.locY()) / (double) this.aP;
+            double d2 = this.locZ() + (this.aS - this.locZ()) / (double) this.aP;
+            double d3 = MathHelper.g(this.aT - (double) this.yaw);
+
+            this.yaw = (float) ((double) this.yaw + d3 / (double) this.aP);
+            this.pitch = (float) ((double) this.pitch + (this.aU - (double) this.pitch) / (double) this.aP);
+            --this.aP;
+            this.setPosition(d0, d1, d2);
+            this.setYawPitch(this.yaw, this.pitch);
+        } else if (!this.doAITick()) {
+            this.setMot(this.getMot().a(0.98D));
+        }
+
+        if (this.aW > 0) {
+            this.ax = (float) ((double) this.ax + MathHelper.g(this.aV - (double) this.ax) / (double) this.aW);
+            --this.aW;
+        }
+
+        Vec3D vec3d = this.getMot();
+        double d4 = vec3d.x;
+        double d5 = vec3d.y;
+        double d6 = vec3d.z;
+
+        if (Math.abs(vec3d.x) < 0.003D) {
+            d4 = 0.0D;
+        }
+
+        if (Math.abs(vec3d.y) < 0.003D) {
+            d5 = 0.0D;
+        }
+
+        if (Math.abs(vec3d.z) < 0.003D) {
+            d6 = 0.0D;
+        }
+
+        this.setMot(d4, d5, d6);
+        this.world.getMethodProfiler().enter("ai");
+        SpigotTimings.timerEntityAI.startTiming(); // Spigot
+        if (this.isFrozen()) {
+            this.jumping = false;
+            this.aM = 0.0F;
+            this.aO = 0.0F;
+        } else if (this.doAITick()) {
+            this.world.getMethodProfiler().enter("newAi");
+            this.doTick();
+            this.world.getMethodProfiler().exit();
+        }
+        SpigotTimings.timerEntityAI.stopTiming(); // Spigot
+
+        this.world.getMethodProfiler().exit();
+        this.world.getMethodProfiler().enter("jump");
+        if (this.jumping && this.dn()) {
+            double d7;
+
+            if (this.aS()) {
+                d7 = this.b((Tag) TagsFluid.LAVA);
+            } else {
+                d7 = this.b((Tag) TagsFluid.WATER);
+            }
+
+            boolean flag = this.isInWater() && d7 > 0.0D;
+            double d8 = this.cE();
+
+            if (flag && (!this.onGround || d7 > d8)) {
+                this.c((Tag) TagsFluid.WATER);
+            } else if (this.aS() && (!this.onGround || d7 > d8)) {
+                this.c((Tag) TagsFluid.LAVA);
+            } else if ((this.onGround || flag && d7 <= d8) && this.jumpTicks == 0) {
+                this.jump();
+                this.jumpTicks = 10;
+            }
+        } else {
+            this.jumpTicks = 0;
+        }
+
+        this.world.getMethodProfiler().exit();
+        this.world.getMethodProfiler().enter("travel");
+        this.aM *= 0.98F;
+        this.aO *= 0.98F;
+        this.r();
+        AxisAlignedBB axisalignedbb = this.getBoundingBox();
+
+        SpigotTimings.timerEntityAIMove.startTiming(); // Spigot
+        this.g(new Vec3D((double) this.aM, (double) this.aN, (double) this.aO));
+        SpigotTimings.timerEntityAIMove.stopTiming(); // Spigot
+        this.world.getMethodProfiler().exit();
+        this.world.getMethodProfiler().enter("freezing");
+        int i = this.bM();
+
+        if (this.aa && this.cV()) {
+            this.setAirTicks(Math.min(this.bP(), i + 1));
+        } else {
+            this.setAirTicks(Math.max(0, i - 2));
+        }
+
+        this.dk();
+        this.dl();
+        if (this.ticksLived % 60 == 0 && this.bO() && this.cV()) {
+            this.damageEntity(DamageSource.FREEZE, 1.0F);
+        }
+
+        this.world.getMethodProfiler().exit();
+        this.world.getMethodProfiler().enter("push");
+        if (this.ba > 0) {
+            --this.ba;
+            this.a(axisalignedbb, this.getBoundingBox());
+        }
+
+        SpigotTimings.timerEntityAICollision.startTiming(); // Spigot
+        this.collideNearby();
+        SpigotTimings.timerEntityAICollision.stopTiming(); // Spigot
+        this.world.getMethodProfiler().exit();
+        if (!this.world.isClientSide && this.ej() && this.aI()) {
+            this.damageEntity(DamageSource.DROWN, 1.0F);
+        }
+
+    }
+
+    public boolean ej() {
+        return false;
+    }
+
+    private void r() {
+        boolean flag = this.getFlag(7);
+
+        if (flag && !this.onGround && !this.isPassenger() && !this.hasEffect(MobEffects.LEVITATION)) {
+            ItemStack itemstack = this.getEquipment(EnumItemSlot.CHEST);
+
+            if (itemstack.a(Items.ELYTRA) && ItemElytra.d(itemstack)) {
+                flag = true;
+                int i = this.aZ + 1;
+
+                if (!this.world.isClientSide && i % 10 == 0) {
+                    int j = i / 10;
+
+                    if (j % 2 == 0) {
+                        itemstack.damage(1, this, (entityliving) -> {
+                            entityliving.broadcastItemBreak(EnumItemSlot.CHEST);
+                        });
+                    }
+
+                    this.a(ckz.d);
+                }
+            } else {
+                flag = false;
+            }
+        } else {
+            flag = false;
+        }
+
+        if (!this.world.isClientSide) {
+            if (flag != this.getFlag(7) && !CraftEventFactory.callToggleGlideEvent(this, flag).isCancelled()) // CraftBukkit
+                this.setFlag(7, flag);
+        }
+
+    }
+
+    protected void doTick() {}
+
+    protected void collideNearby() {
+        List<Entity> list = this.world.getEntities(this, this.getBoundingBox(), IEntitySelector.a(this));
+
+        if (!list.isEmpty()) {
+            int i = this.world.getGameRules().getInt(GameRules.MAX_ENTITY_CRAMMING);
+            int j;
+
+            if (i > 0 && list.size() > i - 1 && this.random.nextInt(4) == 0) {
+                j = 0;
+
+                for (int k = 0; k < list.size(); ++k) {
+                    if (!((Entity) list.get(k)).isPassenger()) {
+                        ++j;
+                    }
+                }
+
+                if (j > i - 1) {
+                    this.damageEntity(DamageSource.CRAMMING, 6.0F);
+                }
+            }
+
+            for (j = 0; j < list.size(); ++j) {
+                Entity entity = (Entity) list.get(j);
+
+                this.C(entity);
+            }
+        }
+
+    }
+
+    protected void a(AxisAlignedBB axisalignedbb, AxisAlignedBB axisalignedbb1) {
+        AxisAlignedBB axisalignedbb2 = axisalignedbb.b(axisalignedbb1);
+        List<Entity> list = this.world.getEntities(this, axisalignedbb2);
+
+        if (!list.isEmpty()) {
+            for (int i = 0; i < list.size(); ++i) {
+                Entity entity = (Entity) list.get(i);
+
+                if (entity instanceof EntityLiving) {
+                    this.g((EntityLiving) entity);
+                    this.ba = 0;
+                    this.setMot(this.getMot().a(-0.2D));
+                    break;
+                }
+            }
+        } else if (this.positionChanged) {
+            this.ba = 0;
+        }
+
+        if (!this.world.isClientSide && this.ba <= 0) {
+            this.c(4, false);
+        }
+
+    }
+
+    protected void C(Entity entity) {
+        entity.collide(this);
+    }
+
+    protected void g(EntityLiving entityliving) {}
+
+    public void s(int i) {
+        this.ba = i;
+        if (!this.world.isClientSide) {
+            this.c(4, true);
+        }
+
+    }
+
+    public boolean isRiptiding() {
+        return ((Byte) this.datawatcher.get(EntityLiving.ab) & 4) != 0;
+    }
+
+    @Override
+    public void stopRiding() {
+        Entity entity = this.getVehicle();
+
+        super.stopRiding();
+        if (entity != null && entity != this.getVehicle() && !this.world.isClientSide) {
+            this.a(entity);
+        }
+
+    }
+
+    @Override
+    public void passengerTick() {
+        super.passengerTick();
+        this.aE = this.aF;
+        this.aF = 0.0F;
+        this.fallDistance = 0.0F;
+    }
+
+    public void setJumping(boolean flag) {
+        this.jumping = flag;
+    }
+
+    public void a(EntityItem entityitem) {
+        EntityHuman entityhuman = entityitem.getThrower() != null ? this.world.b(entityitem.getThrower()) : null;
+
+        if (entityhuman instanceof EntityPlayer) {
+            CriterionTriggers.O.a((EntityPlayer) entityhuman, entityitem.getItemStack(), this);
+        }
+
+    }
+
+    public void receive(Entity entity, int i) {
+        if (!entity.cW() && !this.world.isClientSide && (entity instanceof EntityItem || entity instanceof EntityArrow || entity instanceof EntityExperienceOrb)) {
+            ((WorldServer) this.world).getChunkProvider().broadcast(entity, new PacketPlayOutCollect(entity.getId(), this.getId(), i));
+        }
+
+    }
+
+    public boolean hasLineOfSight(Entity entity) {
+        if (this.world != entity.world) return false; // CraftBukkit - SPIGOT-5675, SPIGOT-5798, MC-149563
+        Vec3D vec3d = new Vec3D(this.locX(), this.getHeadY(), this.locZ());
+        Vec3D vec3d1 = new Vec3D(entity.locX(), entity.getHeadY(), entity.locZ());
+
+        return this.world.rayTrace(new RayTrace(vec3d, vec3d1, RayTrace.BlockCollisionOption.COLLIDER, RayTrace.FluidCollisionOption.NONE, this)).getType() == MovingObjectPosition.EnumMovingObjectType.MISS;
+    }
+
+    @Override
+    public float h(float f) {
+        return f == 1.0F ? this.ax : MathHelper.g(f, this.ay, this.ax);
+    }
+
+    public boolean doAITick() {
+        return !this.world.isClientSide;
+    }
+
+    @Override
+    public boolean isInteractable() {
+        return !this.cW() && this.collides; // CraftBukkit
+    }
+
+    @Override
+    public boolean isCollidable() {
+        return this.isAlive() && !this.isSpectator() && !this.isClimbing() && this.collides; // CraftBukkit
+    }
+
+    // CraftBukkit start - collidable API
+    @Override
+    public boolean canCollideWith(Entity entity) {
+        return isCollidable() && this.collides != this.collidableExemptions.contains(entity.getUniqueID());
+    }
+    // CraftBukkit end
+
+    @Override
+    protected void velocityChanged() {
+        this.velocityChanged = this.random.nextDouble() >= this.b(GenericAttributes.KNOCKBACK_RESISTANCE);
+    }
+
+    @Override
+    public float getHeadRotation() {
+        return this.ax;
+    }
+
+    @Override
+    public void setHeadRotation(float f) {
+        this.ax = f;
+    }
+
+    @Override
+    public void n(float f) {
+        this.av = f;
+    }
+
+    @Override
+    protected Vec3D a(EnumDirection.EnumAxis enumdirection_enumaxis, BlockUtil.Rectangle blockutil_rectangle) {
+        return h(super.a(enumdirection_enumaxis, blockutil_rectangle));
+    }
+
+    public static Vec3D h(Vec3D vec3d) {
+        return new Vec3D(vec3d.x, vec3d.y, 0.0D);
+    }
+
+    public float getAbsorptionHearts() {
+        return this.bs;
+    }
+
+    public void setAbsorptionHearts(float f) {
+        if (f < 0.0F) {
+            f = 0.0F;
+        }
+
+        this.bs = f;
+    }
+
+    public void enterCombat() {}
+
+    public void exitCombat() {}
+
+    protected void ep() {
+        this.updateEffects = true;
+    }
+
+    public abstract EnumMainHand getMainHand();
+
+    public boolean isHandRaised() {
+        return ((Byte) this.datawatcher.get(EntityLiving.ab) & 1) > 0;
+    }
+
+    public EnumHand getRaisedHand() {
+        return ((Byte) this.datawatcher.get(EntityLiving.ab) & 2) > 0 ? EnumHand.OFF_HAND : EnumHand.MAIN_HAND;
+    }
+
+    private void u() {
+        if (this.isHandRaised()) {
+            if (ItemStack.d(this.b(this.getRaisedHand()), this.activeItem)) {
+                this.activeItem = this.b(this.getRaisedHand());
+                this.activeItem.b(this.world, this, this.eu());
+                if (this.v()) {
+                    this.b(this.activeItem, 5);
+                }
+
+                if (--this.aY == 0 && !this.world.isClientSide && !this.activeItem.q()) {
+                    this.s();
+                }
+            } else {
+                this.clearActiveItem();
+            }
+        }
+
+    }
+
+    private boolean v() {
+        int i = this.eu();
+        FoodInfo foodinfo = this.activeItem.getItem().getFoodInfo();
+        boolean flag = foodinfo != null && foodinfo.e();
+
+        flag |= i <= this.activeItem.o() - 7;
+        return flag && i % 4 == 0;
+    }
+
+    private void w() {
+        this.by = this.bx;
+        if (this.bE()) {
+            this.bx = Math.min(1.0F, this.bx + 0.09F);
+        } else {
+            this.bx = Math.max(0.0F, this.bx - 0.09F);
+        }
+
+    }
+
+    protected void c(int i, boolean flag) {
+        byte b0 = (Byte) this.datawatcher.get(EntityLiving.ab);
+        int j;
+
+        if (flag) {
+            j = b0 | i;
+        } else {
+            j = b0 & ~i;
+        }
+
+        this.datawatcher.set(EntityLiving.ab, (byte) j);
+    }
+
+    public void c(EnumHand enumhand) {
+        ItemStack itemstack = this.b(enumhand);
+
+        if (!itemstack.isEmpty() && !this.isHandRaised()) {
+            this.activeItem = itemstack;
+            this.aY = itemstack.o();
+            if (!this.world.isClientSide) {
+                this.c(1, true);
+                this.c(2, enumhand == EnumHand.OFF_HAND);
+            }
+
+        }
+    }
+
+    @Override
+    public void a(DataWatcherObject<?> datawatcherobject) {
+        super.a(datawatcherobject);
+        if (EntityLiving.bf.equals(datawatcherobject)) {
+            if (this.world.isClientSide) {
+                this.getBedPosition().ifPresent(this::a);
+            }
+        } else if (EntityLiving.ab.equals(datawatcherobject) && this.world.isClientSide) {
+            if (this.isHandRaised() && this.activeItem.isEmpty()) {
+                this.activeItem = this.b(this.getRaisedHand());
+                if (!this.activeItem.isEmpty()) {
+                    this.aY = this.activeItem.o();
+                }
+            } else if (!this.isHandRaised() && !this.activeItem.isEmpty()) {
+                this.activeItem = ItemStack.b;
+                this.aY = 0;
+            }
+        }
+
+    }
+
+    @Override
+    public void a(ArgumentAnchor.Anchor argumentanchor_anchor, Vec3D vec3d) {
+        super.a(argumentanchor_anchor, vec3d);
+        this.ay = this.ax;
+        this.av = this.ax;
+        this.aw = this.av;
+    }
+
+    protected void b(ItemStack itemstack, int i) {
+        if (!itemstack.isEmpty() && this.isHandRaised()) {
+            if (itemstack.p() == EnumAnimation.DRINK) {
+                this.playSound(this.c(itemstack), 0.5F, this.world.random.nextFloat() * 0.1F + 0.9F);
+            }
+
+            if (itemstack.p() == EnumAnimation.EAT) {
+                this.a(itemstack, i);
+                this.playSound(this.d(itemstack), 0.5F + 0.5F * (float) this.random.nextInt(2), (this.random.nextFloat() - this.random.nextFloat()) * 0.2F + 1.0F);
+            }
+
+        }
+    }
+
+    private void a(ItemStack itemstack, int i) {
+        for (int j = 0; j < i; ++j) {
+            Vec3D vec3d = new Vec3D(((double) this.random.nextFloat() - 0.5D) * 0.1D, Math.random() * 0.1D + 0.1D, 0.0D);
+
+            vec3d = vec3d.a(-this.pitch * 0.017453292F);
+            vec3d = vec3d.b(-this.yaw * 0.017453292F);
+            double d0 = (double) (-this.random.nextFloat()) * 0.6D - 0.3D;
+            Vec3D vec3d1 = new Vec3D(((double) this.random.nextFloat() - 0.5D) * 0.3D, d0, 0.6D);
+
+            vec3d1 = vec3d1.a(-this.pitch * 0.017453292F);
+            vec3d1 = vec3d1.b(-this.yaw * 0.017453292F);
+            vec3d1 = vec3d1.add(this.locX(), this.getHeadY(), this.locZ());
+            this.world.addParticle(new ParticleParamItem(Particles.ITEM, itemstack), vec3d1.x, vec3d1.y, vec3d1.z, vec3d.x, vec3d.y + 0.05D, vec3d.z);
+        }
+
+    }
+
+    protected void s() {
+        EnumHand enumhand = this.getRaisedHand();
+
+        if (!this.activeItem.equals(this.b(enumhand))) {
+            this.releaseActiveItem();
+        } else {
+            if (!this.activeItem.isEmpty() && this.isHandRaised()) {
+                this.b(this.activeItem, 16);
+                // CraftBukkit start - fire PlayerItemConsumeEvent
+                ItemStack itemstack;
+                if (this instanceof EntityPlayer) {
+                    org.bukkit.inventory.ItemStack craftItem = CraftItemStack.asBukkitCopy(this.activeItem);
+                    PlayerItemConsumeEvent event = new PlayerItemConsumeEvent((Player) this.getBukkitEntity(), craftItem);
+                    world.getServer().getPluginManager().callEvent(event);
+
+                    if (event.isCancelled()) {
+                        // Update client
+                        ((EntityPlayer) this).getBukkitEntity().updateInventory();
+                        ((EntityPlayer) this).getBukkitEntity().updateScaledHealth();
+                        return;
+                    }
+
+                    itemstack = (craftItem.equals(event.getItem())) ? this.activeItem.a(this.world, this) : CraftItemStack.asNMSCopy(event.getItem()).a(world, this);
+                } else {
+                    itemstack = this.activeItem.a(this.world, this);
+                }
+                // CraftBukkit end
+
+                if (itemstack != this.activeItem) {
+                    this.a(enumhand, itemstack);
+                }
+
+                this.clearActiveItem();
+            }
+
+        }
+    }
+
+    public ItemStack getActiveItem() {
+        return this.activeItem;
+    }
+
+    public int eu() {
+        return this.aY;
+    }
+
+    public int ev() {
+        return this.isHandRaised() ? this.activeItem.o() - this.eu() : 0;
+    }
+
+    public void releaseActiveItem() {
+        if (!this.activeItem.isEmpty()) {
+            this.activeItem.a(this.world, this, this.eu());
+            if (this.activeItem.q()) {
+                this.u();
+            }
+        }
+
+        this.clearActiveItem();
+    }
+
+    public void clearActiveItem() {
+        if (!this.world.isClientSide) {
+            this.c(1, false);
+        }
+
+        this.activeItem = ItemStack.b;
+        this.aY = 0;
+    }
+
+    public boolean isBlocking() {
+        if (this.isHandRaised() && !this.activeItem.isEmpty()) {
+            Item item = this.activeItem.getItem();
+
+            return item.d_(this.activeItem) != EnumAnimation.BLOCK ? false : item.e_(this.activeItem) - this.aY >= 5;
+        } else {
+            return false;
+        }
+    }
+
+    public boolean ez() {
+        return this.bw();
+    }
+
+    public boolean isGliding() {
+        return this.getFlag(7);
+    }
+
+    @Override
+    public boolean bE() {
+        return super.bE() || !this.isGliding() && this.getPose() == EntityPose.FALL_FLYING;
+    }
+
+    public boolean a(double d0, double d1, double d2, boolean flag) {
+        double d3 = this.locX();
+        double d4 = this.locY();
+        double d5 = this.locZ();
+        double d6 = d1;
+        boolean flag1 = false;
+        BlockPosition blockposition = new BlockPosition(d0, d1, d2);
+        World world = this.world;
+
+        if (world.isLoaded(blockposition)) {
+            boolean flag2 = false;
+
+            while (!flag2 && blockposition.getY() > world.getMinBuildHeight()) {
+                BlockPosition blockposition1 = blockposition.down();
+                IBlockData iblockdata = world.getType(blockposition1);
+
+                if (iblockdata.getMaterial().isSolid()) {
+                    flag2 = true;
+                } else {
+                    --d6;
+                    blockposition = blockposition1;
+                }
+            }
+
+            if (flag2) {
+                // CraftBukkit start - Teleport event
+                // this.enderTeleportTo(d0, d6, d2);
+                EntityTeleportEvent teleport = new EntityTeleportEvent(this.getBukkitEntity(), new Location(this.world.getWorld(), d3, d4, d5), new Location(this.world.getWorld(), d0, d6, d2));
+                this.world.getServer().getPluginManager().callEvent(teleport);
+                if (!teleport.isCancelled()) {
+                    Location to = teleport.getTo();
+                    this.enderTeleportTo(to.getX(), to.getY(), to.getZ());
+                    if (world.g(this) && !world.containsLiquid(this.getBoundingBox())) {
+                        flag1 = true;
+                    }
+                }
+                // CraftBukkit end
+            }
+        }
+
+        if (!flag1) {
+            this.enderTeleportTo(d3, d4, d5);
+            return false;
+        } else {
+            if (flag) {
+                world.broadcastEntityEffect(this, (byte) 46);
+            }
+
+            if (this instanceof EntityCreature) {
+                ((EntityCreature) this).getNavigation().o();
+            }
+
+            return true;
+        }
+    }
+
+    public boolean eC() {
+        return true;
+    }
+
+    public boolean eD() {
+        return true;
+    }
+
+    public boolean e(ItemStack itemstack) {
+        return false;
+    }
+
+    @Override
+    public Packet<?> P() {
+        return new PacketPlayOutSpawnEntityLiving(this);
+    }
+
+    @Override
+    public EntitySize a(EntityPose entitypose) {
+        return entitypose == EntityPose.SLEEPING ? EntityLiving.ac : super.a(entitypose).a(this.dm());
+    }
+
+    public ImmutableList<EntityPose> eE() {
+        return ImmutableList.of(EntityPose.STANDING);
+    }
+
+    public AxisAlignedBB f(EntityPose entitypose) {
+        EntitySize entitysize = this.a(entitypose);
+
+        return new AxisAlignedBB((double) (-entitysize.width / 2.0F), 0.0D, (double) (-entitysize.width / 2.0F), (double) (entitysize.width / 2.0F), (double) entitysize.height, (double) (entitysize.width / 2.0F));
+    }
+
+    public Optional<BlockPosition> getBedPosition() {
+        return (Optional) this.datawatcher.get(EntityLiving.bf);
+    }
+
+    public void e(BlockPosition blockposition) {
+        this.datawatcher.set(EntityLiving.bf, Optional.of(blockposition));
+    }
+
+    public void eG() {
+        this.datawatcher.set(EntityLiving.bf, Optional.empty());
+    }
+
+    public boolean isSleeping() {
+        return this.getBedPosition().isPresent();
+    }
+
+    public void entitySleep(BlockPosition blockposition) {
+        if (this.isPassenger()) {
+            this.stopRiding();
+        }
+
+        IBlockData iblockdata = this.world.getType(blockposition);
+
+        if (iblockdata.getBlock() instanceof BlockBed) {
+            this.world.setTypeAndData(blockposition, (IBlockData) iblockdata.set(BlockBed.OCCUPIED, true), 3);
+        }
+
+        this.setPose(EntityPose.SLEEPING);
+        this.a(blockposition);
+        this.e(blockposition);
+        this.setMot(Vec3D.ORIGIN);
+        this.impulse = true;
+    }
+
+    private void a(BlockPosition blockposition) {
+        this.setPosition((double) blockposition.getX() + 0.5D, (double) blockposition.getY() + 0.6875D, (double) blockposition.getZ() + 0.5D);
+    }
+
+    private boolean x() {
+        return (Boolean) this.getBedPosition().map((blockposition) -> {
+            return this.world.getType(blockposition).getBlock() instanceof BlockBed;
+        }).orElse(false);
+    }
+
+    public void entityWakeup() {
+        Optional<BlockPosition> optional = this.getBedPosition(); // CraftBukkit - decompile error
+        World world = this.world;
+
+        this.world.getClass();
+        optional.filter(world::isLoaded).ifPresent((blockposition) -> {
+            IBlockData iblockdata = this.world.getType(blockposition);
+
+            if (iblockdata.getBlock() instanceof BlockBed) {
+                this.world.setTypeAndData(blockposition, (IBlockData) iblockdata.set(BlockBed.OCCUPIED, false), 3);
+                Vec3D vec3d = (Vec3D) BlockBed.a(this.getEntityType(), this.world, blockposition, this.yaw).orElseGet(() -> {
+                    BlockPosition blockposition1 = blockposition.up();
+
+                    return new Vec3D((double) blockposition1.getX() + 0.5D, (double) blockposition1.getY() + 0.1D, (double) blockposition1.getZ() + 0.5D);
+                });
+                Vec3D vec3d1 = Vec3D.c((BaseBlockPosition) blockposition).d(vec3d).d();
+                float f = (float) MathHelper.g(MathHelper.d(vec3d1.z, vec3d1.x) * 57.2957763671875D - 90.0D);
+
+                this.setPosition(vec3d.x, vec3d.y, vec3d.z);
+                this.yaw = f;
+                this.pitch = 0.0F;
+            }
+
+        });
+        Vec3D vec3d = this.getPositionVector();
+
+        this.setPose(EntityPose.STANDING);
+        this.setPosition(vec3d.x, vec3d.y, vec3d.z);
+        this.eG();
+    }
+
+    @Override
+    public boolean inBlock() {
+        return !this.isSleeping() && super.inBlock();
+    }
+
+    @Override
+    protected final float getHeadHeight(EntityPose entitypose, EntitySize entitysize) {
+        return entitypose == EntityPose.SLEEPING ? 0.2F : this.b(entitypose, entitysize);
+    }
+
+    protected float b(EntityPose entitypose, EntitySize entitysize) {
+        return super.getHeadHeight(entitypose, entitysize);
+    }
+
+    public ItemStack f(ItemStack itemstack) {
+        return ItemStack.b;
+    }
+
+    public ItemStack a(World world, ItemStack itemstack) {
+        if (itemstack.J()) {
+            world.playSound((EntityHuman) null, this.locX(), this.locY(), this.locZ(), this.d(itemstack), SoundCategory.NEUTRAL, 1.0F, 1.0F + (world.random.nextFloat() - world.random.nextFloat()) * 0.4F);
+            this.a(itemstack, world, this);
+            if (!(this instanceof EntityHuman) || !((EntityHuman) this).eX().canInstantlyBuild) {
+                itemstack.subtract(1);
+            }
+
+            this.a(ckz.G);
+        }
+
+        return itemstack;
+    }
+
+    private void a(ItemStack itemstack, World world, EntityLiving entityliving) {
+        Item item = itemstack.getItem();
+
+        if (item.isFood()) {
+            List<Pair<MobEffect, Float>> list = item.getFoodInfo().f();
+            Iterator iterator = list.iterator();
+
+            while (iterator.hasNext()) {
+                Pair<MobEffect, Float> pair = (Pair) iterator.next();
+
+                if (!world.isClientSide && pair.getFirst() != null && world.random.nextFloat() < (Float) pair.getSecond()) {
+                    entityliving.addEffect(new MobEffect((MobEffect) pair.getFirst()), EntityPotionEffectEvent.Cause.FOOD); // CraftBukkit
+                }
+            }
+        }
+
+    }
+
+    private static byte f(EnumItemSlot enumitemslot) {
+        switch (enumitemslot) {
+            case MAINHAND:
+                return 47;
+            case OFFHAND:
+                return 48;
+            case HEAD:
+                return 49;
+            case CHEST:
+                return 50;
+            case FEET:
+                return 52;
+            case LEGS:
+                return 51;
+            default:
+                return 47;
+        }
+    }
+
+    public void broadcastItemBreak(EnumItemSlot enumitemslot) {
+        this.world.broadcastEntityEffect(this, f(enumitemslot));
+    }
+
+    public void broadcastItemBreak(EnumHand enumhand) {
+        this.broadcastItemBreak(enumhand == EnumHand.MAIN_HAND ? EnumItemSlot.MAINHAND : EnumItemSlot.OFFHAND);
+    }
+
+    public static EnumItemSlot g(ItemStack itemstack) {
+        Item item = itemstack.getItem();
+
+        return !itemstack.a(Items.dn) && (!(item instanceof ItemBlock) || !(((ItemBlock) item).getBlock() instanceof BlockSkullAbstract)) ? (item instanceof ItemArmor ? ((ItemArmor) item).b() : (itemstack.a(Items.ELYTRA) ? EnumItemSlot.CHEST : (itemstack.a(Items.SHIELD) ? EnumItemSlot.OFFHAND : EnumItemSlot.MAINHAND))) : EnumItemSlot.HEAD;
+    }
+
+    private static SlotAccess a(EntityLiving entityliving, EnumItemSlot enumitemslot) {
+        return enumitemslot != EnumItemSlot.HEAD && enumitemslot != EnumItemSlot.MAINHAND && enumitemslot != EnumItemSlot.OFFHAND ? SlotAccess.a(entityliving, enumitemslot, (itemstack) -> {
+            return itemstack.isEmpty() || EntityInsentient.g(itemstack) == enumitemslot;
+        }) : SlotAccess.a(entityliving, enumitemslot);
+    }
+
+    @Nullable
+    private static EnumItemSlot c(int i) {
+        return i == 100 + EnumItemSlot.HEAD.b() ? EnumItemSlot.HEAD : (i == 100 + EnumItemSlot.CHEST.b() ? EnumItemSlot.CHEST : (i == 100 + EnumItemSlot.LEGS.b() ? EnumItemSlot.LEGS : (i == 100 + EnumItemSlot.FEET.b() ? EnumItemSlot.FEET : (i == 98 ? EnumItemSlot.MAINHAND : (i == 99 ? EnumItemSlot.OFFHAND : null)))));
+    }
+
+    @Override
+    public SlotAccess k(int i) {
+        EnumItemSlot enumitemslot = c(i);
+
+        return enumitemslot != null ? a(this, enumitemslot) : super.k(i);
+    }
+
+    @Override
+    public boolean cV() {
+        return this.isSpectator() ? false : !this.getEquipment(EnumItemSlot.HEAD).a((Tag) TagsItem.FREEZE_IMMUNE_WEARABLES) && !this.getEquipment(EnumItemSlot.CHEST).a((Tag) TagsItem.FREEZE_IMMUNE_WEARABLES) && !this.getEquipment(EnumItemSlot.LEGS).a((Tag) TagsItem.FREEZE_IMMUNE_WEARABLES) && !this.getEquipment(EnumItemSlot.FEET).a((Tag) TagsItem.FREEZE_IMMUNE_WEARABLES);
+    }
+}
diff --git a/src/main/java/net/minecraft/server/EntityVillager.java b/src/main/java/net/minecraft/server/EntityVillager.java
new file mode 100644
index 00000000..633ed53a
--- /dev/null
+++ b/src/main/java/net/minecraft/server/EntityVillager.java
@@ -0,0 +1,960 @@
+package net.minecraft.server;
+
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.ImmutableSet;
+import com.mojang.datafixers.util.Pair;
+import com.mojang.serialization.DataResult;
+import com.mojang.serialization.Dynamic;
+import com.mojang.serialization.DynamicOps;
+import it.unimi.dsi.fastutil.ints.Int2ObjectMap;
+import java.util.Collection;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Optional;
+import java.util.Set;
+import java.util.function.BiPredicate;
+import java.util.stream.Collectors;
+import javax.annotation.Nullable;
+import org.apache.logging.log4j.Logger;
+// CraftBukkit start
+import org.bukkit.Bukkit;
+import org.bukkit.craftbukkit.event.CraftEventFactory;
+import org.bukkit.entity.Villager;
+import org.bukkit.event.entity.EntityTransformEvent;
+import org.bukkit.event.entity.VillagerReplenishTradeEvent;
+// CraftBukkit end
+
+public class EntityVillager extends EntityVillagerAbstract implements ReputationHandler, VillagerDataHolder {
+
+    private static final DataWatcherObject<VillagerData> bm = DataWatcher.a(EntityVillager.class, DataWatcherRegistry.q);
+    public static final Map<Item, Integer> bk = ImmutableMap.of(Items.BREAD, 4, Items.POTATO, 1, Items.CARROT, 1, Items.BEETROOT, 1);
+    private static final Set<Item> bn = ImmutableSet.of(Items.BREAD, Items.POTATO, Items.CARROT, Items.WHEAT, Items.WHEAT_SEEDS, Items.BEETROOT, new Item[]{Items.BEETROOT_SEEDS});
+    private int bo;
+    private boolean bp;
+    @Nullable
+    private EntityHuman bq;
+    private byte bs;
+    private final Reputation bt;
+    private long bu;
+    private long bv;
+    private int bw;
+    private long bx;
+    private int by;
+    private long bz;
+    private boolean bA;
+    private static final ImmutableList<MemoryModuleType<?>> bB = ImmutableList.of(MemoryModuleType.HOME, MemoryModuleType.JOB_SITE, MemoryModuleType.POTENTIAL_JOB_SITE, MemoryModuleType.MEETING_POINT, MemoryModuleType.MOBS, MemoryModuleType.VISIBLE_MOBS, MemoryModuleType.VISIBLE_VILLAGER_BABIES, MemoryModuleType.NEAREST_PLAYERS, MemoryModuleType.NEAREST_VISIBLE_PLAYER, MemoryModuleType.NEAREST_VISIBLE_TARGETABLE_PLAYER, MemoryModuleType.NEAREST_VISIBLE_WANTED_ITEM, MemoryModuleType.WALK_TARGET, new MemoryModuleType[]{MemoryModuleType.LOOK_TARGET, MemoryModuleType.INTERACTION_TARGET, MemoryModuleType.BREED_TARGET, MemoryModuleType.PATH, MemoryModuleType.DOORS_TO_CLOSE, MemoryModuleType.NEAREST_BED, MemoryModuleType.HURT_BY, MemoryModuleType.HURT_BY_ENTITY, MemoryModuleType.NEAREST_HOSTILE, MemoryModuleType.SECONDARY_JOB_SITE, MemoryModuleType.HIDING_PLACE, MemoryModuleType.HEARD_BELL_TIME, MemoryModuleType.CANT_REACH_WALK_TARGET_SINCE, MemoryModuleType.LAST_SLEPT, MemoryModuleType.LAST_WOKEN, MemoryModuleType.LAST_WORKED_AT_POI, MemoryModuleType.GOLEM_DETECTED_RECENTLY});
+    private static final ImmutableList<SensorType<? extends Sensor<? super EntityVillager>>> bC = ImmutableList.of(SensorType.c, SensorType.d, SensorType.b, SensorType.e, SensorType.f, SensorType.g, SensorType.h, SensorType.i, SensorType.j);
+    public static final Map<MemoryModuleType<GlobalPos>, BiPredicate<EntityVillager, PointOfInterestType>> bl = ImmutableMap.of(MemoryModuleType.HOME, (entityvillager, pointofinteresttype) -> {
+        return pointofinteresttype == PointOfInterestType.r;
+    }, MemoryModuleType.JOB_SITE, (entityvillager, pointofinteresttype) -> {
+        return entityvillager.getVillagerData().getProfession().b() == pointofinteresttype;
+    }, MemoryModuleType.POTENTIAL_JOB_SITE, (entityvillager, pointofinteresttype) -> {
+        return PointOfInterestType.a.test(pointofinteresttype);
+    }, MemoryModuleType.MEETING_POINT, (entityvillager, pointofinteresttype) -> {
+        return pointofinteresttype == PointOfInterestType.s;
+    });
+
+    public EntityVillager(EntityTypes<? extends EntityVillager> entitytypes, World world) {
+        this(entitytypes, world, VillagerType.PLAINS);
+    }
+
+    public EntityVillager(EntityTypes<? extends EntityVillager> entitytypes, World world, VillagerType villagertype) {
+        super(entitytypes, world);
+        this.bt = new Reputation();
+        ((Navigation) this.getNavigation()).a(true);
+        this.getNavigation().d(true);
+        this.setCanPickupLoot(true);
+        this.setVillagerData(this.getVillagerData().withType(villagertype).withProfession(VillagerProfession.NONE));
+    }
+
+    @Override
+    public BehaviorController<EntityVillager> getBehaviorController() {
+        return (BehaviorController<EntityVillager>) super.getBehaviorController(); // CraftBukkit - decompile error
+    }
+
+    @Override
+    protected BehaviorController.b<EntityVillager> dc() {
+        return BehaviorController.a((Collection) EntityVillager.bB, (Collection) EntityVillager.bC);
+    }
+
+    @Override
+    protected BehaviorController<?> a(Dynamic<?> dynamic) {
+        BehaviorController<EntityVillager> behaviorcontroller = this.dc().a(dynamic);
+
+        this.a(behaviorcontroller);
+        return behaviorcontroller;
+    }
+
+    public void c(WorldServer worldserver) {
+        BehaviorController<EntityVillager> behaviorcontroller = this.getBehaviorController();
+
+        behaviorcontroller.b(worldserver, this); // CraftBukkit - decompile error
+        this.bb = behaviorcontroller.h();
+        this.a(this.getBehaviorController());
+    }
+
+    private void a(BehaviorController<EntityVillager> behaviorcontroller) {
+        VillagerProfession villagerprofession = this.getVillagerData().getProfession();
+
+        if (this.isBaby()) {
+            behaviorcontroller.setSchedule(Schedule.VILLAGER_BABY);
+            behaviorcontroller.a(Activity.PLAY, Behaviors.a(0.5F));
+        } else {
+            behaviorcontroller.setSchedule(Schedule.VILLAGER_DEFAULT);
+            behaviorcontroller.a(Activity.WORK, Behaviors.b(villagerprofession, 0.5F), (Set) ImmutableSet.of(Pair.of(MemoryModuleType.JOB_SITE, MemoryStatus.VALUE_PRESENT)));
+        }
+
+        behaviorcontroller.a(Activity.CORE, Behaviors.a(villagerprofession, 0.5F));
+        behaviorcontroller.a(Activity.MEET, Behaviors.d(villagerprofession, 0.5F), (Set) ImmutableSet.of(Pair.of(MemoryModuleType.MEETING_POINT, MemoryStatus.VALUE_PRESENT)));
+        behaviorcontroller.a(Activity.REST, Behaviors.c(villagerprofession, 0.5F));
+        behaviorcontroller.a(Activity.IDLE, Behaviors.e(villagerprofession, 0.5F));
+        behaviorcontroller.a(Activity.PANIC, Behaviors.f(villagerprofession, 0.5F));
+        behaviorcontroller.a(Activity.PRE_RAID, Behaviors.g(villagerprofession, 0.5F));
+        behaviorcontroller.a(Activity.RAID, Behaviors.h(villagerprofession, 0.5F));
+        behaviorcontroller.a(Activity.HIDE, Behaviors.i(villagerprofession, 0.5F));
+        behaviorcontroller.a((Set) ImmutableSet.of(Activity.CORE));
+        behaviorcontroller.b(Activity.IDLE);
+        behaviorcontroller.a(Activity.IDLE);
+        behaviorcontroller.a(this.world.getDayTime(), this.world.getTime());
+    }
+
+    @Override
+    protected void m() {
+        super.m();
+        if (this.world instanceof WorldServer) {
+            this.c((WorldServer) this.world);
+        }
+
+    }
+
+    public static AttributeProvider.Builder ft() {
+        return EntityInsentient.p().a(GenericAttributes.MOVEMENT_SPEED, 0.5D).a(GenericAttributes.FOLLOW_RANGE, 48.0D);
+    }
+
+    public boolean fu() {
+        return this.bA;
+    }
+
+    // Spigot Start
+    @Override
+    public void inactiveTick() {
+        // SPIGOT-3874, SPIGOT-3894, SPIGOT-3846, SPIGOT-5286 :(
+        if (world.spigotConfig.tickInactiveVillagers && this.doAITick()) {
+            this.mobTick();
+        }
+        super.inactiveTick();
+    }
+    // Spigot End
+
+    @Override
+    protected void mobTick() {
+        this.world.getMethodProfiler().enter("villagerBrain");
+        this.getBehaviorController().a((WorldServer) this.world, this); // CraftBukkit - decompile error
+        this.world.getMethodProfiler().exit();
+        if (this.bA) {
+            this.bA = false;
+        }
+
+        if (!this.fi() && this.bo > 0) {
+            --this.bo;
+            if (this.bo <= 0) {
+                if (this.bp) {
+                    this.populateTrades();
+                    this.bp = false;
+                }
+
+                this.addEffect(new MobEffect(MobEffects.REGENERATION, 200, 0), org.bukkit.event.entity.EntityPotionEffectEvent.Cause.VILLAGER_TRADE); // CraftBukkit
+            }
+        }
+
+        if (this.bq != null && this.world instanceof WorldServer) {
+            ((WorldServer) this.world).a(ReputationEvent.e, (Entity) this.bq, (ReputationHandler) this);
+            this.world.broadcastEntityEffect(this, (byte) 14);
+            this.bq = null;
+        }
+
+        if (!this.isNoAI() && this.random.nextInt(100) == 0) {
+            Raid raid = ((WorldServer) this.world).b_(this.getChunkCoordinates());
+
+            if (raid != null && raid.v() && !raid.a()) {
+                this.world.broadcastEntityEffect(this, (byte) 42);
+            }
+        }
+
+        if (this.getVillagerData().getProfession() == VillagerProfession.NONE && this.fi()) {
+            this.fn();
+        }
+
+        super.mobTick();
+    }
+
+    @Override
+    public void tick() {
+        super.tick();
+        if (this.ff() > 0) {
+            this.t(this.ff() - 1);
+        }
+
+        this.fR();
+    }
+
+    @Override
+    public EnumInteractionResult b(EntityHuman entityhuman, EnumHand enumhand) {
+        ItemStack itemstack = entityhuman.b(enumhand);
+
+        if (!itemstack.a(Items.VILLAGER_SPAWN_EGG) && this.isAlive() && !this.fi() && !this.isSleeping()) {
+            if (this.isBaby()) {
+                this.fF();
+                return EnumInteractionResult.a(this.world.isClientSide);
+            } else {
+                boolean flag = this.getOffers().isEmpty();
+
+                if (enumhand == EnumHand.MAIN_HAND) {
+                    if (flag && !this.world.isClientSide) {
+                        this.fF();
+                    }
+
+                    entityhuman.a(StatisticList.TALKED_TO_VILLAGER);
+                }
+
+                if (flag) {
+                    return EnumInteractionResult.a(this.world.isClientSide);
+                } else {
+                    if (!this.world.isClientSide && !this.trades.isEmpty()) {
+                        this.h(entityhuman);
+                    }
+
+                    return EnumInteractionResult.a(this.world.isClientSide);
+                }
+            }
+        } else {
+            return super.b(entityhuman, enumhand);
+        }
+    }
+
+    private void fF() {
+        this.t(40);
+        if (!this.world.g()) {
+            this.playSound(SoundEffects.VILLAGER_NO, this.getSoundVolume(), this.ec());
+        }
+
+    }
+
+    private void h(EntityHuman entityhuman) {
+        this.i(entityhuman);
+        this.setTradingPlayer(entityhuman);
+        this.openTrade(entityhuman, this.getScoreboardDisplayName(), this.getVillagerData().getLevel());
+    }
+
+    @Override
+    public void setTradingPlayer(@Nullable EntityHuman entityhuman) {
+        boolean flag = this.getTrader() != null && entityhuman == null;
+
+        super.setTradingPlayer(entityhuman);
+        if (flag) {
+            this.fn();
+        }
+
+    }
+
+    @Override
+    protected void fn() {
+        super.fn();
+        this.fG();
+    }
+
+    private void fG() {
+        Iterator iterator = this.getOffers().iterator();
+
+        while (iterator.hasNext()) {
+            MerchantRecipe merchantrecipe = (MerchantRecipe) iterator.next();
+
+            merchantrecipe.setSpecialPrice();
+        }
+
+    }
+
+    @Override
+    public boolean fv() {
+        return true;
+    }
+
+    public void fw() {
+        this.fK();
+        Iterator iterator = this.getOffers().iterator();
+
+        while (iterator.hasNext()) {
+            MerchantRecipe merchantrecipe = (MerchantRecipe) iterator.next();
+
+            merchantrecipe.resetUses();
+        }
+
+        this.bx = this.world.getTime();
+        ++this.by;
+    }
+
+    private boolean fH() {
+        Iterator iterator = this.getOffers().iterator();
+
+        MerchantRecipe merchantrecipe;
+
+        do {
+            if (!iterator.hasNext()) {
+                return false;
+            }
+
+            merchantrecipe = (MerchantRecipe) iterator.next();
+        } while (!merchantrecipe.r());
+
+        return true;
+    }
+
+    private boolean fI() {
+        return this.by == 0 || this.by < 2 && this.world.getTime() > this.bx + 2400L;
+    }
+
+    public boolean fx() {
+        long i = this.bx + 12000L;
+        long j = this.world.getTime();
+        boolean flag = j > i;
+        long k = this.world.getDayTime();
+
+        if (this.bz > 0L) {
+            long l = this.bz / 24000L;
+            long i1 = k / 24000L;
+
+            flag |= i1 > l;
+        }
+
+        this.bz = k;
+        if (flag) {
+            this.bx = j;
+            this.fS();
+        }
+
+        return this.fI() && this.fH();
+    }
+
+    private void fJ() {
+        int i = 2 - this.by;
+
+        if (i > 0) {
+            Iterator iterator = this.getOffers().iterator();
+
+            while (iterator.hasNext()) {
+                MerchantRecipe merchantrecipe = (MerchantRecipe) iterator.next();
+
+                merchantrecipe.resetUses();
+            }
+        }
+
+        for (int j = 0; j < i; ++j) {
+            this.fK();
+        }
+
+    }
+
+    private void fK() {
+        Iterator iterator = this.getOffers().iterator();
+
+        while (iterator.hasNext()) {
+            MerchantRecipe merchantrecipe = (MerchantRecipe) iterator.next();
+
+            merchantrecipe.e();
+        }
+
+    }
+
+    private void i(EntityHuman entityhuman) {
+        int i = this.g(entityhuman);
+
+        if (i != 0) {
+            Iterator iterator = this.getOffers().iterator();
+
+            while (iterator.hasNext()) {
+                MerchantRecipe merchantrecipe = (MerchantRecipe) iterator.next();
+
+                // CraftBukkit start
+                int bonus = -MathHelper.d((float) i * merchantrecipe.getPriceMultiplier());
+                VillagerReplenishTradeEvent event = new VillagerReplenishTradeEvent((Villager) this.getBukkitEntity(), merchantrecipe.asBukkit(), bonus);
+                Bukkit.getPluginManager().callEvent(event);
+                if (!event.isCancelled()) {
+                    merchantrecipe.increaseSpecialPrice(event.getBonus());
+                }
+                // CraftBukkit end
+            }
+        }
+
+        if (entityhuman.hasEffect(MobEffects.HERO_OF_THE_VILLAGE)) {
+            MobEffect mobeffect = entityhuman.getEffect(MobEffects.HERO_OF_THE_VILLAGE);
+            int j = mobeffect.getAmplifier();
+            Iterator iterator1 = this.getOffers().iterator();
+
+            while (iterator1.hasNext()) {
+                MerchantRecipe merchantrecipe1 = (MerchantRecipe) iterator1.next();
+                double d0 = 0.3D + 0.0625D * (double) j;
+                int k = (int) Math.floor(d0 * (double) merchantrecipe1.a().getCount());
+
+                merchantrecipe1.increaseSpecialPrice(-Math.max(k, 1));
+            }
+        }
+
+    }
+
+    @Override
+    protected void initDatawatcher() {
+        super.initDatawatcher();
+        this.datawatcher.register(EntityVillager.bm, new VillagerData(VillagerType.PLAINS, VillagerProfession.NONE, 1));
+    }
+
+    @Override
+    public void saveData(NBTTagCompound nbttagcompound) {
+        super.saveData(nbttagcompound);
+        DataResult<NBTBase> dataresult = VillagerData.a.encodeStart(DynamicOpsNBT.a, this.getVillagerData()); // CraftBukkit - decompile error
+        Logger logger = EntityVillager.LOGGER;
+
+        logger.getClass();
+        dataresult.resultOrPartial(logger::error).ifPresent((nbtbase) -> {
+            nbttagcompound.set("VillagerData", nbtbase);
+        });
+        nbttagcompound.setByte("FoodLevel", this.bs);
+        nbttagcompound.set("Gossips", (NBTBase) this.bt.a((DynamicOps) DynamicOpsNBT.a).getValue());
+        nbttagcompound.setInt("Xp", this.bw);
+        nbttagcompound.setLong("LastRestock", this.bx);
+        nbttagcompound.setLong("LastGossipDecay", this.bv);
+        nbttagcompound.setInt("RestocksToday", this.by);
+        if (this.bA) {
+            nbttagcompound.setBoolean("AssignProfessionWhenSpawned", true);
+        }
+
+    }
+
+    @Override
+    public void loadData(NBTTagCompound nbttagcompound) {
+        super.loadData(nbttagcompound);
+        if (nbttagcompound.hasKeyOfType("VillagerData", 10)) {
+            DataResult<VillagerData> dataresult = VillagerData.a.parse(new Dynamic(DynamicOpsNBT.a, nbttagcompound.get("VillagerData")));
+            Logger logger = EntityVillager.LOGGER;
+
+            logger.getClass();
+            dataresult.resultOrPartial(logger::error).ifPresent(this::setVillagerData);
+        }
+
+        if (nbttagcompound.hasKeyOfType("Offers", 10)) {
+            this.trades = new MerchantRecipeList(nbttagcompound.getCompound("Offers"));
+        }
+
+        if (nbttagcompound.hasKeyOfType("FoodLevel", 1)) {
+            this.bs = nbttagcompound.getByte("FoodLevel");
+        }
+
+        NBTTagList nbttaglist = nbttagcompound.getList("Gossips", 10);
+
+        this.bt.a(new Dynamic(DynamicOpsNBT.a, nbttaglist));
+        if (nbttagcompound.hasKeyOfType("Xp", 3)) {
+            this.bw = nbttagcompound.getInt("Xp");
+        }
+
+        this.bx = nbttagcompound.getLong("LastRestock");
+        this.bv = nbttagcompound.getLong("LastGossipDecay");
+        this.setCanPickupLoot(true);
+        if (this.world instanceof WorldServer) {
+            this.c((WorldServer) this.world);
+        }
+
+        this.by = nbttagcompound.getInt("RestocksToday");
+        if (nbttagcompound.hasKey("AssignProfessionWhenSpawned")) {
+            this.bA = nbttagcompound.getBoolean("AssignProfessionWhenSpawned");
+        }
+
+    }
+
+    @Override
+    public boolean isTypeNotPersistent(double d0) {
+        return false;
+    }
+
+    @Nullable
+    @Override
+    protected SoundEffect getSoundAmbient() {
+        return this.isSleeping() ? null : (this.fi() ? SoundEffects.VILLAGER_TRADE : SoundEffects.VILLAGER_AMBIENT);
+    }
+
+    @Override
+    protected SoundEffect getSoundHurt(DamageSource damagesource) {
+        return SoundEffects.VILLAGER_HURT;
+    }
+
+    @Override
+    protected SoundEffect getSoundDeath() {
+        return SoundEffects.VILLAGER_DEATH;
+    }
+
+    public void fy() {
+        SoundEffect soundeffect = this.getVillagerData().getProfession().e();
+
+        if (soundeffect != null) {
+            this.playSound(soundeffect, this.getSoundVolume(), this.ec());
+        }
+
+    }
+
+    public void setVillagerData(VillagerData villagerdata) {
+        VillagerData villagerdata1 = this.getVillagerData();
+
+        if (villagerdata1.getProfession() != villagerdata.getProfession()) {
+            this.trades = null;
+        }
+
+        this.datawatcher.set(EntityVillager.bm, villagerdata);
+    }
+
+    @Override
+    public VillagerData getVillagerData() {
+        return (VillagerData) this.datawatcher.get(EntityVillager.bm);
+    }
+
+    @Override
+    protected void b(MerchantRecipe merchantrecipe) {
+        int i = 3 + this.random.nextInt(4);
+
+        this.bw += merchantrecipe.getXp();
+        this.bq = this.getTrader();
+        if (this.fO()) {
+            this.bo = 40;
+            this.bp = true;
+            i += 5;
+        }
+
+        if (merchantrecipe.isRewardExp()) {
+            this.world.addEntity(new EntityExperienceOrb(this.world, this.locX(), this.locY() + 0.5D, this.locZ(), i));
+        }
+
+    }
+
+    @Override
+    public void setLastDamager(@Nullable EntityLiving entityliving) {
+        if (entityliving != null && this.world instanceof WorldServer) {
+            ((WorldServer) this.world).a(ReputationEvent.c, (Entity) entityliving, (ReputationHandler) this);
+            if (this.isAlive() && entityliving instanceof EntityHuman) {
+                this.world.broadcastEntityEffect(this, (byte) 13);
+            }
+        }
+
+        super.setLastDamager(entityliving);
+    }
+
+    @Override
+    public void die(DamageSource damagesource) {
+        EntityVillager.LOGGER.info("Villager {} died, message: '{}'", this, damagesource.getLocalizedDeathMessage(this).getString());
+        Entity entity = damagesource.getEntity();
+
+        if (entity != null) {
+            this.a(entity);
+        }
+
+        this.fL();
+        super.die(damagesource);
+    }
+
+    private void fL() {
+        this.a(MemoryModuleType.HOME);
+        this.a(MemoryModuleType.JOB_SITE);
+        this.a(MemoryModuleType.POTENTIAL_JOB_SITE);
+        this.a(MemoryModuleType.MEETING_POINT);
+    }
+
+    private void a(Entity entity) {
+        if (this.world instanceof WorldServer) {
+            Optional<List<EntityLiving>> optional = this.bb.getMemory(MemoryModuleType.VISIBLE_MOBS);
+
+            if (optional.isPresent()) {
+                WorldServer worldserver = (WorldServer) this.world;
+
+                ((List) optional.get()).stream().filter((entityliving) -> {
+                    return entityliving instanceof ReputationHandler;
+                }).forEach((entityliving) -> {
+                    worldserver.a(ReputationEvent.d, entity, (ReputationHandler) entityliving);
+                });
+            }
+        }
+    }
+
+    public void a(MemoryModuleType<GlobalPos> memorymoduletype) {
+        if (this.world instanceof WorldServer) {
+            MinecraftServer minecraftserver = ((WorldServer) this.world).getMinecraftServer();
+
+            this.bb.getMemory(memorymoduletype).ifPresent((globalpos) -> {
+                WorldServer worldserver = minecraftserver.getWorldServer(globalpos.getDimensionManager());
+
+                if (worldserver != null) {
+                    VillagePlace villageplace = worldserver.A();
+                    Optional<PointOfInterestType> optional = villageplace.c(globalpos.getBlockPosition());
+                    BiPredicate<EntityVillager, PointOfInterestType> bipredicate = (BiPredicate) EntityVillager.bl.get(memorymoduletype);
+
+                    if (optional.isPresent() && bipredicate.test(this, optional.get())) {
+                        villageplace.b(globalpos.getBlockPosition());
+                        PacketDebug.c(worldserver, globalpos.getBlockPosition());
+                    }
+
+                }
+            });
+        }
+    }
+
+    @Override
+    public boolean canBreed() {
+        return this.bs + this.fQ() >= 12 && this.getAge() == 0;
+    }
+
+    private boolean fM() {
+        return this.bs < 12;
+    }
+
+    private void fN() {
+        if (this.fM() && this.fQ() != 0) {
+            for (int i = 0; i < this.getInventory().getSize(); ++i) {
+                ItemStack itemstack = this.getInventory().getItem(i);
+
+                if (!itemstack.isEmpty()) {
+                    Integer integer = (Integer) EntityVillager.bk.get(itemstack.getItem());
+
+                    if (integer != null) {
+                        int j = itemstack.getCount();
+
+                        for (int k = j; k > 0; --k) {
+                            this.bs = (byte) (this.bs + integer);
+                            this.getInventory().splitStack(i, 1);
+                            if (!this.fM()) {
+                                return;
+                            }
+                        }
+                    }
+                }
+            }
+
+        }
+    }
+
+    public int g(EntityHuman entityhuman) {
+        return this.bt.a(entityhuman.getUniqueID(), (reputationtype) -> {
+            return true;
+        });
+    }
+
+    private void w(int i) {
+        this.bs = (byte) (this.bs - i);
+    }
+
+    public void fA() {
+        this.fN();
+        this.w(12);
+    }
+
+    public void b(MerchantRecipeList merchantrecipelist) {
+        this.trades = merchantrecipelist;
+    }
+
+    private boolean fO() {
+        int i = this.getVillagerData().getLevel();
+
+        return VillagerData.d(i) && this.bw >= VillagerData.c(i);
+    }
+
+    public void populateTrades() {
+        this.setVillagerData(this.getVillagerData().withLevel(this.getVillagerData().getLevel() + 1));
+        this.fq();
+    }
+
+    @Override
+    protected IChatBaseComponent bQ() {
+        return new ChatMessage(this.getEntityType().g() + '.' + IRegistry.VILLAGER_PROFESSION.getKey(this.getVillagerData().getProfession()).getKey());
+    }
+
+    @Nullable
+    @Override
+    public GroupDataEntity prepare(WorldAccess worldaccess, DifficultyDamageScaler difficultydamagescaler, EnumMobSpawn enummobspawn, @Nullable GroupDataEntity groupdataentity, @Nullable NBTTagCompound nbttagcompound) {
+        if (enummobspawn == EnumMobSpawn.BREEDING) {
+            this.setVillagerData(this.getVillagerData().withProfession(VillagerProfession.NONE));
+        }
+
+        if (enummobspawn == EnumMobSpawn.COMMAND || enummobspawn == EnumMobSpawn.SPAWN_EGG || enummobspawn == EnumMobSpawn.SPAWNER || enummobspawn == EnumMobSpawn.DISPENSER) {
+            this.setVillagerData(this.getVillagerData().withType(VillagerType.a(worldaccess.h(this.getChunkCoordinates()))));
+        }
+
+        if (enummobspawn == EnumMobSpawn.STRUCTURE) {
+            this.bA = true;
+        }
+
+        return super.prepare(worldaccess, difficultydamagescaler, enummobspawn, groupdataentity, nbttagcompound);
+    }
+
+    @Override
+    public EntityVillager createChild(WorldServer worldserver, EntityAgeable entityageable) {
+        double d0 = this.random.nextDouble();
+        VillagerType villagertype;
+
+        if (d0 < 0.5D) {
+            villagertype = VillagerType.a(worldserver.h(this.getChunkCoordinates()));
+        } else if (d0 < 0.75D) {
+            villagertype = this.getVillagerData().getType();
+        } else {
+            villagertype = ((EntityVillager) entityageable).getVillagerData().getType();
+        }
+
+        EntityVillager entityvillager = new EntityVillager(EntityTypes.VILLAGER, worldserver, villagertype);
+
+        entityvillager.prepare(worldserver, worldserver.getDamageScaler(entityvillager.getChunkCoordinates()), EnumMobSpawn.BREEDING, (GroupDataEntity) null, (NBTTagCompound) null);
+        return entityvillager;
+    }
+
+    @Override
+    public void onLightningStrike(WorldServer worldserver, EntityLightning entitylightning) {
+        if (worldserver.getDifficulty() != EnumDifficulty.PEACEFUL) {
+            EntityVillager.LOGGER.info("Villager {} was struck by lightning {}.", this, entitylightning);
+            EntityWitch entitywitch = (EntityWitch) EntityTypes.WITCH.a((World) worldserver);
+
+            entitywitch.setPositionRotation(this.locX(), this.locY(), this.locZ(), this.yaw, this.pitch);
+            entitywitch.prepare(worldserver, worldserver.getDamageScaler(entitywitch.getChunkCoordinates()), EnumMobSpawn.CONVERSION, (GroupDataEntity) null, (NBTTagCompound) null);
+            entitywitch.setNoAI(this.isNoAI());
+            if (this.hasCustomName()) {
+                entitywitch.setCustomName(this.getCustomName());
+                entitywitch.setCustomNameVisible(this.getCustomNameVisible());
+            }
+
+            entitywitch.setPersistent();
+            // CraftBukkit start
+            if (CraftEventFactory.callEntityTransformEvent(this, entitywitch, EntityTransformEvent.TransformReason.LIGHTNING).isCancelled()) {
+                return;
+            }
+            worldserver.addAllEntities(entitywitch, org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason.LIGHTNING);
+            // CraftBukkit end
+            this.fL();
+            this.ab();
+        } else {
+            super.onLightningStrike(worldserver, entitylightning);
+        }
+
+    }
+
+    @Override
+    protected void b(EntityItem entityitem) {
+        ItemStack itemstack = entityitem.getItemStack();
+
+        if (this.j(itemstack)) {
+            InventorySubcontainer inventorysubcontainer = this.getInventory();
+            boolean flag = inventorysubcontainer.b(itemstack);
+
+            if (!flag) {
+                return;
+            }
+
+            this.a(entityitem);
+            this.receive(entityitem, itemstack.getCount());
+            ItemStack itemstack1 = inventorysubcontainer.a(itemstack);
+
+            if (itemstack1.isEmpty()) {
+                entityitem.ab();
+            } else {
+                itemstack.setCount(itemstack1.getCount());
+            }
+        }
+
+    }
+
+    @Override
+    public boolean j(ItemStack itemstack) {
+        Item item = itemstack.getItem();
+
+        return (EntityVillager.bn.contains(item) || this.getVillagerData().getProfession().c().contains(item)) && this.getInventory().b(itemstack);
+    }
+
+    public boolean fB() {
+        return this.fQ() >= 24;
+    }
+
+    public boolean fC() {
+        return this.fQ() < 12;
+    }
+
+    private int fQ() {
+        InventorySubcontainer inventorysubcontainer = this.getInventory();
+
+        return EntityVillager.bk.entrySet().stream().mapToInt((entry) -> {
+            return inventorysubcontainer.a((Item) entry.getKey()) * (Integer) entry.getValue();
+        }).sum();
+    }
+
+    public boolean canPlant() {
+        return this.getInventory().a((Set) ImmutableSet.of(Items.WHEAT_SEEDS, Items.POTATO, Items.CARROT, Items.BEETROOT_SEEDS));
+    }
+
+    @Override
+    protected void fq() {
+        VillagerData villagerdata = this.getVillagerData();
+        Int2ObjectMap<VillagerTrades.IMerchantRecipeOption[]> int2objectmap = (Int2ObjectMap) VillagerTrades.a.get(villagerdata.getProfession());
+
+        if (int2objectmap != null && !int2objectmap.isEmpty()) {
+            VillagerTrades.IMerchantRecipeOption[] avillagertrades_imerchantrecipeoption = (VillagerTrades.IMerchantRecipeOption[]) int2objectmap.get(villagerdata.getLevel());
+
+            if (avillagertrades_imerchantrecipeoption != null) {
+                MerchantRecipeList merchantrecipelist = this.getOffers();
+
+                this.a(merchantrecipelist, avillagertrades_imerchantrecipeoption, 2);
+            }
+        }
+    }
+
+    public void a(WorldServer worldserver, EntityVillager entityvillager, long i) {
+        if ((i < this.bu || i >= this.bu + 1200L) && (i < entityvillager.bu || i >= entityvillager.bu + 1200L)) {
+            this.bt.a(entityvillager.bt, this.random, 10);
+            this.bu = i;
+            entityvillager.bu = i;
+            this.a(worldserver, i, 5);
+        }
+    }
+
+    private void fR() {
+        long i = this.world.getTime();
+
+        if (this.bv == 0L) {
+            this.bv = i;
+        } else if (i >= this.bv + 24000L) {
+            this.bt.b();
+            this.bv = i;
+        }
+    }
+
+    public void a(WorldServer worldserver, long i, int j) {
+        if (this.a(i)) {
+            AxisAlignedBB axisalignedbb = this.getBoundingBox().grow(10.0D, 10.0D, 10.0D);
+            List<EntityVillager> list = worldserver.a(EntityVillager.class, axisalignedbb);
+            List<EntityVillager> list1 = (List) list.stream().filter((entityvillager) -> {
+                return entityvillager.a(i);
+            }).limit(5L).collect(Collectors.toList());
+
+            if (list1.size() >= j) {
+                EntityIronGolem entityirongolem = this.d(worldserver);
+
+                if (entityirongolem != null) {
+                    list.forEach(SensorGolemLastSeen::b);
+                }
+            }
+        }
+    }
+
+    public boolean a(long i) {
+        return !this.b(this.world.getTime()) ? false : !this.bb.hasMemory(MemoryModuleType.GOLEM_DETECTED_RECENTLY);
+    }
+
+    @Nullable
+    private EntityIronGolem d(WorldServer worldserver) {
+        BlockPosition blockposition = this.getChunkCoordinates();
+
+        for (int i = 0; i < 10; ++i) {
+            double d0 = (double) (worldserver.random.nextInt(16) - 8);
+            double d1 = (double) (worldserver.random.nextInt(16) - 8);
+            BlockPosition blockposition1 = this.a(blockposition, d0, d1);
+
+            if (blockposition1 != null) {
+                EntityIronGolem entityirongolem = (EntityIronGolem) EntityTypes.IRON_GOLEM.createCreature(worldserver, (NBTTagCompound) null, (IChatBaseComponent) null, (EntityHuman) null, blockposition1, EnumMobSpawn.MOB_SUMMONED, false, false);
+
+                if (entityirongolem != null) {
+                    if (entityirongolem.a((GeneratorAccess) worldserver, EnumMobSpawn.MOB_SUMMONED) && entityirongolem.a((IWorldReader) worldserver)) {
+                        worldserver.addAllEntities(entityirongolem, org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason.VILLAGE_DEFENSE); // CraftBukkit
+                        return entityirongolem;
+                    }
+
+                    entityirongolem.ab();
+                }
+            }
+        }
+
+        return null;
+    }
+
+    @Nullable
+    private BlockPosition a(BlockPosition blockposition, double d0, double d1) {
+        boolean flag = true;
+        BlockPosition blockposition1 = blockposition.a(d0, 6.0D, d1);
+        IBlockData iblockdata = this.world.getType(blockposition1);
+
+        for (int i = 6; i >= -6; --i) {
+            BlockPosition blockposition2 = blockposition1;
+            IBlockData iblockdata1 = iblockdata;
+
+            blockposition1 = blockposition1.down();
+            iblockdata = this.world.getType(blockposition1);
+            if ((iblockdata1.isAir() || iblockdata1.getMaterial().isLiquid()) && iblockdata.getMaterial().f()) {
+                return blockposition2;
+            }
+        }
+
+        return null;
+    }
+
+    @Override
+    public void a(ReputationEvent reputationevent, Entity entity) {
+        if (reputationevent == ReputationEvent.a) {
+            this.bt.a(entity.getUniqueID(), ReputationType.MAJOR_POSITIVE, 20);
+            this.bt.a(entity.getUniqueID(), ReputationType.MINOR_POSITIVE, 25);
+        } else if (reputationevent == ReputationEvent.e) {
+            this.bt.a(entity.getUniqueID(), ReputationType.TRADING, 2);
+        } else if (reputationevent == ReputationEvent.c) {
+            this.bt.a(entity.getUniqueID(), ReputationType.MINOR_NEGATIVE, 25);
+        } else if (reputationevent == ReputationEvent.d) {
+            this.bt.a(entity.getUniqueID(), ReputationType.MAJOR_NEGATIVE, 25);
+        }
+
+    }
+
+    @Override
+    public int getExperience() {
+        return this.bw;
+    }
+
+    public void setExperience(int i) {
+        this.bw = i;
+    }
+
+    private void fS() {
+        this.fJ();
+        this.by = 0;
+    }
+
+    public Reputation fE() {
+        return this.bt;
+    }
+
+    public void a(NBTBase nbtbase) {
+        this.bt.a(new Dynamic(DynamicOpsNBT.a, nbtbase));
+    }
+
+    @Override
+    protected void M() {
+        super.M();
+        PacketDebug.a((EntityLiving) this);
+    }
+
+    @Override
+    public void entitySleep(BlockPosition blockposition) {
+        super.entitySleep(blockposition);
+        this.bb.setMemory(MemoryModuleType.LAST_SLEPT, this.world.getTime()); // CraftBukkit - decompile error
+        this.bb.removeMemory(MemoryModuleType.WALK_TARGET);
+        this.bb.removeMemory(MemoryModuleType.CANT_REACH_WALK_TARGET_SINCE);
+    }
+
+    @Override
+    public void entityWakeup() {
+        super.entityWakeup();
+        this.bb.setMemory(MemoryModuleType.LAST_WOKEN, this.world.getTime()); // CraftBukkit - decompile error
+    }
+
+    private boolean b(long i) {
+        Optional<Long> optional = this.bb.getMemory(MemoryModuleType.LAST_SLEPT);
+
+        return optional.isPresent() ? i - (Long) optional.get() < 24000L : false;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/WorldServer.java b/src/main/java/net/minecraft/server/WorldServer.java
new file mode 100644
index 00000000..41cace2f
--- /dev/null
+++ b/src/main/java/net/minecraft/server/WorldServer.java
@@ -0,0 +1,1786 @@
+package net.minecraft.server;
+
+import com.google.common.annotations.VisibleForTesting;
+import com.google.common.collect.Lists;
+import com.mojang.datafixers.DataFixer;
+import it.unimi.dsi.fastutil.ints.Int2ObjectMap;
+import it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap;
+import it.unimi.dsi.fastutil.longs.LongSet;
+import it.unimi.dsi.fastutil.longs.LongSets;
+import it.unimi.dsi.fastutil.objects.Object2IntMap.Entry;
+import it.unimi.dsi.fastutil.objects.Object2IntOpenHashMap;
+import it.unimi.dsi.fastutil.objects.ObjectIterator;
+import it.unimi.dsi.fastutil.objects.ObjectLinkedOpenHashSet;
+import it.unimi.dsi.fastutil.objects.ObjectOpenHashSet;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import org.bukkit.Bukkit;
+import org.bukkit.WeatherType;
+import org.bukkit.craftbukkit.event.CraftEventFactory;
+import org.bukkit.craftbukkit.util.WorldUUID;
+import org.bukkit.event.entity.CreatureSpawnEvent;
+import org.bukkit.event.server.MapInitializeEvent;
+import org.bukkit.event.weather.LightningStrikeEvent;
+import org.bukkit.event.world.TimeSkipEvent;
+
+import javax.annotation.Nonnull;
+import javax.annotation.Nullable;
+import java.io.BufferedWriter;
+import java.io.File;
+import java.io.IOException;
+import java.io.Writer;
+import java.nio.file.Files;
+import java.util.Comparator;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Objects;
+import java.util.Optional;
+import java.util.Set;
+import java.util.UUID;
+import java.util.concurrent.Executor;
+import java.util.function.BooleanSupplier;
+import java.util.function.Function;
+import java.util.function.Predicate;
+import java.util.logging.Level;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+// CraftBukkit end
+
+public class WorldServer extends World implements GeneratorAccessSeed {
+
+    public static final BlockPosition a = new BlockPosition(100, 50, 0);
+    private static final Logger LOGGER = LogManager.getLogger();
+    private final List<EntityPlayer> players = Lists.newArrayList();
+    private final ChunkProviderServer chunkProvider;
+    private final MinecraftServer server;
+    public final WorldDataServer worldDataServer; // CraftBukkit - type
+    private final EntityTickList x = new EntityTickList();
+    private final PersistentEntitySectionManager<Entity> y;
+    public boolean savingDisabled;
+    private float percentageSleepingPlayers;
+    private int emptyTime;
+    private final PortalTravelAgent portalTravelAgent;
+    private final TickListServer<Block> nextTickListBlock;
+    private final TickListServer<FluidType> nextTickListFluid;
+    private final Set<EntityInsentient> navigators;
+    protected final PersistentRaid persistentRaid;
+    private final ObjectLinkedOpenHashSet<BlockActionData> F;
+    private boolean ticking;
+    private final List<MobSpawner> mobSpawners;
+    @Nullable
+    private final EnderDragonBattle dragonBattle;
+    private final Int2ObjectMap<EntityComplexPart> J;
+    private final StructureManager structureManager;
+    private final boolean L;
+
+
+    // CraftBukkit start
+    private int tickPosition;
+    public final Convertable.ConversionSession convertable;
+    public final UUID uuid;
+
+    public Chunk getChunkIfLoaded(int x, int z) {
+        return this.chunkProvider.getChunkAt(x, z, false);
+    }
+
+    // Add env and gen to constructor, WorldData -> WorldDataServer
+    public WorldServer(MinecraftServer minecraftserver, Executor executor, Convertable.ConversionSession convertable_conversionsession, IWorldDataServer iworlddataserver, ResourceKey<World> resourcekey, DimensionManager dimensionmanager, WorldLoadListener worldloadlistener, ChunkGenerator chunkgenerator, boolean flag, long i, List<MobSpawner> list, boolean flag1, org.bukkit.World.Environment env, org.bukkit.generator.ChunkGenerator gen) {
+        super(iworlddataserver, resourcekey, dimensionmanager, minecraftserver::getMethodProfiler, false, flag, i, gen, env);
+        this.pvpMode = minecraftserver.getPVP();
+        convertable = convertable_conversionsession;
+        uuid = WorldUUID.getUUID(convertable_conversionsession.folder.toFile());
+        // CraftBukkit end
+        this.nextTickListBlock = new TickListServer<>(this, (block) -> {
+            return block == null || block.getBlockData().isAir();
+        }, IRegistry.BLOCK::getKey, this::b);
+        this.nextTickListFluid = new TickListServer<>(this, (fluidtype) -> {
+            return fluidtype == null || fluidtype == FluidTypes.EMPTY;
+        }, IRegistry.FLUID::getKey, this::a);
+        this.navigators = new ObjectOpenHashSet();
+        this.F = new ObjectLinkedOpenHashSet();
+        this.J = new Int2ObjectOpenHashMap();
+        this.L = flag1;
+        this.server = minecraftserver;
+        this.mobSpawners = list;
+        // CraftBukkit start
+        this.worldDataServer = (WorldDataServer) iworlddataserver;
+        worldDataServer.world = this;
+        if (gen != null) {
+            chunkgenerator = new org.bukkit.craftbukkit.generator.CustomChunkGenerator(this, chunkgenerator, gen);
+        }
+        // CraftBukkit end
+
+        boolean flag2 = minecraftserver.isSyncChunkWrites();
+        DataFixer datafixer = minecraftserver.getDataFixer();
+        EntityPersistentStorage<Entity> entitypersistentstorage = new EntityStorage(this, new File(convertable_conversionsession.a(resourcekey), "entities"), datafixer, flag2, minecraftserver);
+
+        this.y = new PersistentEntitySectionManager<>(Entity.class, new a(), entitypersistentstorage);
+        DefinedStructureManager definedstructuremanager = minecraftserver.getDefinedStructureManager();
+        int j = this.spigotConfig.viewDistance; // Spigot
+        PersistentEntitySectionManager persistententitysectionmanager = this.y;
+
+        this.y.getClass();
+        this.chunkProvider = new ChunkProviderServer(this, convertable_conversionsession, datafixer, definedstructuremanager, executor, chunkgenerator, j, flag2, worldloadlistener, persistententitysectionmanager::a, () -> {
+            return minecraftserver.E().getWorldPersistentData();
+        });
+        this.portalTravelAgent = new PortalTravelAgent(this);
+        this.S();
+        this.T();
+        this.getWorldBorder().a(minecraftserver.as());
+        this.persistentRaid = (PersistentRaid) this.getWorldPersistentData().a((nbttagcompound) -> {
+            return PersistentRaid.a(this, nbttagcompound);
+        }, () -> {
+            return new PersistentRaid(this);
+        }, PersistentRaid.a(this.getDimensionManager()));
+        if (!minecraftserver.isEmbeddedServer()) {
+            iworlddataserver.setGameType(minecraftserver.getGamemode());
+        }
+
+        this.structureManager = new StructureManager(this, this.worldDataServer.getGeneratorSettings()); // CraftBukkit
+        if (this.getDimensionManager().isCreateDragonBattle()) {
+            this.dragonBattle = new EnderDragonBattle(this, this.worldDataServer.getGeneratorSettings().getSeed(), this.worldDataServer.C()); // CraftBukkit
+        } else {
+            this.dragonBattle = null;
+        }
+        this.getServer().addWorld(this.getWorld()); // CraftBukkit
+    }
+
+    // CraftBukkit start
+    @Override
+    protected TileEntity getTileEntity(BlockPosition pos, boolean validate) {
+        TileEntity result = super.getTileEntity(pos, validate);
+        if (!validate || Thread.currentThread() != this.serverThread) {
+            // SPIGOT-5378: avoid deadlock, this can be called in loading logic (i.e lighting) but getType() will block on chunk load
+            return result;
+        }
+        Block type = getType(pos).getBlock();
+
+        if (result != null && type != Blocks.AIR) {
+            if (!result.getTileType().isValidBlock(type.getBlockData())) {
+                result = fixTileEntity(pos, type, result);
+            }
+        }
+
+        return result;
+    }
+
+    private TileEntity fixTileEntity(BlockPosition pos, Block type, TileEntity found) {
+        this.getServer().getLogger().log(Level.SEVERE, "Block at {0}, {1}, {2} is {3} but has {4}" + ". "
+                + "Bukkit will attempt to fix this, but there may be additional damage that we cannot recover.", new Object[]{pos.getX(), pos.getY(), pos.getZ(), type, found});
+
+        if (type instanceof ITileEntity) {
+            TileEntity replacement = ((ITileEntity) type).createTile(pos, type.getBlockData());
+            replacement.world = this;
+            this.setTileEntity(pos, replacement);
+            return replacement;
+        } else {
+            return found;
+        }
+    }
+    // CraftBukkit end
+
+    public void a(int i, int j, boolean flag, boolean flag1) {
+        this.worldDataServer.a(i);
+        this.worldDataServer.setWeatherDuration(j);
+        this.worldDataServer.setThunderDuration(j);
+        this.worldDataServer.setStorm(flag);
+        this.worldDataServer.setThundering(flag1);
+    }
+
+    @Override
+    public BiomeBase a(int i, int j, int k) {
+        return this.getChunkProvider().getChunkGenerator().getWorldChunkManager().getBiome(i, j, k);
+    }
+
+    public StructureManager getStructureManager() {
+        return this.structureManager;
+    }
+
+    public void doTick(BooleanSupplier booleansupplier) {
+        GameProfilerFiller gameprofilerfiller = this.getMethodProfiler();
+
+        this.ticking = true;
+        gameprofilerfiller.enter("world border");
+        this.getWorldBorder().s();
+        gameprofilerfiller.exitEnter("weather");
+        boolean flag = this.isRaining();
+        int i;
+
+        if (this.getDimensionManager().hasSkyLight()) {
+            if (this.getGameRules().getBoolean(GameRules.DO_WEATHER_CYCLE)) {
+                i = this.worldDataServer.h();
+                int j = this.worldDataServer.getThunderDuration();
+                int k = this.worldDataServer.getWeatherDuration();
+                boolean flag1 = this.worldData.isThundering();
+                boolean flag2 = this.worldData.hasStorm();
+
+                if (i > 0) {
+                    --i;
+                    j = flag1 ? 0 : 1;
+                    k = flag2 ? 0 : 1;
+                    flag1 = false;
+                    flag2 = false;
+                } else {
+                    if (j > 0) {
+                        --j;
+                        if (j == 0) {
+                            flag1 = !flag1;
+                        }
+                    } else if (flag1) {
+                        j = this.random.nextInt(12000) + 3600;
+                    } else {
+                        j = this.random.nextInt(168000) + 12000;
+                    }
+
+                    if (k > 0) {
+                        --k;
+                        if (k == 0) {
+                            flag2 = !flag2;
+                        }
+                    } else if (flag2) {
+                        k = this.random.nextInt(12000) + 12000;
+                    } else {
+                        k = this.random.nextInt(168000) + 12000;
+                    }
+                }
+
+                this.worldDataServer.setThunderDuration(j);
+                this.worldDataServer.setWeatherDuration(k);
+                this.worldDataServer.a(i);
+                this.worldDataServer.setThundering(flag1);
+                this.worldDataServer.setStorm(flag2);
+            }
+
+            this.lastThunderLevel = this.thunderLevel;
+            if (this.worldData.isThundering()) {
+                this.thunderLevel = (float) ((double) this.thunderLevel + 0.01D);
+            } else {
+                this.thunderLevel = (float) ((double) this.thunderLevel - 0.01D);
+            }
+
+            this.thunderLevel = MathHelper.a(this.thunderLevel, 0.0F, 1.0F);
+            this.lastRainLevel = this.rainLevel;
+            if (this.worldData.hasStorm()) {
+                this.rainLevel = (float) ((double) this.rainLevel + 0.01D);
+            } else {
+                this.rainLevel = (float) ((double) this.rainLevel - 0.01D);
+            }
+
+            this.rainLevel = MathHelper.a(this.rainLevel, 0.0F, 1.0F);
+        }
+
+        /* CraftBukkit start
+        if (this.lastRainLevel != this.rainLevel) {
+            this.server.getPlayerList().a((Packet) (new PacketPlayOutGameStateChange(PacketPlayOutGameStateChange.h, this.rainLevel)), this.getDimensionKey());
+        }
+
+        if (this.lastThunderLevel != this.thunderLevel) {
+            this.server.getPlayerList().a((Packet) (new PacketPlayOutGameStateChange(PacketPlayOutGameStateChange.i, this.thunderLevel)), this.getDimensionKey());
+        }
+
+        if (flag != this.isRaining()) {
+            if (flag) {
+                this.server.getPlayerList().sendAll(new PacketPlayOutGameStateChange(PacketPlayOutGameStateChange.c, 0.0F));
+            } else {
+                this.server.getPlayerList().sendAll(new PacketPlayOutGameStateChange(PacketPlayOutGameStateChange.b, 0.0F));
+            }
+
+            this.server.getPlayerList().sendAll(new PacketPlayOutGameStateChange(PacketPlayOutGameStateChange.h, this.rainLevel));
+            this.server.getPlayerList().sendAll(new PacketPlayOutGameStateChange(PacketPlayOutGameStateChange.i, this.thunderLevel));
+        }
+        // */
+        for (int idx = 0; idx < this.players.size(); ++idx) {
+            if (((EntityPlayer) this.players.get(idx)).world == this) {
+                ((EntityPlayer) this.players.get(idx)).tickWeather();
+            }
+        }
+
+        if (flag != this.isRaining()) {
+            // Only send weather packets to those affected
+            for (int idx = 0; idx < this.players.size(); ++idx) {
+                if (((EntityPlayer) this.players.get(idx)).world == this) {
+                    ((EntityPlayer) this.players.get(idx)).setPlayerWeather((!flag ? WeatherType.DOWNFALL : WeatherType.CLEAR), false);
+                }
+            }
+        }
+        for (int idx = 0; idx < this.players.size(); ++idx) {
+            if (((EntityPlayer) this.players.get(idx)).world == this) {
+                ((EntityPlayer) this.players.get(idx)).updateWeather(this.lastRainLevel, this.rainLevel, this.lastThunderLevel, this.thunderLevel);
+            }
+        }
+        // CraftBukkit end
+
+        i = this.getGameRules().getInt(GameRules.I);
+        if (this.percentageSleepingPlayers > 0.0F && this.percentageSleepingPlayers >= (float) i && this.a(true) >= (float) i) {
+            TimeSkipEvent event = null; // CraftBukkit
+            if (this.getGameRules().getBoolean(GameRules.DO_DAYLIGHT_CYCLE)) {
+                long l = this.worldData.getDayTime() + 24000L;
+                // CraftBukkit start
+                event = new TimeSkipEvent(this.getWorld(), TimeSkipEvent.SkipReason.NIGHT_SKIP, (l - l % 24000L) - this.getDayTime());
+                getServer().getPluginManager().callEvent(event);
+                if (!event.isCancelled()) {
+                    this.setDayTime(this.getDayTime() + event.getSkipAmount());
+                }
+
+            }
+
+            if (event != null && !event.isCancelled()) {
+                this.percentageSleepingPlayers = 0.0F;
+                this.wakeupPlayers();
+            }
+            // CraftBukkit end
+            if (this.getGameRules().getBoolean(GameRules.DO_WEATHER_CYCLE)) {
+                this.clearWeather();
+            }
+        }
+
+        this.S();
+        this.b();
+        gameprofilerfiller.exitEnter("chunkSource");
+        this.getChunkProvider().tick(booleansupplier);
+        gameprofilerfiller.exitEnter("tickPending");
+        if (!this.isDebugWorld()) {
+            this.nextTickListBlock.b();
+            this.nextTickListFluid.b();
+        }
+
+        gameprofilerfiller.exitEnter("raid");
+        this.persistentRaid.a();
+        gameprofilerfiller.exitEnter("blockEvents");
+        this.aq();
+        this.ticking = false;
+        gameprofilerfiller.exit();
+        boolean flag3 = true || !this.players.isEmpty() || !this.getForceLoadedChunks().isEmpty(); // CraftBukkit - this prevents entity cleanup, other issues on servers with no players
+
+        if (flag3) {
+            this.resetEmptyTime();
+        }
+
+        if (flag3 || this.emptyTime++ < 300) {
+            gameprofilerfiller.enter("entities");
+            if (this.dragonBattle != null) {
+                gameprofilerfiller.enter("dragonFight");
+                this.dragonBattle.b();
+                gameprofilerfiller.exit();
+            }
+
+            org.spigotmc.ActivationRange.activateEntities(this); // Spigot
+            this.x.a((entity) -> {
+                if (!entity.cW()) {
+                    if (this.i(entity)) {
+                        entity.ab();
+                    } else {
+                        gameprofilerfiller.enter("checkDespawn");
+                        entity.checkDespawn();
+                        gameprofilerfiller.exit();
+                        Entity entity1 = entity.getVehicle();
+
+                        if (entity1 != null) {
+                            if (!entity1.cW() && entity1.w(entity)) {
+                                return;
+                            }
+
+                            entity.stopRiding();
+                        }
+
+                        gameprofilerfiller.enter("tick");
+                        this.a(this::entityJoinedWorld, entity);
+                        gameprofilerfiller.exit();
+                    }
+                }
+            });
+            gameprofilerfiller.exit();
+            this.tickBlockEntities();
+        }
+
+        gameprofilerfiller.enter("entityManagement");
+        this.y.a();
+        gameprofilerfiller.exit();
+    }
+
+    protected void b() {
+        if (this.L) {
+            long i = this.worldData.getTime() + 1L;
+
+            this.worldDataServer.setTime(i);
+            this.worldDataServer.u().a(this.server, i);
+            if (this.worldData.q().getBoolean(GameRules.DO_DAYLIGHT_CYCLE)) {
+                this.setDayTime(this.worldData.getDayTime() + 1L);
+            }
+
+        }
+    }
+
+    public void setDayTime(long i) {
+        this.worldDataServer.setDayTime(i);
+    }
+
+    public void doMobSpawning(boolean flag, boolean flag1) {
+        Iterator iterator = this.mobSpawners.iterator();
+
+        while (iterator.hasNext()) {
+            MobSpawner mobspawner = (MobSpawner) iterator.next();
+
+            mobspawner.a(this, flag, flag1);
+        }
+
+    }
+
+    private boolean i(Entity entity) {
+        return !this.server.getSpawnAnimals() && (entity instanceof EntityAnimal || entity instanceof EntityWaterAnimal) ? true : !this.server.getSpawnNPCs() && entity instanceof NPC;
+    }
+
+    private void wakeupPlayers() {
+        this.percentageSleepingPlayers = 0.0F;
+        (this.players.stream().filter(EntityLiving::isSleeping).collect(Collectors.toList())).forEach((entityplayer) -> { // CraftBukkit - decompile error
+            entityplayer.wakeup(false, false);
+        });
+    }
+
+    public void a(Chunk chunk, int i) {
+        ChunkCoordIntPair chunkcoordintpair = chunk.getPos();
+        boolean flag = this.isRaining();
+        int j = chunkcoordintpair.d();
+        int k = chunkcoordintpair.e();
+        GameProfilerFiller gameprofilerfiller = this.getMethodProfiler();
+
+        gameprofilerfiller.enter("thunder");
+        BlockPosition blockposition;
+
+        if (flag && this.Y() && this.random.nextInt(100000) == 0) {
+            blockposition = this.a(this.a(j, 0, k, 15));
+            if (this.isRainingAt(blockposition)) {
+                DifficultyDamageScaler difficultydamagescaler = this.getDamageScaler(blockposition);
+                boolean flag1 = this.getGameRules().getBoolean(GameRules.DO_MOB_SPAWNING) && this.random.nextDouble() < (double) difficultydamagescaler.b() * 0.01D;
+
+                if (flag1) {
+                    EntityHorseSkeleton entityhorseskeleton = (EntityHorseSkeleton) EntityTypes.SKELETON_HORSE.a((World) this);
+
+                    entityhorseskeleton.t(true);
+                    entityhorseskeleton.setAgeRaw(0);
+                    entityhorseskeleton.setPosition((double) blockposition.getX(), (double) blockposition.getY(), (double) blockposition.getZ());
+                    this.addEntity(entityhorseskeleton, CreatureSpawnEvent.SpawnReason.LIGHTNING); // CraftBukkit
+                }
+                // CraftBukkit end */
+
+                EntityLightning entitylightning = (EntityLightning) EntityTypes.LIGHTNING_BOLT.a((World) this);
+
+                entitylightning.d(Vec3D.c((BaseBlockPosition) blockposition));
+                entitylightning.setEffect(flag1);
+                this.strikeLightning(entitylightning, LightningStrikeEvent.Cause.WEATHER); // CraftBukkit
+            }
+        }
+
+        gameprofilerfiller.exitEnter("iceandsnow");
+        if (this.random.nextInt(16) == 0) {
+            blockposition = this.getHighestBlockYAt(HeightMap.Type.MOTION_BLOCKING, this.a(j, 0, k, 15));
+            BlockPosition blockposition1 = blockposition.down();
+            BiomeBase biomebase = this.getBiome(blockposition);
+
+            if (biomebase.a(this, blockposition1)) {
+                CraftEventFactory.handleBlockFormEvent(this, blockposition1, Blocks.ICE.getBlockData(), null); // CraftBukkit
+            }
+
+            if (flag) {
+                if (biomebase.b(this, blockposition)) {
+                    CraftEventFactory.handleBlockFormEvent(this, blockposition, Blocks.SNOW.getBlockData(), null); // CraftBukkit
+                }
+
+                IBlockData iblockdata = this.getType(blockposition1);
+                BiomeBase.Precipitation biomebase_precipitation = this.getBiome(blockposition1).c();
+
+                iblockdata.getBlock().a(iblockdata, (World) this, blockposition1, biomebase_precipitation);
+            }
+        }
+
+        gameprofilerfiller.exitEnter("tickBlocks");
+        if (i > 0) {
+            ChunkSection[] achunksection = chunk.getSections();
+            int l = achunksection.length;
+
+            for (int i1 = 0; i1 < l; ++i1) {
+                ChunkSection chunksection = achunksection[i1];
+
+                if (chunksection != Chunk.a && chunksection.d()) {
+                    int j1 = chunksection.getYPosition();
+
+                    for (int k1 = 0; k1 < i; ++k1) {
+                        BlockPosition blockposition2 = this.a(j, j1, k, 15);
+
+                        gameprofilerfiller.enter("randomTick");
+                        IBlockData iblockdata1 = chunksection.getType(blockposition2.getX() - j, blockposition2.getY() - j1, blockposition2.getZ() - k);
+
+                        if (iblockdata1.isTicking()) {
+                            iblockdata1.b(this, blockposition2, this.random);
+                        }
+
+                        Fluid fluid = iblockdata1.getFluid();
+
+                        if (fluid.f()) {
+                            fluid.b(this, blockposition2, this.random);
+                        }
+
+                        gameprofilerfiller.exit();
+                    }
+                }
+            }
+        }
+
+        gameprofilerfiller.exit();
+    }
+
+    private Optional<BlockPosition> C(BlockPosition blockposition) {
+        Optional<BlockPosition> optional = this.A().d((pointofinteresttype) -> {
+            return pointofinteresttype == PointOfInterestType.x;
+        }, blockposition, 128, VillagePlace.Occupancy.ANY);
+
+        if (optional.isPresent()) {
+            BlockPosition blockposition1 = (BlockPosition) optional.get();
+            int i = this.getMinecraftWorld().a(HeightMap.Type.WORLD_SURFACE, blockposition1.getX(), blockposition1.getZ()) - 1;
+
+            if (blockposition1.getY() == i) {
+                return Optional.of(blockposition1.up(1));
+            }
+
+            BlockPosition blockposition2 = new BlockPosition(blockposition1.getX(), i, blockposition1.getZ());
+
+            if (this.getMinecraftWorld().getType(blockposition2).a(Blocks.LIGHTNING_ROD)) {
+                return Optional.of(blockposition2.up(1));
+            }
+        }
+
+        return Optional.empty();
+    }
+
+    protected BlockPosition a(BlockPosition blockposition) {
+        BlockPosition blockposition1 = this.getHighestBlockYAt(HeightMap.Type.MOTION_BLOCKING, blockposition);
+        Optional<BlockPosition> optional = this.C(blockposition1);
+
+        if (optional.isPresent()) {
+            return (BlockPosition) optional.get();
+        } else {
+            AxisAlignedBB axisalignedbb = (new AxisAlignedBB(blockposition1, new BlockPosition(blockposition1.getX(), this.getMaxBuildHeight(), blockposition1.getZ()))).g(3.0D);
+            List<EntityLiving> list = this.a(EntityLiving.class, axisalignedbb, (entityliving) -> {
+                return entityliving != null && entityliving.isAlive() && this.e(entityliving.getChunkCoordinates());
+            });
+
+            if (!list.isEmpty()) {
+                return ((EntityLiving) list.get(this.random.nextInt(list.size()))).getChunkCoordinates();
+            } else {
+                if (blockposition1.getY() == this.getMinBuildHeight() - 1) {
+                    blockposition1 = blockposition1.up(2);
+                }
+
+                return blockposition1;
+            }
+        }
+    }
+
+    public boolean m_() {
+        return this.ticking;
+    }
+
+    public boolean d() {
+        return this.getGameRules().getInt(GameRules.I) <= 100;
+    }
+
+    private void an() {
+        if (this.d()) {
+            int i = this.getGameRules().getInt(GameRules.I);
+            ChatMessage chatmessage;
+
+            if (this.percentageSleepingPlayers >= (float) i) {
+                chatmessage = new ChatMessage("sleep.skipping_night");
+            } else {
+                int j = 0;
+                int k = 0;
+                Iterator iterator = this.players.iterator();
+
+                while (iterator.hasNext()) {
+                    EntityPlayer entityplayer = (EntityPlayer) iterator.next();
+
+                    if (!entityplayer.isSpectator()) {
+                        ++k;
+                        if (entityplayer.isSleeping()) {
+                            ++j;
+                        }
+                    }
+                }
+
+                k = Math.max(k * i / 100, 1);
+                chatmessage = new ChatMessage("sleep.players_sleeping", new Object[]{j, k});
+            }
+
+            Iterator iterator1 = this.players.iterator();
+
+            while (iterator1.hasNext()) {
+                EntityPlayer entityplayer1 = (EntityPlayer) iterator1.next();
+
+                entityplayer1.a((IChatBaseComponent) chatmessage, true);
+            }
+
+        }
+    }
+
+    public void everyoneSleeping() {
+        if (!this.players.isEmpty()) {
+            float f = this.percentageSleepingPlayers;
+
+            this.percentageSleepingPlayers = this.a(false);
+            if (f != this.percentageSleepingPlayers) {
+                this.an();
+            }
+        }
+
+    }
+
+    private float a(boolean flag) {
+        int i = 0;
+        int j = 0;
+        Iterator iterator = this.players.iterator();
+
+        while (iterator.hasNext()) {
+            EntityPlayer entityplayer = (EntityPlayer) iterator.next();
+
+            if (!entityplayer.isSpectator() || (entityplayer.fauxSleeping && !entityplayer.isSleeping())) { // CraftBukkit
+                ++i;
+                if (flag) {
+                    if (!entityplayer.eY()) {
+                        continue;
+                    }
+                } else if (!entityplayer.isSleeping()) {
+                    continue;
+                }
+
+                ++j;
+            }
+        }
+
+        if (i == 0) {
+            return 0.0F;
+        } else {
+            return 100.0F * (float) j / (float) i;
+        }
+    }
+
+    @Override
+    public ScoreboardServer getScoreboard() {
+        return this.server.getScoreboard();
+    }
+
+    private void clearWeather() {
+        // CraftBukkit start
+        this.worldDataServer.setStorm(false);
+        // If we stop due to everyone sleeping we should reset the weather duration to some other random value.
+        // Not that everyone ever manages to get the whole server to sleep at the same time....
+        if (!this.worldDataServer.hasStorm()) {
+            this.worldDataServer.setWeatherDuration(0);
+        }
+        // CraftBukkit end
+        this.worldDataServer.setThundering(false);
+        // CraftBukkit start
+        // If we stop due to everyone sleeping we should reset the weather duration to some other random value.
+        // Not that everyone ever manages to get the whole server to sleep at the same time....
+        if (!this.worldDataServer.isThundering()) {
+            this.worldDataServer.setThunderDuration(0);
+        }
+        // CraftBukkit end
+    }
+
+    public void resetEmptyTime() {
+        this.emptyTime = 0;
+    }
+
+    private void a(NextTickListEntry<FluidType> nextticklistentry) {
+        Fluid fluid = this.getFluid(nextticklistentry.a);
+
+        if (fluid.getType() == nextticklistentry.b()) {
+            fluid.a((World) this, nextticklistentry.a);
+        }
+
+    }
+
+    private void b(NextTickListEntry<Block> nextticklistentry) {
+        IBlockData iblockdata = this.getType(nextticklistentry.a);
+
+        if (iblockdata.a((Block) nextticklistentry.b())) {
+            iblockdata.a(this, nextticklistentry.a, this.random);
+        }
+
+    }
+
+    public void entityJoinedWorld(Entity entity) {
+        entity.g(entity.locX(), entity.locY(), entity.locZ());
+        entity.lastYaw = entity.yaw;
+        entity.lastPitch = entity.pitch;
+        GameProfilerFiller gameprofilerfiller = this.getMethodProfiler();
+
+        ++entity.ticksLived;
+        this.getMethodProfiler().a(() -> {
+            return IRegistry.ENTITY_TYPE.getKey(entity.getEntityType()).toString();
+        });
+        gameprofilerfiller.c("tickNonPassenger");
+        entity.tick();
+        entity.postTick();
+        this.getMethodProfiler().exit();
+        Iterator iterator = entity.getPassengers().iterator();
+
+        while (iterator.hasNext()) {
+            Entity entity1 = (Entity) iterator.next();
+
+            this.a(entity, entity1);
+        }
+
+    }
+
+    private void a(Entity entity, Entity entity1) {
+        if (!entity1.cW() && entity1.getVehicle() == entity) {
+            if (entity1 instanceof EntityHuman || this.x.c(entity1)) {
+                // Spigot start
+                if (!org.spigotmc.ActivationRange.checkIfActive(entity)) {
+                    entity.ticksLived++;
+                    entity.inactiveTick();
+                    return;
+                }
+                // Spigot end
+                entity.tickTimer.startTiming(); // Spigot
+                entity1.g(entity1.locX(), entity1.locY(), entity1.locZ());
+                entity1.lastYaw = entity1.yaw;
+                entity1.lastPitch = entity1.pitch;
+                ++entity1.ticksLived;
+                GameProfilerFiller gameprofilerfiller = this.getMethodProfiler();
+
+                gameprofilerfiller.a(() -> {
+                    return IRegistry.ENTITY_TYPE.getKey(entity1.getEntityType()).toString();
+                });
+                gameprofilerfiller.c("tickPassenger");
+                entity1.passengerTick();
+                entity1.postTick();
+                gameprofilerfiller.exit();
+                Iterator iterator = entity1.getPassengers().iterator();
+
+                while (iterator.hasNext()) {
+                    Entity entity2 = (Entity) iterator.next();
+
+                    this.a(entity1, entity2);
+                }
+                entity.tickTimer.stopTiming(); // Spigot
+
+            }
+        } else {
+            entity1.stopRiding();
+        }
+    }
+
+    @Override
+    public boolean a(EntityHuman entityhuman, BlockPosition blockposition) {
+        return !this.server.a(this, blockposition, entityhuman) && this.getWorldBorder().a(blockposition);
+    }
+
+    public void save(@Nullable IProgressUpdate iprogressupdate, boolean flag, boolean flag1) {
+        ChunkProviderServer chunkproviderserver = this.getChunkProvider();
+
+        if (!flag1) {
+            Bukkit.getPluginManager().callEvent(new org.bukkit.event.world.WorldSaveEvent(getWorld())); // CraftBukkit
+            if (iprogressupdate != null) {
+                iprogressupdate.a(new ChatMessage("menu.savingLevel"));
+            }
+
+            this.ap();
+            if (iprogressupdate != null) {
+                iprogressupdate.c(new ChatMessage("menu.savingChunks"));
+            }
+
+            chunkproviderserver.save(flag);
+            if (flag) {
+                this.y.c();
+            } else {
+                this.y.b();
+            }
+
+        }
+        // CraftBukkit start - moved from MinecraftServer.saveChunks
+        WorldServer worldserver1 = this;
+
+        worldDataServer.a(worldserver1.getWorldBorder().t());
+        worldDataServer.setCustomBossEvents(this.server.getBossBattleCustomData().save());
+        convertable.a(this.server.customRegistry, this.worldDataServer, this.server.getPlayerList().save());
+        // CraftBukkit end
+    }
+
+    private void ap() {
+        if (this.dragonBattle != null) {
+            this.server.getSaveData().a(this.dragonBattle.a());
+        }
+
+        this.getChunkProvider().getWorldPersistentData().a();
+    }
+
+    public <T extends Entity> List<? extends T> a(EntityTypeTest<Entity, T> entitytypetest, Predicate<? super T> predicate) {
+        List<T> list = Lists.newArrayList();
+
+        this.getEntities().a(entitytypetest, (entity) -> {
+            if (predicate.test(entity)) {
+                list.add(entity);
+            }
+
+        });
+        return list;
+    }
+
+    public List<? extends EntityEnderDragon> h() {
+        return this.a((EntityTypeTest) EntityTypes.ENDER_DRAGON, EntityLiving::isAlive);
+    }
+
+    public List<EntityPlayer> a(Predicate<? super EntityPlayer> predicate) {
+        List<EntityPlayer> list = Lists.newArrayList();
+        Iterator iterator = this.players.iterator();
+
+        while (iterator.hasNext()) {
+            EntityPlayer entityplayer = (EntityPlayer) iterator.next();
+
+            if (predicate.test(entityplayer)) {
+                list.add(entityplayer);
+            }
+        }
+
+        return list;
+    }
+
+    @Nullable
+    public EntityPlayer i() {
+        List<EntityPlayer> list = this.a(EntityLiving::isAlive);
+
+        return list.isEmpty() ? null : (EntityPlayer) list.get(this.random.nextInt(list.size()));
+    }
+
+    public boolean addEntity(Entity entity) { return addFreshEntity(entity); } // CraftBukkit
+
+    public boolean addFreshEntity(Entity entity) {
+        // CraftBukkit start
+        return this.addEntity0(entity, CreatureSpawnEvent.SpawnReason.DEFAULT);
+    }
+
+    @Override
+    public boolean addEntity(Entity entity, CreatureSpawnEvent.SpawnReason reason) {
+        return this.addEntity0(entity, reason);
+        // CraftBukkit end
+    }
+
+    public boolean addEntitySerialized(Entity entity) {
+        // CraftBukkit start
+        return this.addEntitySerialized(entity, CreatureSpawnEvent.SpawnReason.DEFAULT);
+    }
+
+    public boolean addEntitySerialized(Entity entity, CreatureSpawnEvent.SpawnReason reason) {
+        return this.addEntity0(entity, reason);
+        // CraftBukkit end
+    }
+
+    public void addEntityTeleport(Entity entity) {
+        this.addEntity0(entity, CreatureSpawnEvent.SpawnReason.DEFAULT);
+    }
+
+    public void addPlayerCommand(EntityPlayer entityplayer) {
+        this.addPlayer0(entityplayer);
+    }
+
+    public void addPlayerPortal(EntityPlayer entityplayer) {
+        this.addPlayer0(entityplayer);
+    }
+
+    public void addPlayerJoin(EntityPlayer entityplayer) {
+        this.addPlayer0(entityplayer);
+    }
+
+    public void addPlayerRespawn(EntityPlayer entityplayer) {
+        this.addPlayer0(entityplayer);
+    }
+
+    private void addPlayer0(EntityPlayer entityplayer) {
+        Entity entity = (Entity) this.getEntities().a(entityplayer.getUniqueID());
+
+        if (entity != null) {
+            WorldServer.LOGGER.warn("Force-added player with duplicate UUID {}", entityplayer.getUniqueID().toString());
+            entity.decouple();
+            this.removePlayer((EntityPlayer) entity, Entity.RemovalReason.DISCARDED);
+        }
+
+        this.y.a(entityplayer); // CraftBukkit - decompile error
+    }
+
+    // CraftBukkit start
+    private boolean addEntity0(Entity entity, CreatureSpawnEvent.SpawnReason spawnReason) {
+        org.spigotmc.AsyncCatcher.catchOp("entity add"); // Spigot
+        if (entity.cW()) {
+            // WorldServer.LOGGER.warn("Tried to add entity {} but it was marked as removed already", EntityTypes.getName(entity.getEntityType())); // CraftBukkit
+            return false;
+        } else {
+            return this.y.a(entity, false, spawnReason, this);
+        }
+    }
+
+    public boolean addAllEntitiesSafely(Entity entity) {
+        // CraftBukkit start
+        return this.addAllEntitiesSafely(entity, CreatureSpawnEvent.SpawnReason.DEFAULT);
+    }
+
+    public boolean addAllEntitiesSafely(Entity entity, CreatureSpawnEvent.SpawnReason reason) {
+        // CraftBukkit end
+        Stream<UUID> stream = entity.cu().map(Entity::getUniqueID); // CraftBukkit - decompile error
+        PersistentEntitySectionManager persistententitysectionmanager = this.y;
+
+        this.y.getClass();
+        if (stream.anyMatch(persistententitysectionmanager::a)) {
+            return false;
+        } else {
+            this.addAllEntities(entity, reason); // CraftBukkit
+            return true;
+        }
+    }
+
+    public void unloadChunk(Chunk chunk) {
+        chunk.C();
+    }
+
+    public void removePlayer(EntityPlayer entityplayer, Entity.RemovalReason entity_removalreason) {
+        entityplayer.a(entity_removalreason);
+    }
+
+    // CraftBukkit start
+    public boolean strikeLightning(Entity entitylightning) {
+        return this.strikeLightning(entitylightning, LightningStrikeEvent.Cause.UNKNOWN);
+    }
+
+    public boolean strikeLightning(Entity entitylightning, LightningStrikeEvent.Cause cause) {
+        LightningStrikeEvent lightning = new LightningStrikeEvent(this.getWorld(), (org.bukkit.entity.LightningStrike) entitylightning.getBukkitEntity(), cause);
+        this.getServer().getPluginManager().callEvent(lightning);
+
+        if (lightning.isCancelled()) {
+            return false;
+        }
+
+        return this.addEntity(entitylightning);
+    }
+    // CraftBukkit end
+
+    @Override
+    public void a(int i, BlockPosition blockposition, int j) {
+        Iterator iterator = this.server.getPlayerList().getPlayers().iterator();
+
+        // CraftBukkit start
+        EntityHuman entityhuman = null;
+        Entity entity = this.getEntity(i);
+        if (entity instanceof EntityHuman) entityhuman = (EntityHuman) entity;
+        // CraftBukkit end
+
+        while (iterator.hasNext()) {
+            EntityPlayer entityplayer = (EntityPlayer) iterator.next();
+
+            if (entityplayer != null && entityplayer.world == this && entityplayer.getId() != i) {
+                double d0 = (double) blockposition.getX() - entityplayer.locX();
+                double d1 = (double) blockposition.getY() - entityplayer.locY();
+                double d2 = (double) blockposition.getZ() - entityplayer.locZ();
+
+                // CraftBukkit start
+                if (entityhuman != null && entityhuman instanceof EntityPlayer && !entityplayer.getBukkitEntity().canSee(((EntityPlayer) entityhuman).getBukkitEntity())) {
+                    continue;
+                }
+                // CraftBukkit end
+
+                if (d0 * d0 + d1 * d1 + d2 * d2 < 1024.0D) {
+                    entityplayer.playerConnection.sendPacket(new PacketPlayOutBlockBreakAnimation(i, blockposition, j));
+                }
+            }
+        }
+
+    }
+
+    @Override
+    public void playSound(@Nullable EntityHuman entityhuman, double d0, double d1, double d2, SoundEffect soundeffect, SoundCategory soundcategory, float f, float f1) {
+        this.server.getPlayerList().sendPacketNearby(entityhuman, d0, d1, d2, f > 1.0F ? (double) (16.0F * f) : 16.0D, this.getDimensionKey(), new PacketPlayOutNamedSoundEffect(soundeffect, soundcategory, d0, d1, d2, f, f1));
+    }
+
+    @Override
+    public void playSound(@Nullable EntityHuman entityhuman, Entity entity, SoundEffect soundeffect, SoundCategory soundcategory, float f, float f1) {
+        this.server.getPlayerList().sendPacketNearby(entityhuman, entity.locX(), entity.locY(), entity.locZ(), f > 1.0F ? (double) (16.0F * f) : 16.0D, this.getDimensionKey(), new PacketPlayOutEntitySound(soundeffect, soundcategory, entity, f, f1));
+    }
+
+    @Override
+    public void b(int i, BlockPosition blockposition, int j) {
+        this.server.getPlayerList().sendAll(new PacketPlayOutWorldEvent(i, blockposition, j, true));
+    }
+
+    @Override
+    public void a(@Nullable EntityHuman entityhuman, int i, BlockPosition blockposition, int j) {
+        this.server.getPlayerList().sendPacketNearby(entityhuman, (double) blockposition.getX(), (double) blockposition.getY(), (double) blockposition.getZ(), 64.0D, this.getDimensionKey(), new PacketPlayOutWorldEvent(i, blockposition, j, false));
+    }
+
+    public int j() {
+        return this.getDimensionManager().getLogicalHeight();
+    }
+
+    @Override
+    public void a(@Nullable Entity entity, ckz ckz, BlockPosition blockposition) {
+        this.a(entity, ckz, blockposition, ckz.b());
+    }
+
+    @Override
+    public void notify(BlockPosition blockposition, IBlockData iblockdata, IBlockData iblockdata1, int i) {
+        this.getChunkProvider().flagDirty(blockposition);
+        VoxelShape voxelshape = iblockdata.getCollisionShape(this, blockposition);
+        VoxelShape voxelshape1 = iblockdata1.getCollisionShape(this, blockposition);
+
+        if (VoxelShapes.c(voxelshape, voxelshape1, OperatorBoolean.NOT_SAME)) {
+            Iterator iterator = this.navigators.iterator();
+
+            while (iterator.hasNext()) {
+                EntityInsentient entityinsentient = (EntityInsentient) iterator.next();
+                NavigationAbstract navigationabstract = entityinsentient.getNavigation();
+
+                if (!navigationabstract.i()) {
+                    navigationabstract.b(blockposition);
+                }
+            }
+
+        }
+    }
+
+    @Override
+    public void broadcastEntityEffect(Entity entity, byte b0) {
+        this.getChunkProvider().broadcastIncludingSelf(entity, new PacketPlayOutEntityStatus(entity, b0));
+    }
+
+    @Override
+    public ChunkProviderServer getChunkProvider() {
+        return this.chunkProvider;
+    }
+
+    @Override
+    public Explosion createExplosion(@Nullable Entity entity, @Nullable DamageSource damagesource, @Nullable ExplosionDamageCalculator explosiondamagecalculator, double d0, double d1, double d2, float f, boolean flag, Explosion.Effect explosion_effect) {
+        // CraftBukkit start
+        Explosion explosion = super.createExplosion(entity, damagesource, explosiondamagecalculator, d0, d1, d2, f, flag, explosion_effect);
+
+        if (explosion.wasCanceled) {
+            return explosion;
+        }
+
+        /* Remove
+        Explosion explosion = new Explosion(this, entity, damagesource, explosiondamagecalculator, d0, d1, d2, f, flag, explosion_effect);
+
+        explosion.a();
+        explosion.a(false);
+        */
+        // CraftBukkit end - TODO: Check if explosions are still properly implemented
+        if (explosion_effect == Explosion.Effect.NONE) {
+            explosion.clearBlocks();
+        }
+
+        Iterator iterator = this.players.iterator();
+
+        while (iterator.hasNext()) {
+            EntityPlayer entityplayer = (EntityPlayer) iterator.next();
+
+            if (entityplayer.h(d0, d1, d2) < 4096.0D) {
+                entityplayer.playerConnection.sendPacket(new PacketPlayOutExplosion(d0, d1, d2, f, explosion.getBlocks(), (Vec3D) explosion.c().get(entityplayer)));
+            }
+        }
+
+        return explosion;
+    }
+
+    @Override
+    public void playBlockAction(BlockPosition blockposition, Block block, int i, int j) {
+        this.F.add(new BlockActionData(blockposition, block, i, j));
+    }
+
+    private void aq() {
+        while (!this.F.isEmpty()) {
+            BlockActionData blockactiondata = (BlockActionData) this.F.removeFirst();
+
+            if (this.a(blockactiondata)) {
+                this.server.getPlayerList().sendPacketNearby((EntityHuman) null, (double) blockactiondata.a().getX(), (double) blockactiondata.a().getY(), (double) blockactiondata.a().getZ(), 64.0D, this.getDimensionKey(), new PacketPlayOutBlockAction(blockactiondata.a(), blockactiondata.b(), blockactiondata.c(), blockactiondata.d()));
+            }
+        }
+
+    }
+
+    private boolean a(BlockActionData blockactiondata) {
+        IBlockData iblockdata = this.getType(blockactiondata.a());
+
+        return iblockdata.a(blockactiondata.b()) ? iblockdata.a((World) this, blockactiondata.a(), blockactiondata.c(), blockactiondata.d()) : false;
+    }
+
+    @Override
+    public TickListServer<Block> getBlockTickList() {
+        return this.nextTickListBlock;
+    }
+
+    @Override
+    public TickListServer<FluidType> getFluidTickList() {
+        return this.nextTickListFluid;
+    }
+
+    @Nonnull
+    @Override
+    public MinecraftServer getMinecraftServer() {
+        return this.server;
+    }
+
+    public PortalTravelAgent getTravelAgent() {
+        return this.portalTravelAgent;
+    }
+
+    public DefinedStructureManager p() {
+        return this.server.getDefinedStructureManager();
+    }
+
+    public void a(clh clh) {
+        BlockPosition blockposition = clh.b();
+        PacketPlayOutAddVibrationSignal packetplayoutaddvibrationsignal = new PacketPlayOutAddVibrationSignal(clh);
+
+        this.players.forEach((entityplayer) -> {
+            this.a(entityplayer, false, (double) blockposition.getX(), (double) blockposition.getY(), (double) blockposition.getZ(), packetplayoutaddvibrationsignal);
+        });
+    }
+
+    public <T extends ParticleParam> int a(T t0, double d0, double d1, double d2, int i, double d3, double d4, double d5, double d6) {
+        // CraftBukkit - visibility api support
+        return sendParticles(null, t0, d0, d1, d2, i, d3, d4, d5, d6, false);
+    }
+
+    public <T extends ParticleParam> int sendParticles(EntityPlayer sender, T t0, double d0, double d1, double d2, int i, double d3, double d4, double d5, double d6, boolean force) {
+        PacketPlayOutWorldParticles packetplayoutworldparticles = new PacketPlayOutWorldParticles(t0, force, d0, d1, d2, (float) d3, (float) d4, (float) d5, (float) d6, i);
+        // CraftBukkit end
+        int j = 0;
+
+        for (int k = 0; k < this.players.size(); ++k) {
+            EntityPlayer entityplayer = (EntityPlayer) this.players.get(k);
+            if (sender != null && !entityplayer.getBukkitEntity().canSee(sender.getBukkitEntity())) continue; // CraftBukkit
+
+            if (this.a(entityplayer, force, d0, d1, d2, packetplayoutworldparticles)) { // CraftBukkit
+                ++j;
+            }
+        }
+
+        return j;
+    }
+
+    public <T extends ParticleParam> boolean a(EntityPlayer entityplayer, T t0, boolean flag, double d0, double d1, double d2, int i, double d3, double d4, double d5, double d6) {
+        Packet<?> packet = new PacketPlayOutWorldParticles(t0, flag, d0, d1, d2, (float) d3, (float) d4, (float) d5, (float) d6, i);
+
+        return this.a(entityplayer, flag, d0, d1, d2, packet);
+    }
+
+    private boolean a(EntityPlayer entityplayer, boolean flag, double d0, double d1, double d2, Packet<?> packet) {
+        if (entityplayer.getWorldServer() != this) {
+            return false;
+        } else {
+            BlockPosition blockposition = entityplayer.getChunkCoordinates();
+
+            if (blockposition.a((IPosition) (new Vec3D(d0, d1, d2)), flag ? 512.0D : 32.0D)) {
+                entityplayer.playerConnection.sendPacket(packet);
+                return true;
+            } else {
+                return false;
+            }
+        }
+    }
+
+    @Nullable
+    @Override
+    public Entity getEntity(int i) {
+        return (Entity) this.getEntities().a(i);
+    }
+
+    @Deprecated
+    @Nullable
+    public Entity b(int i) {
+        Entity entity = (Entity) this.getEntities().a(i);
+
+        return entity != null ? entity : (Entity) this.J.get(i);
+    }
+
+    @Nullable
+    public Entity getEntity(UUID uuid) {
+        return (Entity) this.getEntities().a(uuid);
+    }
+
+    @Nullable
+    public BlockPosition a(StructureGenerator<?> structuregenerator, BlockPosition blockposition, int i, boolean flag) {
+        return !this.worldDataServer.getGeneratorSettings().shouldGenerateMapFeatures() ? null : this.getChunkProvider().getChunkGenerator().findNearestMapFeature(this, structuregenerator, blockposition, i, flag); // CraftBukkit
+    }
+
+    @Nullable
+    public BlockPosition a(BiomeBase biomebase, BlockPosition blockposition, int i, int j) {
+        return this.getChunkProvider().getChunkGenerator().getWorldChunkManager().a(blockposition.getX(), blockposition.getY(), blockposition.getZ(), i, j, (biomebase1) -> {
+            return biomebase1 == biomebase;
+        }, this.random, true);
+    }
+
+    @Override
+    public CraftingManager getCraftingManager() {
+        return this.server.getCraftingManager();
+    }
+
+    @Override
+    public ITagRegistry r() {
+        return this.server.getTagRegistry();
+    }
+
+    @Override
+    public boolean isSavingDisabled() {
+        return this.savingDisabled;
+    }
+
+    @Override
+    public IRegistryCustom t() {
+        return this.server.getCustomRegistry();
+    }
+
+    public WorldPersistentData getWorldPersistentData() {
+        return this.getChunkProvider().getWorldPersistentData();
+    }
+
+    @Nullable
+    @Override
+    public WorldMap a(String s) {
+        // CraftBukkit start
+        // We only get here when the data file exists, but is not a valid map
+        WorldMap map = this.getMinecraftServer().E().getWorldPersistentData().a(WorldMap::b, s);
+        if (map == null) return null;
+        MapInitializeEvent event = new MapInitializeEvent(map.mapView);
+        Bukkit.getServer().getPluginManager().callEvent(event);
+        return map;
+        // CraftBukkit end
+    }
+
+    @Override
+    public void a(String s, WorldMap worldmap) {
+        this.getMinecraftServer().E().getWorldPersistentData().a(s, (PersistentBase) worldmap);
+    }
+
+    @Override
+    public int getWorldMapCount() {
+        return ((PersistentIdCounts) this.getMinecraftServer().E().getWorldPersistentData().a(PersistentIdCounts::b, PersistentIdCounts::new, "idcounts")).a();
+    }
+
+    public void a(BlockPosition blockposition, float f) {
+        ChunkCoordIntPair chunkcoordintpair = new ChunkCoordIntPair(new BlockPosition(this.worldData.a(), 0, this.worldData.c()));
+
+        this.worldData.setSpawn(blockposition, f);
+        this.getChunkProvider().removeTicket(TicketType.START, chunkcoordintpair, 11, Unit.INSTANCE);
+        this.getChunkProvider().addTicket(TicketType.START, new ChunkCoordIntPair(blockposition), 11, Unit.INSTANCE);
+        this.getMinecraftServer().getPlayerList().sendAll(new PacketPlayOutSpawnPosition(blockposition, f));
+    }
+
+    public BlockPosition getSpawn() {
+        BlockPosition blockposition = new BlockPosition(this.worldData.a(), this.worldData.b(), this.worldData.c());
+
+        if (!this.getWorldBorder().a(blockposition)) {
+            blockposition = this.getHighestBlockYAt(HeightMap.Type.MOTION_BLOCKING, new BlockPosition(this.getWorldBorder().getCenterX(), 0.0D, this.getWorldBorder().getCenterZ()));
+        }
+
+        return blockposition;
+    }
+
+    public float x() {
+        return this.worldData.d();
+    }
+
+    public LongSet getForceLoadedChunks() {
+        ForcedChunk forcedchunk = (ForcedChunk) this.getWorldPersistentData().a(ForcedChunk::b, "chunks");
+
+        return (LongSet) (forcedchunk != null ? LongSets.unmodifiable(forcedchunk.a()) : LongSets.EMPTY_SET);
+    }
+
+    public boolean setForceLoaded(int i, int j, boolean flag) {
+        ForcedChunk forcedchunk = (ForcedChunk) this.getWorldPersistentData().a(ForcedChunk::b, ForcedChunk::new, "chunks");
+        ChunkCoordIntPair chunkcoordintpair = new ChunkCoordIntPair(i, j);
+        long k = chunkcoordintpair.pair();
+        boolean flag1;
+
+        if (flag) {
+            flag1 = forcedchunk.a().add(k);
+            if (flag1) {
+                this.getChunkAt(i, j);
+            }
+        } else {
+            flag1 = forcedchunk.a().remove(k);
+        }
+
+        forcedchunk.a(flag1);
+        if (flag1) {
+            this.getChunkProvider().a(chunkcoordintpair, flag);
+        }
+
+        return flag1;
+    }
+
+    @Override
+    public List<EntityPlayer> getPlayers() {
+        return this.players;
+    }
+
+    @Override
+    public void a(BlockPosition blockposition, IBlockData iblockdata, IBlockData iblockdata1) {
+        Optional<PointOfInterestType> optional = PointOfInterestType.b(iblockdata);
+        Optional<PointOfInterestType> optional1 = PointOfInterestType.b(iblockdata1);
+
+        if (!Objects.equals(optional, optional1)) {
+            BlockPosition blockposition1 = blockposition.immutableCopy();
+
+            optional.ifPresent((pointofinteresttype) -> {
+                this.getMinecraftServer().execute(() -> {
+                    this.A().a(blockposition1);
+                    PacketDebug.b(this, blockposition1);
+                });
+            });
+            optional1.ifPresent((pointofinteresttype) -> {
+                this.getMinecraftServer().execute(() -> {
+                    this.A().a(blockposition1, pointofinteresttype);
+                    PacketDebug.a(this, blockposition1);
+                });
+            });
+        }
+    }
+
+    public VillagePlace A() {
+        return this.getChunkProvider().j();
+    }
+
+    public boolean a_(BlockPosition blockposition) {
+        return this.a(blockposition, 1);
+    }
+
+    public boolean a(SectionPosition sectionposition) {
+        return this.a_(sectionposition.q());
+    }
+
+    public boolean a(BlockPosition blockposition, int i) {
+        return i > 6 ? false : this.b(SectionPosition.a(blockposition)) <= i;
+    }
+
+    public int b(SectionPosition sectionposition) {
+        return this.A().a(sectionposition);
+    }
+
+    public PersistentRaid getPersistentRaid() {
+        return this.persistentRaid;
+    }
+
+    @Nullable
+    public Raid b_(BlockPosition blockposition) {
+        return this.persistentRaid.getNearbyRaid(blockposition, 9216);
+    }
+
+    public boolean c_(BlockPosition blockposition) {
+        return this.b_(blockposition) != null;
+    }
+
+    public void a(ReputationEvent reputationevent, Entity entity, ReputationHandler reputationhandler) {
+        reputationhandler.a(reputationevent, entity);
+    }
+
+    public void a(java.nio.file.Path java_nio_file_path) throws IOException {
+        PlayerChunkMap playerchunkmap = this.getChunkProvider().playerChunkMap;
+        BufferedWriter bufferedwriter = Files.newBufferedWriter(java_nio_file_path.resolve("stats.txt"));
+        Throwable throwable = null;
+
+        try {
+            bufferedwriter.write(String.format("spawning_chunks: %d\n", playerchunkmap.e().b()));
+            SpawnerCreature.d spawnercreature_d = this.getChunkProvider().k();
+
+            if (spawnercreature_d != null) {
+                ObjectIterator objectiterator = spawnercreature_d.b().object2IntEntrySet().iterator();
+
+                while (objectiterator.hasNext()) {
+                    Entry<EnumCreatureType> entry = (Entry) objectiterator.next();
+
+                    bufferedwriter.write(String.format("spawn_count.%s: %d\n", ((EnumCreatureType) entry.getKey()).b(), entry.getIntValue()));
+                }
+            }
+
+            bufferedwriter.write(String.format("entities: %s\n", this.y.e()));
+            bufferedwriter.write(String.format("block_entity_tickers: %d\n", this.tileEntityList.size()));
+            bufferedwriter.write(String.format("block_ticks: %d\n", this.getBlockTickList().a()));
+            bufferedwriter.write(String.format("fluid_ticks: %d\n", this.getFluidTickList().a()));
+            bufferedwriter.write("distance_manager: " + playerchunkmap.e().c() + "\n");
+            bufferedwriter.write(String.format("pending_tasks: %d\n", this.getChunkProvider().f()));
+        } catch (Throwable throwable1) {
+            throwable = throwable1;
+            throw throwable1;
+        } finally {
+            if (bufferedwriter != null) {
+                if (throwable != null) {
+                    try {
+                        bufferedwriter.close();
+                    } catch (Throwable throwable2) {
+                        throwable.addSuppressed(throwable2);
+                    }
+                } else {
+                    bufferedwriter.close();
+                }
+            }
+
+        }
+
+        CrashReport crashreport = new CrashReport("Level dump", new Exception("dummy"));
+
+        this.a(crashreport);
+        BufferedWriter bufferedwriter1 = Files.newBufferedWriter(java_nio_file_path.resolve("example_crash.txt"));
+        Throwable throwable3 = null;
+
+        try {
+            bufferedwriter1.write(crashreport.e());
+        } catch (Throwable throwable4) {
+            throwable3 = throwable4;
+            throw throwable4;
+        } finally {
+            if (bufferedwriter1 != null) {
+                if (throwable3 != null) {
+                    try {
+                        bufferedwriter1.close();
+                    } catch (Throwable throwable5) {
+                        throwable3.addSuppressed(throwable5);
+                    }
+                } else {
+                    bufferedwriter1.close();
+                }
+            }
+
+        }
+
+        java.nio.file.Path java_nio_file_path1 = java_nio_file_path.resolve("chunks.csv");
+        BufferedWriter bufferedwriter2 = Files.newBufferedWriter(java_nio_file_path1);
+        Throwable throwable6 = null;
+
+        try {
+            playerchunkmap.a((Writer) bufferedwriter2);
+        } catch (Throwable throwable7) {
+            throwable6 = throwable7;
+            throw throwable7;
+        } finally {
+            if (bufferedwriter2 != null) {
+                if (throwable6 != null) {
+                    try {
+                        bufferedwriter2.close();
+                    } catch (Throwable throwable8) {
+                        throwable6.addSuppressed(throwable8);
+                    }
+                } else {
+                    bufferedwriter2.close();
+                }
+            }
+
+        }
+
+        java.nio.file.Path java_nio_file_path2 = java_nio_file_path.resolve("entity_chunks.csv");
+        BufferedWriter bufferedwriter3 = Files.newBufferedWriter(java_nio_file_path2);
+        Throwable throwable9 = null;
+
+        try {
+            this.y.a((Writer) bufferedwriter3);
+        } catch (Throwable throwable10) {
+            throwable9 = throwable10;
+            throw throwable10;
+        } finally {
+            if (bufferedwriter3 != null) {
+                if (throwable9 != null) {
+                    try {
+                        bufferedwriter3.close();
+                    } catch (Throwable throwable11) {
+                        throwable9.addSuppressed(throwable11);
+                    }
+                } else {
+                    bufferedwriter3.close();
+                }
+            }
+
+        }
+
+        java.nio.file.Path java_nio_file_path3 = java_nio_file_path.resolve("entities.csv");
+        BufferedWriter bufferedwriter4 = Files.newBufferedWriter(java_nio_file_path3);
+        Throwable throwable12 = null;
+
+        try {
+            a((Writer) bufferedwriter4, this.getEntities().iterable());
+        } catch (Throwable throwable13) {
+            throwable12 = throwable13;
+            throw throwable13;
+        } finally {
+            if (bufferedwriter4 != null) {
+                if (throwable12 != null) {
+                    try {
+                        bufferedwriter4.close();
+                    } catch (Throwable throwable14) {
+                        throwable12.addSuppressed(throwable14);
+                    }
+                } else {
+                    bufferedwriter4.close();
+                }
+            }
+
+        }
+
+        java.nio.file.Path java_nio_file_path4 = java_nio_file_path.resolve("block_entities.csv");
+        BufferedWriter bufferedwriter5 = Files.newBufferedWriter(java_nio_file_path4);
+        Throwable throwable15 = null;
+
+        try {
+            this.a((Writer) bufferedwriter5);
+        } catch (Throwable throwable16) {
+            throwable15 = throwable16;
+            throw throwable16;
+        } finally {
+            if (bufferedwriter5 != null) {
+                if (throwable15 != null) {
+                    try {
+                        bufferedwriter5.close();
+                    } catch (Throwable throwable17) {
+                        throwable15.addSuppressed(throwable17);
+                    }
+                } else {
+                    bufferedwriter5.close();
+                }
+            }
+
+        }
+
+    }
+
+    private static void a(Writer writer, Iterable<Entity> iterable) throws IOException {
+        CSVWriter csvwriter = CSVWriter.a().a("x").a("y").a("z").a("uuid").a("type").a("alive").a("display_name").a("custom_name").a(writer);
+        Iterator iterator = iterable.iterator();
+
+        while (iterator.hasNext()) {
+            Entity entity = (Entity) iterator.next();
+            IChatBaseComponent ichatbasecomponent = entity.getCustomName();
+            IChatBaseComponent ichatbasecomponent1 = entity.getScoreboardDisplayName();
+
+            csvwriter.a(entity.locX(), entity.locY(), entity.locZ(), entity.getUniqueID(), IRegistry.ENTITY_TYPE.getKey(entity.getEntityType()), entity.isAlive(), ichatbasecomponent1.getString(), ichatbasecomponent != null ? ichatbasecomponent.getString() : null);
+        }
+
+    }
+
+    private void a(Writer writer) throws IOException {
+        CSVWriter csvwriter = CSVWriter.a().a("x").a("y").a("z").a("type").a(writer);
+        Iterator iterator = this.tileEntityList.iterator();
+
+        while (iterator.hasNext()) {
+            ITickable itickable = (ITickable) iterator.next();
+            BlockPosition blockposition = itickable.c();
+
+            csvwriter.a(blockposition.getX(), blockposition.getY(), blockposition.getZ(), itickable.d());
+        }
+
+    }
+
+    @VisibleForTesting
+    public void a(StructureBoundingBox structureboundingbox) {
+        this.F.removeIf((blockactiondata) -> {
+            return structureboundingbox.b((BaseBlockPosition) blockactiondata.a());
+        });
+    }
+
+    @Override
+    public void update(BlockPosition blockposition, Block block) {
+        if (!this.isDebugWorld()) {
+            // CraftBukkit start
+            if (populating) {
+                return;
+            }
+            // CraftBukkit end
+            this.applyPhysics(blockposition, block);
+        }
+
+    }
+
+    public Iterable<Entity> C() {
+        return this.getEntities().iterable();
+    }
+
+    public String toString() {
+        return "ServerLevel[" + this.worldDataServer.getName() + "]";
+    }
+
+    public boolean isFlatWorld() {
+        return this.worldDataServer.getGeneratorSettings().isFlatWorld(); // CraftBukkit
+    }
+
+    @Override
+    public long getSeed() {
+        return this.worldDataServer.getGeneratorSettings().getSeed(); // CraftBukkit
+    }
+
+    @Nullable
+    public EnderDragonBattle getDragonBattle() {
+        return this.dragonBattle;
+    }
+
+    @Override
+    public Stream<? extends StructureStart<?>> a(SectionPosition sectionposition, StructureGenerator<?> structuregenerator) {
+        return this.getStructureManager().a(sectionposition, structuregenerator);
+    }
+
+    @Override
+    public WorldServer getMinecraftWorld() {
+        return this;
+    }
+
+    @VisibleForTesting
+    public String H() {
+        return String.format("players: %s, entities: %s [%s], block_entities: %d [%s], block_ticks: %d, fluid_ticks: %d, chunk_source: %s", this.players.size(), this.y.e(), a(this.y.d().iterable(), (entity) -> {
+            return IRegistry.ENTITY_TYPE.getKey(entity.getEntityType()).toString();
+        }), this.tileEntityList.size(), a((Iterable) this.tileEntityList, ITickable::d), this.getBlockTickList().a(), this.getFluidTickList().a(), this.J());
+    }
+
+    private static <T> String a(Iterable<T> iterable, Function<T, String> function) {
+        try {
+            Object2IntOpenHashMap<String> object2intopenhashmap = new Object2IntOpenHashMap();
+            Iterator<T> iterator = iterable.iterator(); // CraftBukkit - decompile error
+
+            while (iterator.hasNext()) {
+                T t0 = iterator.next();
+                String s = (String) function.apply(t0);
+
+                object2intopenhashmap.addTo(s, 1);
+            }
+
+            return (String) object2intopenhashmap.object2IntEntrySet().stream().sorted(Comparator.comparing(Entry<String>::getIntValue).reversed()).limit(5L).map((entry) -> { // CraftBukkit - decompile error
+                return (String) entry.getKey() + ":" + entry.getIntValue();
+            }).collect(Collectors.joining(","));
+        } catch (Exception exception) {
+            return "";
+        }
+    }
+
+    public static void a(WorldServer worldserver) {
+        // CraftBukkit start
+        WorldServer.a(worldserver, null);
+    }
+
+    public static void a(WorldServer worldserver, Entity entity) {
+        // CraftBukkit end
+        BlockPosition blockposition = WorldServer.a;
+        int i = blockposition.getX();
+        int j = blockposition.getY() - 2;
+        int k = blockposition.getZ();
+
+        // CraftBukkit start
+        org.bukkit.craftbukkit.util.BlockStateListPopulator blockList = new org.bukkit.craftbukkit.util.BlockStateListPopulator(worldserver);
+        BlockPosition.b(i - 2, j + 1, k - 2, i + 2, j + 3, k + 2).forEach((blockposition1) -> {
+            blockList.setTypeAndData(blockposition1, Blocks.AIR.getBlockData(), 3);
+        });
+        BlockPosition.b(i - 2, j, k - 2, i + 2, j, k + 2).forEach((blockposition1) -> {
+            blockList.setTypeAndData(blockposition1, Blocks.OBSIDIAN.getBlockData(), 3);
+        });
+        org.bukkit.World bworld = worldserver.getWorld();
+        org.bukkit.event.world.PortalCreateEvent portalEvent = new org.bukkit.event.world.PortalCreateEvent((List<org.bukkit.block.BlockState>) (List) blockList.getList(), bworld, (entity == null) ? null : entity.getBukkitEntity(), org.bukkit.event.world.PortalCreateEvent.CreateReason.END_PLATFORM);
+
+        worldserver.getServer().getPluginManager().callEvent(portalEvent);
+        if (!portalEvent.isCancelled()) {
+            blockList.updateList();
+        }
+        // CraftBukkit end
+    }
+
+    @Override
+    public WorldEntityGetter<Entity> getEntities() {
+        return this.y.d();
+    }
+
+    public void a(Stream<Entity> stream) {
+        this.y.a(stream);
+    }
+
+    public void b(Stream<Entity> stream) {
+        this.y.b(stream);
+    }
+
+    @Override
+    public void close() throws IOException {
+        super.close();
+        this.y.close();
+    }
+
+    public String J() {
+        return "Chunks[S] W: " + this.chunkProvider.getName() + " E: " + this.y.e();
+    }
+
+    final class a implements WorldCallback<Entity> {
+
+        private a() {}
+
+        public void f(Entity entity) {}
+
+        public void e(Entity entity) {
+            WorldServer.this.getScoreboard().a(entity);
+        }
+
+        public void d(Entity entity) {
+            WorldServer.this.x.a(entity);
+        }
+
+        public void c(Entity entity) {
+            WorldServer.this.x.b(entity);
+        }
+
+        public void b(Entity entity) {
+            WorldServer.this.getChunkProvider().removeEntity(entity);
+            if (entity instanceof EntityPlayer) {
+                WorldServer.this.players.add((EntityPlayer) entity);
+                WorldServer.this.everyoneSleeping();
+            }
+
+            if (entity instanceof EntityInsentient) {
+                WorldServer.this.navigators.add((EntityInsentient) entity);
+            }
+
+            if (entity instanceof EntityEnderDragon) {
+                EntityComplexPart[] aentitycomplexpart = ((EntityEnderDragon) entity).fe();
+                int i = aentitycomplexpart.length;
+
+                for (int j = 0; j < i; ++j) {
+                    EntityComplexPart entitycomplexpart = aentitycomplexpart[j];
+
+                    WorldServer.this.J.put(entitycomplexpart.getId(), entitycomplexpart);
+                }
+            }
+
+        }
+
+        public void a(Entity entity) {
+            WorldServer.this.getChunkProvider().a(entity);
+            if (entity instanceof EntityPlayer) {
+                EntityPlayer entityplayer = (EntityPlayer) entity;
+
+                WorldServer.this.players.remove(entityplayer);
+                WorldServer.this.everyoneSleeping();
+            }
+
+            if (entity instanceof EntityInsentient) {
+                WorldServer.this.navigators.remove(entity);
+            }
+            entity.valid = false; // CraftBukkit
+
+            if (entity instanceof EntityEnderDragon) {
+                EntityComplexPart[] aentitycomplexpart = ((EntityEnderDragon) entity).fe();
+                int i = aentitycomplexpart.length;
+
+                for (int j = 0; j < i; ++j) {
+                    EntityComplexPart entitycomplexpart = aentitycomplexpart[j];
+
+                    WorldServer.this.J.remove(entitycomplexpart.getId());
+                }
+            }
+
+            clc clc = entity.bI();
+
+            if (clc != null) {
+                clc.a(entity.world);
+            }
+
+        }
+    }
+}
diff --git a/src/main/java/org/bukkit/craftbukkit/SpigotTimings.java b/src/main/java/org/bukkit/craftbukkit/SpigotTimings.java
index a0bf9731..7f435847 100644
--- a/src/main/java/org/bukkit/craftbukkit/SpigotTimings.java
+++ b/src/main/java/org/bukkit/craftbukkit/SpigotTimings.java
@@ -39,6 +39,9 @@ public class SpigotTimings {
 
     public static final CustomTimingsHandler playerCommandTimer = new CustomTimingsHandler("** playerCommand");
 
+    public static final CustomTimingsHandler entityActivationCheckTimer = new CustomTimingsHandler("entityActivationCheck");
+    public static final CustomTimingsHandler checkIfActiveTimer = new CustomTimingsHandler("** checkIfActive");
+
     public static final HashMap<String, CustomTimingsHandler> entityTypeTimingMap = new HashMap<String, CustomTimingsHandler>();
     public static final HashMap<String, CustomTimingsHandler> tileEntityTypeTimingMap = new HashMap<String, CustomTimingsHandler>();
     public static final HashMap<String, CustomTimingsHandler> pluginTaskTimingMap = new HashMap<String, CustomTimingsHandler>();
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java
index ecee379a..ba1d644a 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java
@@ -493,6 +493,7 @@ public abstract class CraftEntity implements org.bukkit.entity.Entity {
         entity.setLocation(location.getX(), location.getY(), location.getZ(), location.getYaw(), location.getPitch());
         // SPIGOT-619: Force sync head rotation also
         entity.setHeadRotation(location.getYaw());
+        entity.stopRiding();
 
         return true;
     }
diff --git a/src/main/java/org/spigotmc/ActivationRange.java b/src/main/java/org/spigotmc/ActivationRange.java
new file mode 100644
index 00000000..4abbe516
--- /dev/null
+++ b/src/main/java/org/spigotmc/ActivationRange.java
@@ -0,0 +1,277 @@
+package org.spigotmc;
+
+import java.util.Collection;
+import net.minecraft.server.AxisAlignedBB;
+import net.minecraft.server.Chunk;
+import net.minecraft.server.Entity;
+import net.minecraft.server.EntityAmbient;
+import net.minecraft.server.EntityAnimal;
+import net.minecraft.server.EntityArrow;
+import net.minecraft.server.EntityComplexPart;
+import net.minecraft.server.EntityCreature;
+import net.minecraft.server.EntityCreeper;
+import net.minecraft.server.EntityEnderCrystal;
+import net.minecraft.server.EntityEnderDragon;
+import net.minecraft.server.EntityFireball;
+import net.minecraft.server.EntityFireworks;
+import net.minecraft.server.EntityHuman;
+import net.minecraft.server.EntityLightning;
+import net.minecraft.server.EntityLiving;
+import net.minecraft.server.EntityMonster;
+import net.minecraft.server.EntityProjectile;
+import net.minecraft.server.EntityRaider;
+import net.minecraft.server.EntitySheep;
+import net.minecraft.server.EntitySlice;
+import net.minecraft.server.EntitySlime;
+import net.minecraft.server.EntityTNTPrimed;
+import net.minecraft.server.EntityThrownTrident;
+import net.minecraft.server.EntityVillager;
+import net.minecraft.server.EntityWither;
+import net.minecraft.server.MathHelper;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.World;
+import org.bukkit.craftbukkit.SpigotTimings;
+
+public class ActivationRange
+{
+
+    public enum ActivationType
+    {
+        MONSTER,
+        ANIMAL,
+        RAIDER,
+        MISC;
+
+        AxisAlignedBB boundingBox = new AxisAlignedBB( 0, 0, 0, 0, 0, 0 );
+    }
+
+    static AxisAlignedBB maxBB = new AxisAlignedBB( 0, 0, 0, 0, 0, 0 );
+
+    /**
+     * Initializes an entities type on construction to specify what group this
+     * entity is in for activation ranges.
+     *
+     * @param entity
+     * @return group id
+     */
+    public static ActivationType initializeEntityActivationType(Entity entity)
+    {
+        if ( entity instanceof EntityRaider )
+        {
+            return ActivationType.RAIDER;
+        } else if ( entity instanceof EntityMonster || entity instanceof EntitySlime )
+        {
+            return ActivationType.MONSTER;
+        } else if ( entity instanceof EntityCreature || entity instanceof EntityAmbient )
+        {
+            return ActivationType.ANIMAL;
+        } else
+        {
+            return ActivationType.MISC;
+        }
+    }
+
+    /**
+     * These entities are excluded from Activation range checks.
+     *
+     * @param entity
+     * @param config
+     * @return boolean If it should always tick.
+     */
+    public static boolean initializeEntityActivationState(Entity entity, SpigotWorldConfig config)
+    {
+        if ( ( entity.activationType == ActivationType.MISC && config.miscActivationRange == 0 )
+                || ( entity.activationType == ActivationType.RAIDER && config.raiderActivationRange == 0 )
+                || ( entity.activationType == ActivationType.ANIMAL && config.animalActivationRange == 0 )
+                || ( entity.activationType == ActivationType.MONSTER && config.monsterActivationRange == 0 )
+                || entity instanceof EntityHuman
+                || entity instanceof EntityProjectile
+                || entity instanceof EntityEnderDragon
+                || entity instanceof EntityComplexPart
+                || entity instanceof EntityWither
+                || entity instanceof EntityFireball
+                || entity instanceof EntityLightning
+                || entity instanceof EntityTNTPrimed
+                || entity instanceof EntityEnderCrystal
+                || entity instanceof EntityFireworks
+                || entity instanceof EntityThrownTrident )
+        {
+            return true;
+        }
+
+        return false;
+    }
+
+    /**
+     * Find what entities are in range of the players in the world and set
+     * active if in range.
+     *
+     * @param world
+     */
+    public static void activateEntities(World world)
+    {
+        SpigotTimings.entityActivationCheckTimer.startTiming();
+        final int miscActivationRange = world.spigotConfig.miscActivationRange;
+        final int raiderActivationRange = world.spigotConfig.raiderActivationRange;
+        final int animalActivationRange = world.spigotConfig.animalActivationRange;
+        final int monsterActivationRange = world.spigotConfig.monsterActivationRange;
+
+        int maxRange = Math.max( monsterActivationRange, animalActivationRange );
+        maxRange = Math.max( maxRange, raiderActivationRange );
+        maxRange = Math.max( maxRange, miscActivationRange );
+        maxRange = Math.min( ( world.spigotConfig.viewDistance << 4 ) - 8, maxRange );
+
+        for ( EntityHuman player : world.getPlayers() )
+        {
+
+            player.activatedTick = MinecraftServer.currentTick;
+            maxBB = player.getBoundingBox().grow( maxRange, 256, maxRange );
+            ActivationType.MISC.boundingBox = player.getBoundingBox().grow( miscActivationRange, 256, miscActivationRange );
+            ActivationType.RAIDER.boundingBox = player.getBoundingBox().grow( raiderActivationRange, 256, raiderActivationRange );
+            ActivationType.ANIMAL.boundingBox = player.getBoundingBox().grow( animalActivationRange, 256, animalActivationRange );
+            ActivationType.MONSTER.boundingBox = player.getBoundingBox().grow( monsterActivationRange, 256, monsterActivationRange );
+
+            int i = MathHelper.floor( maxBB.minX / 16.0D );
+            int j = MathHelper.floor( maxBB.maxX / 16.0D );
+            int k = MathHelper.floor( maxBB.minZ / 16.0D );
+            int l = MathHelper.floor( maxBB.maxZ / 16.0D );
+
+            for ( int i1 = i; i1 <= j; ++i1 )
+            {
+                for ( int j1 = k; j1 <= l; ++j1 )
+                {
+                    if ( world.getWorld().isChunkLoaded( i1, j1 ) )
+                    {
+                        activateChunkEntities( world.getChunkAt( i1, j1 ) );
+                    }
+                }
+            }
+        }
+        SpigotTimings.entityActivationCheckTimer.stopTiming();
+    }
+
+    /**
+     * Checks for the activation state of all entities in this chunk.
+     *
+     * @param chunk
+     */
+    private static void activateChunkEntities(Chunk chunk)
+    {
+        for ( EntitySlice slice : chunk.entitySlices )
+        {
+            for ( Entity entity : (Collection<Entity>) slice )
+            {
+                if ( MinecraftServer.currentTick > entity.activatedTick )
+                {
+                    if ( entity.defaultActivationState )
+                    {
+                        entity.activatedTick = MinecraftServer.currentTick;
+                        continue;
+                    }
+                    if ( entity.activationType.boundingBox.c( entity.getBoundingBox() ) )
+                    {
+                        entity.activatedTick = MinecraftServer.currentTick;
+                    }
+                }
+            }
+        }
+    }
+
+    /**
+     * If an entity is not in range, do some more checks to see if we should
+     * give it a shot.
+     *
+     * @param entity
+     * @return
+     */
+    public static boolean checkEntityImmunities(Entity entity)
+    {
+        // quick checks.
+        if ( entity.inWater || entity.fireTicks > 0 )
+        {
+            return true;
+        }
+        if ( !( entity instanceof EntityArrow ) )
+        {
+            if ( !entity.isOnGround() || !entity.passengers.isEmpty() || entity.isPassenger() )
+            {
+                return true;
+            }
+        } else if ( !( (EntityArrow) entity ).inGround )
+        {
+            return true;
+        }
+        // special cases.
+        if ( entity instanceof EntityLiving )
+        {
+            EntityLiving living = (EntityLiving) entity;
+            if ( /*TODO: Missed mapping? living.attackTicks > 0 || */ living.hurtTicks > 0 || living.effects.size() > 0 )
+            {
+                return true;
+            }
+            if ( entity instanceof EntityCreature && ( (EntityCreature) entity ).getGoalTarget() != null )
+            {
+                return true;
+            }
+            if ( entity instanceof EntityVillager && ( (EntityVillager) entity ).canBreed() )
+            {
+                return true;
+            }
+            if ( entity instanceof EntityAnimal )
+            {
+                EntityAnimal animal = (EntityAnimal) entity;
+                if ( animal.isBaby() || animal.isInLove() )
+                {
+                    return true;
+                }
+                if ( entity instanceof EntitySheep && ( (EntitySheep) entity ).isSheared() )
+                {
+                    return true;
+                }
+            }
+            if (entity instanceof EntityCreeper && ((EntityCreeper) entity).isIgnited()) { // isExplosive
+                return true;
+            }
+        }
+        return false;
+    }
+
+    /**
+     * Checks if the entity is active for this tick.
+     *
+     * @param entity
+     * @return
+     */
+    public static boolean checkIfActive(Entity entity)
+    {
+        SpigotTimings.checkIfActiveTimer.startTiming();
+        // Never safe to skip fireworks or entities not yet added to chunk
+        if ( !entity.inChunk || entity instanceof EntityFireworks ) {
+            SpigotTimings.checkIfActiveTimer.stopTiming();
+            return true;
+        }
+
+        boolean isActive = entity.activatedTick >= MinecraftServer.currentTick || entity.defaultActivationState;
+
+        // Should this entity tick?
+        if ( !isActive )
+        {
+            if ( ( MinecraftServer.currentTick - entity.activatedTick - 1 ) % 20 == 0 )
+            {
+                // Check immunities every 20 ticks.
+                if ( checkEntityImmunities( entity ) )
+                {
+                    // Triggered some sort of immunity, give 20 full ticks before we check again.
+                    entity.activatedTick = MinecraftServer.currentTick + 20;
+                }
+                isActive = true;
+            }
+            // Add a little performance juice to active entities. Skip 1/4 if not immune.
+        } else if ( !entity.defaultActivationState && entity.ticksLived % 4 == 0 && !checkEntityImmunities( entity ) )
+        {
+            isActive = false;
+        }
+        SpigotTimings.checkIfActiveTimer.stopTiming();
+        return isActive;
+    }
+}
diff --git a/src/main/java/org/spigotmc/SpigotWorldConfig.java b/src/main/java/org/spigotmc/SpigotWorldConfig.java
index 7dd66b48..d873b32b 100644
--- a/src/main/java/org/spigotmc/SpigotWorldConfig.java
+++ b/src/main/java/org/spigotmc/SpigotWorldConfig.java
@@ -175,4 +175,19 @@ public class SpigotWorldConfig
         itemDespawnRate = getInt( "item-despawn-rate", 6000 );
         log( "Item Despawn Rate: " + itemDespawnRate );
     }
+
+    public int animalActivationRange = 32;
+    public int monsterActivationRange = 32;
+    public int raiderActivationRange = 48;
+    public int miscActivationRange = 16;
+    public boolean tickInactiveVillagers = true;
+    private void activationRange()
+    {
+        animalActivationRange = getInt( "entity-activation-range.animals", animalActivationRange );
+        monsterActivationRange = getInt( "entity-activation-range.monsters", monsterActivationRange );
+        raiderActivationRange = getInt( "entity-activation-range.raiders", raiderActivationRange );
+        miscActivationRange = getInt( "entity-activation-range.misc", miscActivationRange );
+        tickInactiveVillagers = getBoolean( "entity-activation-range.tick-inactive-villagers", tickInactiveVillagers );
+        log( "Entity Activation Range: An " + animalActivationRange + " / Mo " + monsterActivationRange + " / Ra " + raiderActivationRange + " / Mi " + miscActivationRange + " / Tiv " + tickInactiveVillagers );
+    }
 }
-- 
2.21.0.windows.1

