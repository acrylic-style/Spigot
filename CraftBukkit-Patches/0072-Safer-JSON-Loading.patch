From 9c06da4ceefdadb5bba136b8c45a0277ed61bda5 Mon Sep 17 00:00:00 2001
From: Suddenly <suddenly@suddenly.coffee>
Date: Tue, 8 Jul 2014 09:44:18 +1000
Subject: [PATCH] Safer JSON Loading


diff --git a/src/main/java/net/minecraft/server/BlockBase.java b/src/main/java/net/minecraft/server/BlockBase.java
index f28b9c09..b298d45d 100644
--- a/src/main/java/net/minecraft/server/BlockBase.java
+++ b/src/main/java/net/minecraft/server/BlockBase.java
@@ -23,11 +23,11 @@ public abstract class BlockBase {
     protected final float speedFactor;
     protected final float jumpFactor;
     protected final boolean aA;
-    protected final BlockBase.Info aB;
+    protected final Info aB;
     @Nullable
     protected MinecraftKey aC;
 
-    public BlockBase(BlockBase.Info blockbase_info) {
+    public BlockBase(Info blockbase_info) {
         this.material = blockbase_info.a;
         this.at = blockbase_info.c;
         this.aC = blockbase_info.m;
@@ -69,15 +69,12 @@ public abstract class BlockBase {
     }
 
     @Deprecated
-    public void onPlace(IBlockData iblockdata, World world, BlockPosition blockposition, IBlockData iblockdata1, boolean flag) {
-        org.spigotmc.AsyncCatcher.catchOp("block onPlace"); // Spigot
-    }
+    public void onPlace(IBlockData iblockdata, World world, BlockPosition blockposition, IBlockData iblockdata1, boolean flag) {}
 
     @Deprecated
     public void remove(IBlockData iblockdata, World world, BlockPosition blockposition, IBlockData iblockdata1, boolean flag) {
-        org.spigotmc.AsyncCatcher.catchOp("block remove"); // Spigot
-        if (this.isTileEntity() && !iblockdata.a(iblockdata1.getBlock())) {
-            world.removeTileEntity(blockposition);
+        if (iblockdata.isTileEntity() && !iblockdata.a(iblockdata1.getBlock())) {
+            world.l(blockposition);
         }
 
     }
@@ -93,12 +90,12 @@ public abstract class BlockBase {
     }
 
     @Deprecated
-    public EnumRenderType b(IBlockData iblockdata) {
+    public EnumRenderType a_(IBlockData iblockdata) {
         return EnumRenderType.MODEL;
     }
 
     @Deprecated
-    public boolean c_(IBlockData iblockdata) {
+    public boolean e_(IBlockData iblockdata) {
         return false;
     }
 
@@ -118,12 +115,16 @@ public abstract class BlockBase {
     }
 
     @Deprecated
-    public boolean isComplexRedstone(IBlockData iblockdata) {
+    public boolean b(IBlockData iblockdata) {
         return false;
     }
 
-    public BlockBase.EnumRandomOffset ah_() {
-        return BlockBase.EnumRandomOffset.NONE;
+    public EnumRandomOffset ai_() {
+        return EnumRandomOffset.NONE;
+    }
+
+    public float am_() {
+        return 0.25F;
     }
 
     @Deprecated
@@ -138,7 +139,7 @@ public abstract class BlockBase {
 
     @Deprecated
     public boolean a(IBlockData iblockdata, BlockActionContext blockactioncontext) {
-        return this.material.isReplaceable() && (blockactioncontext.getItemStack().isEmpty() || blockactioncontext.getItemStack().getItem() != this.getItem());
+        return this.material.isReplaceable() && (blockactioncontext.getItemStack().isEmpty() || !blockactioncontext.getItemStack().a(this.getItem()));
     }
 
     @Deprecated
@@ -148,7 +149,7 @@ public abstract class BlockBase {
 
     @Deprecated
     public List<ItemStack> a(IBlockData iblockdata, LootTableInfo.Builder loottableinfo_builder) {
-        MinecraftKey minecraftkey = this.r();
+        MinecraftKey minecraftkey = this.q();
 
         if (minecraftkey == LootTables.a) {
             return Collections.emptyList();
@@ -162,7 +163,7 @@ public abstract class BlockBase {
     }
 
     @Deprecated
-    public VoxelShape d(IBlockData iblockdata, IBlockAccess iblockaccess, BlockPosition blockposition) {
+    public VoxelShape a_(IBlockData iblockdata, IBlockAccess iblockaccess, BlockPosition blockposition) {
         return iblockdata.getShape(iblockaccess, blockposition);
     }
 
@@ -172,13 +173,13 @@ public abstract class BlockBase {
     }
 
     @Deprecated
-    public VoxelShape a_(IBlockData iblockdata, IBlockAccess iblockaccess, BlockPosition blockposition) {
+    public VoxelShape a(IBlockData iblockdata, IBlockAccess iblockaccess, BlockPosition blockposition) {
         return VoxelShapes.a();
     }
 
     @Deprecated
     public int f(IBlockData iblockdata, IBlockAccess iblockaccess, BlockPosition blockposition) {
-        return iblockdata.i(iblockaccess, blockposition) ? iblockaccess.K() : (iblockdata.a(iblockaccess, blockposition) ? 0 : 1);
+        return iblockdata.i(iblockaccess, blockposition) ? iblockaccess.O() : (iblockdata.a(iblockaccess, blockposition) ? 0 : 1);
     }
 
     @Nullable
@@ -198,7 +199,7 @@ public abstract class BlockBase {
     }
 
     @Deprecated
-    public VoxelShape b(IBlockData iblockdata, IBlockAccess iblockaccess, BlockPosition blockposition, VoxelShapeCollision voxelshapecollision) {
+    public VoxelShape a(IBlockData iblockdata, IBlockAccess iblockaccess, BlockPosition blockposition, VoxelShapeCollision voxelshapecollision) {
         return VoxelShapes.b();
     }
 
@@ -208,7 +209,7 @@ public abstract class BlockBase {
     }
 
     @Deprecated
-    public VoxelShape a(IBlockData iblockdata, IBlockAccess iblockaccess, BlockPosition blockposition, VoxelShapeCollision voxelshapecollision) {
+    public VoxelShape b(IBlockData iblockdata, IBlockAccess iblockaccess, BlockPosition blockposition, VoxelShapeCollision voxelshapecollision) {
         return this.c(iblockdata, iblockaccess, blockposition, voxelshapecollision);
     }
 
@@ -252,11 +253,7 @@ public abstract class BlockBase {
         return 0;
     }
 
-    public final boolean isTileEntity() {
-        return this instanceof ITileEntity;
-    }
-
-    public final MinecraftKey r() {
+    public final MinecraftKey q() {
         if (this.aC == null) {
             MinecraftKey minecraftkey = IRegistry.BLOCK.getKey(this.p());
 
@@ -273,7 +270,7 @@ public abstract class BlockBase {
 
     protected abstract Block p();
 
-    public MaterialMapColor s() {
+    public MaterialMapColor r() {
         return (MaterialMapColor) this.aB.b.apply(this.p().getBlockData());
     }
 
@@ -303,17 +300,17 @@ public abstract class BlockBase {
         private final BlockBase.e o;
         private final BlockBase.e p;
         @Nullable
-        protected BlockBase.BlockData.Cache a;
+        protected Cache a;
 
         protected BlockData(Block block, ImmutableMap<IBlockState<?>, Comparable<?>> immutablemap, MapCodec<IBlockData> mapcodec) {
             super(block, immutablemap, mapcodec);
-            BlockBase.Info blockbase_info = block.aB;
+            Info blockbase_info = block.aB;
 
-            this.b = blockbase_info.e.applyAsInt(this.p());
-            this.e = block.c_(this.p());
+            this.b = blockbase_info.e.applyAsInt(this.q());
+            this.e = block.e_(this.q());
             this.f = blockbase_info.o;
             this.g = blockbase_info.a;
-            this.h = (MaterialMapColor) blockbase_info.b.apply(this.p());
+            this.h = (MaterialMapColor) blockbase_info.b.apply(this.q());
             this.strength = blockbase_info.g;
             this.j = blockbase_info.h;
             this.k = blockbase_info.n;
@@ -326,7 +323,7 @@ public abstract class BlockBase {
 
         public void a() {
             if (!this.getBlock().o()) {
-                this.a = new BlockBase.BlockData.Cache(this.p());
+                this.a = new Cache(this.q());
             }
 
         }
@@ -340,15 +337,15 @@ public abstract class BlockBase {
         }
 
         public boolean a(IBlockAccess iblockaccess, BlockPosition blockposition, EntityTypes<?> entitytypes) {
-            return this.getBlock().aB.p.test(this.p(), iblockaccess, blockposition, entitytypes);
+            return this.getBlock().aB.p.test(this.q(), iblockaccess, blockposition, entitytypes);
         }
 
         public boolean a(IBlockAccess iblockaccess, BlockPosition blockposition) {
-            return this.a != null ? this.a.g : this.getBlock().b(this.p(), iblockaccess, blockposition);
+            return this.a != null ? this.a.g : this.getBlock().c(this.q(), iblockaccess, blockposition);
         }
 
         public int b(IBlockAccess iblockaccess, BlockPosition blockposition) {
-            return this.a != null ? this.a.h : this.getBlock().f(this.p(), iblockaccess, blockposition);
+            return this.a != null ? this.a.h : this.getBlock().f(this.q(), iblockaccess, blockposition);
         }
 
         public VoxelShape a(IBlockAccess iblockaccess, BlockPosition blockposition, EnumDirection enumdirection) {
@@ -356,7 +353,7 @@ public abstract class BlockBase {
         }
 
         public VoxelShape c(IBlockAccess iblockaccess, BlockPosition blockposition) {
-            return this.getBlock().d(this.p(), iblockaccess, blockposition);
+            return this.getBlock().a_(this.q(), iblockaccess, blockposition);
         }
 
         public boolean d() {
@@ -380,35 +377,35 @@ public abstract class BlockBase {
         }
 
         public IBlockData a(EnumBlockRotation enumblockrotation) {
-            return this.getBlock().a(this.p(), enumblockrotation);
+            return this.getBlock().a(this.q(), enumblockrotation);
         }
 
         public IBlockData a(EnumBlockMirror enumblockmirror) {
-            return this.getBlock().a(this.p(), enumblockmirror);
+            return this.getBlock().a(this.q(), enumblockmirror);
         }
 
         public EnumRenderType h() {
-            return this.getBlock().b(this.p());
+            return this.getBlock().a_(this.q());
         }
 
         public boolean isOccluding(IBlockAccess iblockaccess, BlockPosition blockposition) {
-            return this.l.test(this.p(), iblockaccess, blockposition);
+            return this.l.test(this.q(), iblockaccess, blockposition);
         }
 
         public boolean isPowerSource() {
-            return this.getBlock().isPowerSource(this.p());
+            return this.getBlock().isPowerSource(this.q());
         }
 
         public int b(IBlockAccess iblockaccess, BlockPosition blockposition, EnumDirection enumdirection) {
-            return this.getBlock().a(this.p(), iblockaccess, blockposition, enumdirection);
+            return this.getBlock().a(this.q(), iblockaccess, blockposition, enumdirection);
         }
 
         public boolean isComplexRedstone() {
-            return this.getBlock().isComplexRedstone(this.p());
+            return this.getBlock().b(this.q());
         }
 
         public int a(World world, BlockPosition blockposition) {
-            return this.getBlock().a(this.p(), world, blockposition);
+            return this.getBlock().a(this.q(), world, blockposition);
         }
 
         public float h(IBlockAccess iblockaccess, BlockPosition blockposition) {
@@ -416,22 +413,22 @@ public abstract class BlockBase {
         }
 
         public float getDamage(EntityHuman entityhuman, IBlockAccess iblockaccess, BlockPosition blockposition) {
-            return this.getBlock().getDamage(this.p(), entityhuman, iblockaccess, blockposition);
+            return this.getBlock().getDamage(this.q(), entityhuman, iblockaccess, blockposition);
         }
 
         public int c(IBlockAccess iblockaccess, BlockPosition blockposition, EnumDirection enumdirection) {
-            return this.getBlock().b(this.p(), iblockaccess, blockposition, enumdirection);
+            return this.getBlock().b(this.q(), iblockaccess, blockposition, enumdirection);
         }
 
         public EnumPistonReaction getPushReaction() {
-            return this.getBlock().getPushReaction(this.p());
+            return this.getBlock().getPushReaction(this.q());
         }
 
         public boolean i(IBlockAccess iblockaccess, BlockPosition blockposition) {
             if (this.a != null) {
                 return this.a.a;
             } else {
-                IBlockData iblockdata = this.p();
+                IBlockData iblockdata = this.q();
 
                 return iblockdata.l() ? Block.a(iblockdata.c(iblockaccess, blockposition)) : false;
             }
@@ -446,7 +443,7 @@ public abstract class BlockBase {
         }
 
         public VoxelShape a(IBlockAccess iblockaccess, BlockPosition blockposition, VoxelShapeCollision voxelshapecollision) {
-            return this.getBlock().b(this.p(), iblockaccess, blockposition, voxelshapecollision);
+            return this.getBlock().a(this.q(), iblockaccess, blockposition, voxelshapecollision);
         }
 
         public VoxelShape getCollisionShape(IBlockAccess iblockaccess, BlockPosition blockposition) {
@@ -454,19 +451,19 @@ public abstract class BlockBase {
         }
 
         public VoxelShape b(IBlockAccess iblockaccess, BlockPosition blockposition, VoxelShapeCollision voxelshapecollision) {
-            return this.getBlock().c(this.p(), iblockaccess, blockposition, voxelshapecollision);
+            return this.getBlock().c(this.q(), iblockaccess, blockposition, voxelshapecollision);
         }
 
         public VoxelShape l(IBlockAccess iblockaccess, BlockPosition blockposition) {
-            return this.getBlock().e(this.p(), iblockaccess, blockposition);
+            return this.getBlock().e(this.q(), iblockaccess, blockposition);
         }
 
         public VoxelShape c(IBlockAccess iblockaccess, BlockPosition blockposition, VoxelShapeCollision voxelshapecollision) {
-            return this.getBlock().a(this.p(), iblockaccess, blockposition, voxelshapecollision);
+            return this.getBlock().b(this.q(), iblockaccess, blockposition, voxelshapecollision);
         }
 
         public VoxelShape m(IBlockAccess iblockaccess, BlockPosition blockposition) {
-            return this.getBlock().a_(this.p(), iblockaccess, blockposition);
+            return this.getBlock().a(this.q(), iblockaccess, blockposition);
         }
 
         public final boolean a(IBlockAccess iblockaccess, BlockPosition blockposition, Entity entity) {
@@ -478,23 +475,28 @@ public abstract class BlockBase {
         }
 
         public Vec3D n(IBlockAccess iblockaccess, BlockPosition blockposition) {
-            BlockBase.EnumRandomOffset blockbase_enumrandomoffset = this.getBlock().ah_();
+            Block block = this.getBlock();
+            EnumRandomOffset blockbase_enumrandomoffset = block.ai_();
 
-            if (blockbase_enumrandomoffset == BlockBase.EnumRandomOffset.NONE) {
+            if (blockbase_enumrandomoffset == EnumRandomOffset.NONE) {
                 return Vec3D.ORIGIN;
             } else {
                 long i = MathHelper.c(blockposition.getX(), 0, blockposition.getZ());
+                float f = block.am_();
+                double d0 = MathHelper.a(((double) ((float) (i & 15L) / 15.0F) - 0.5D) * 0.5D, (double) (-f), (double) f);
+                double d1 = blockbase_enumrandomoffset == EnumRandomOffset.XYZ ? ((double) ((float) (i >> 4 & 15L) / 15.0F) - 1.0D) * 0.2D : 0.0D;
+                double d2 = MathHelper.a(((double) ((float) (i >> 8 & 15L) / 15.0F) - 0.5D) * 0.5D, (double) (-f), (double) f);
 
-                return new Vec3D(((double) ((float) (i & 15L) / 15.0F) - 0.5D) * 0.5D, blockbase_enumrandomoffset == BlockBase.EnumRandomOffset.XYZ ? ((double) ((float) (i >> 4 & 15L) / 15.0F) - 1.0D) * 0.2D : 0.0D, ((double) ((float) (i >> 8 & 15L) / 15.0F) - 0.5D) * 0.5D);
+                return new Vec3D(d0, d1, d2);
             }
         }
 
         public boolean a(World world, BlockPosition blockposition, int i, int j) {
-            return this.getBlock().a(this.p(), world, blockposition, i, j);
+            return this.getBlock().a(this.q(), world, blockposition, i, j);
         }
 
         public void doPhysics(World world, BlockPosition blockposition, Block block, BlockPosition blockposition1, boolean flag) {
-            this.getBlock().doPhysics(this.p(), world, blockposition, block, blockposition1, flag);
+            this.getBlock().doPhysics(this.q(), world, blockposition, block, blockposition1, flag);
         }
 
         public final void a(GeneratorAccess generatoraccess, BlockPosition blockposition, int i) {
@@ -512,7 +514,7 @@ public abstract class BlockBase {
 
                 blockposition_mutableblockposition.a((BaseBlockPosition) blockposition, enumdirection);
                 IBlockData iblockdata = generatoraccess.getType(blockposition_mutableblockposition);
-                IBlockData iblockdata1 = iblockdata.updateState(enumdirection.opposite(), this.p(), generatoraccess, blockposition_mutableblockposition, blockposition);
+                IBlockData iblockdata1 = iblockdata.updateState(enumdirection.opposite(), this.q(), generatoraccess, blockposition_mutableblockposition, blockposition);
 
                 Block.a(iblockdata, iblockdata1, generatoraccess, blockposition_mutableblockposition, i, j);
             }
@@ -524,100 +526,109 @@ public abstract class BlockBase {
         }
 
         public void b(GeneratorAccess generatoraccess, BlockPosition blockposition, int i, int j) {
-            this.getBlock().a(this.p(), generatoraccess, blockposition, i, j);
+            this.getBlock().a(this.q(), generatoraccess, blockposition, i, j);
         }
 
         public void onPlace(World world, BlockPosition blockposition, IBlockData iblockdata, boolean flag) {
-            this.getBlock().onPlace(this.p(), world, blockposition, iblockdata, flag);
+            this.getBlock().onPlace(this.q(), world, blockposition, iblockdata, flag);
         }
 
         public void remove(World world, BlockPosition blockposition, IBlockData iblockdata, boolean flag) {
-            this.getBlock().remove(this.p(), world, blockposition, iblockdata, flag);
+            this.getBlock().remove(this.q(), world, blockposition, iblockdata, flag);
         }
 
         public void a(WorldServer worldserver, BlockPosition blockposition, Random random) {
-            this.getBlock().tickAlways(this.p(), worldserver, blockposition, random);
+            this.getBlock().tickAlways(this.q(), worldserver, blockposition, random);
         }
 
         public void b(WorldServer worldserver, BlockPosition blockposition, Random random) {
-            this.getBlock().tick(this.p(), worldserver, blockposition, random);
+            this.getBlock().tick(this.q(), worldserver, blockposition, random);
         }
 
         public void a(World world, BlockPosition blockposition, Entity entity) {
-            this.getBlock().a(this.p(), world, blockposition, entity);
+            this.getBlock().a(this.q(), world, blockposition, entity);
         }
 
         public void dropNaturally(WorldServer worldserver, BlockPosition blockposition, ItemStack itemstack) {
-            this.getBlock().dropNaturally(this.p(), worldserver, blockposition, itemstack);
+            this.getBlock().dropNaturally(this.q(), worldserver, blockposition, itemstack);
         }
 
         public List<ItemStack> a(LootTableInfo.Builder loottableinfo_builder) {
-            return this.getBlock().a(this.p(), loottableinfo_builder);
+            return this.getBlock().a(this.q(), loottableinfo_builder);
         }
 
         public EnumInteractionResult interact(World world, EntityHuman entityhuman, EnumHand enumhand, MovingObjectPositionBlock movingobjectpositionblock) {
-            return this.getBlock().interact(this.p(), world, movingobjectpositionblock.getBlockPosition(), entityhuman, enumhand, movingobjectpositionblock);
+            return this.getBlock().interact(this.q(), world, movingobjectpositionblock.getBlockPosition(), entityhuman, enumhand, movingobjectpositionblock);
         }
 
         public void attack(World world, BlockPosition blockposition, EntityHuman entityhuman) {
-            this.getBlock().attack(this.p(), world, blockposition, entityhuman);
+            this.getBlock().attack(this.q(), world, blockposition, entityhuman);
         }
 
         public boolean o(IBlockAccess iblockaccess, BlockPosition blockposition) {
-            return this.m.test(this.p(), iblockaccess, blockposition);
+            return this.m.test(this.q(), iblockaccess, blockposition);
         }
 
         public IBlockData updateState(EnumDirection enumdirection, IBlockData iblockdata, GeneratorAccess generatoraccess, BlockPosition blockposition, BlockPosition blockposition1) {
-            return this.getBlock().updateState(this.p(), enumdirection, iblockdata, generatoraccess, blockposition, blockposition1);
+            return this.getBlock().updateState(this.q(), enumdirection, iblockdata, generatoraccess, blockposition, blockposition1);
         }
 
         public boolean a(IBlockAccess iblockaccess, BlockPosition blockposition, PathMode pathmode) {
-            return this.getBlock().a(this.p(), iblockaccess, blockposition, pathmode);
+            return this.getBlock().a(this.q(), iblockaccess, blockposition, pathmode);
         }
 
         public boolean a(BlockActionContext blockactioncontext) {
-            return this.getBlock().a(this.p(), blockactioncontext);
+            return this.getBlock().a(this.q(), blockactioncontext);
         }
 
         public boolean a(FluidType fluidtype) {
-            return this.getBlock().a(this.p(), fluidtype);
+            return this.getBlock().a(this.q(), fluidtype);
         }
 
         public boolean canPlace(IWorldReader iworldreader, BlockPosition blockposition) {
-            return this.getBlock().canPlace(this.p(), iworldreader, blockposition);
+            return this.getBlock().canPlace(this.q(), iworldreader, blockposition);
         }
 
         public boolean q(IBlockAccess iblockaccess, BlockPosition blockposition) {
-            return this.o.test(this.p(), iblockaccess, blockposition);
+            return this.o.test(this.q(), iblockaccess, blockposition);
         }
 
         @Nullable
         public ITileInventory b(World world, BlockPosition blockposition) {
-            return this.getBlock().getInventory(this.p(), world, blockposition);
+            return this.getBlock().getInventory(this.q(), world, blockposition);
         }
 
         public boolean a(Tag<Block> tag) {
-            return this.getBlock().a(tag);
+            return tag.isTagged(this.getBlock());
         }
 
-        public boolean a(Tag<Block> tag, Predicate<BlockBase.BlockData> predicate) {
-            return this.getBlock().a(tag) && predicate.test(this);
+        public boolean a(Tag<Block> tag, Predicate<BlockData> predicate) {
+            return this.a(tag) && predicate.test(this);
+        }
+
+        public boolean isTileEntity() {
+            return this.getBlock() instanceof ITileEntity;
+        }
+
+        @Nullable
+        public <T extends TileEntity> TileEntityTicker<T> a(World world, TileEntityTypes<T> tileentitytypes) {
+            return this.getBlock() instanceof ITileEntity ? ((ITileEntity) this.getBlock()).a(world, this.q(), tileentitytypes) : null;
         }
 
         public boolean a(Block block) {
-            return this.getBlock().a(block);
+            return this.getBlock() == block;
         }
 
         public Fluid getFluid() {
-            return this.getBlock().d(this.p());
+            return this.getBlock().d(this.q());
         }
 
         public boolean isTicking() {
-            return this.getBlock().isTicking(this.p());
+            return this.getBlock().isTicking(this.q());
         }
 
         public SoundEffectType getStepSound() {
-            return this.getBlock().getStepSound(this.p());
+            return this.getBlock().l(this.q());
         }
 
         public void a(World world, IBlockData iblockdata, MovingObjectPositionBlock movingobjectpositionblock, IProjectile iprojectile) {
@@ -629,14 +640,14 @@ public abstract class BlockBase {
         }
 
         public boolean a(IBlockAccess iblockaccess, BlockPosition blockposition, EnumDirection enumdirection, EnumBlockSupport enumblocksupport) {
-            return this.a != null ? this.a.a(enumdirection, enumblocksupport) : enumblocksupport.a(this.p(), iblockaccess, blockposition, enumdirection);
+            return this.a != null ? this.a.a(enumdirection, enumblocksupport) : enumblocksupport.a(this.q(), iblockaccess, blockposition, enumdirection);
         }
 
         public boolean r(IBlockAccess iblockaccess, BlockPosition blockposition) {
             return this.a != null ? this.a.d : Block.a(this.getCollisionShape(iblockaccess, blockposition));
         }
 
-        protected abstract IBlockData p();
+        protected abstract IBlockData q();
 
         public boolean isRequiresSpecialTool() {
             return this.j;
@@ -660,16 +671,16 @@ public abstract class BlockBase {
                 Block block = iblockdata.getBlock();
 
                 this.a = iblockdata.i(BlockAccessAir.INSTANCE, BlockPosition.ZERO);
-                this.g = block.b(iblockdata, (IBlockAccess) BlockAccessAir.INSTANCE, BlockPosition.ZERO);
+                this.g = block.c(iblockdata, (IBlockAccess) BlockAccessAir.INSTANCE, BlockPosition.ZERO);
                 this.h = block.f(iblockdata, BlockAccessAir.INSTANCE, BlockPosition.ZERO);
                 int i;
 
                 if (!iblockdata.l()) {
                     this.i = null;
                 } else {
-                    this.i = new VoxelShape[BlockBase.BlockData.Cache.e.length];
-                    VoxelShape voxelshape = block.d(iblockdata, BlockAccessAir.INSTANCE, BlockPosition.ZERO);
-                    EnumDirection[] aenumdirection = BlockBase.BlockData.Cache.e;
+                    this.i = new VoxelShape[Cache.e.length];
+                    VoxelShape voxelshape = block.a_(iblockdata, BlockAccessAir.INSTANCE, BlockPosition.ZERO);
+                    EnumDirection[] aenumdirection = Cache.e;
 
                     i = aenumdirection.length;
 
@@ -684,8 +695,8 @@ public abstract class BlockBase {
                 this.c = Arrays.stream(EnumDirection.EnumAxis.values()).anyMatch((enumdirection_enumaxis) -> {
                     return this.b.b(enumdirection_enumaxis) < 0.0D || this.b.c(enumdirection_enumaxis) > 1.0D;
                 });
-                this.j = new boolean[BlockBase.BlockData.Cache.e.length * BlockBase.BlockData.Cache.f];
-                EnumDirection[] aenumdirection1 = BlockBase.BlockData.Cache.e;
+                this.j = new boolean[Cache.e.length * Cache.f];
+                EnumDirection[] aenumdirection1 = Cache.e;
                 int k = aenumdirection1.length;
 
                 for (i = 0; i < k; ++i) {
@@ -708,7 +719,7 @@ public abstract class BlockBase {
             }
 
             private static int b(EnumDirection enumdirection, EnumBlockSupport enumblocksupport) {
-                return enumdirection.ordinal() * BlockBase.BlockData.Cache.f + enumblocksupport.ordinal();
+                return enumdirection.ordinal() * Cache.f + enumblocksupport.ordinal();
             }
         }
     }
@@ -774,24 +785,24 @@ public abstract class BlockBase {
             this.b = function;
         }
 
-        public static BlockBase.Info a(Material material) {
+        public static Info a(Material material) {
             return a(material, material.h());
         }
 
-        public static BlockBase.Info a(Material material, EnumColor enumcolor) {
-            return a(material, enumcolor.f());
+        public static Info a(Material material, EnumColor enumcolor) {
+            return a(material, enumcolor.e());
         }
 
-        public static BlockBase.Info a(Material material, MaterialMapColor materialmapcolor) {
-            return new BlockBase.Info(material, materialmapcolor);
+        public static Info a(Material material, MaterialMapColor materialmapcolor) {
+            return new Info(material, materialmapcolor);
         }
 
-        public static BlockBase.Info a(Material material, Function<IBlockData, MaterialMapColor> function) {
-            return new BlockBase.Info(material, function);
+        public static Info a(Material material, Function<IBlockData, MaterialMapColor> function) {
+            return new Info(material, function);
         }
 
-        public static BlockBase.Info a(BlockBase blockbase) {
-            BlockBase.Info blockbase_info = new BlockBase.Info(blockbase.material, blockbase.aB.b);
+        public static Info a(BlockBase blockbase) {
+            Info blockbase_info = new Info(blockbase.material, blockbase.aB.b);
 
             blockbase_info.a = blockbase.aB.a;
             blockbase_info.g = blockbase.aB.g;
@@ -810,116 +821,123 @@ public abstract class BlockBase {
             return blockbase_info;
         }
 
-        public BlockBase.Info a() {
+        public Info a() {
             this.c = false;
             this.n = false;
             return this;
         }
 
-        public BlockBase.Info b() {
+        public Info b() {
             this.n = false;
             return this;
         }
 
-        public BlockBase.Info a(float f) {
+        public Info a(float f) {
             this.j = f;
             return this;
         }
 
-        public BlockBase.Info b(float f) {
+        public Info b(float f) {
             this.k = f;
             return this;
         }
 
-        public BlockBase.Info c(float f) {
+        public Info c(float f) {
             this.l = f;
             return this;
         }
 
-        public BlockBase.Info a(SoundEffectType soundeffecttype) {
+        public Info a(SoundEffectType soundeffecttype) {
             this.d = soundeffecttype;
             return this;
         }
 
-        public BlockBase.Info a(ToIntFunction<IBlockData> tointfunction) {
+        public Info a(ToIntFunction<IBlockData> tointfunction) {
             this.e = tointfunction;
             return this;
         }
 
-        public BlockBase.Info a(float f, float f1) {
+        public Info a(float f, float f1) {
             this.g = f;
             this.f = Math.max(0.0F, f1);
             return this;
         }
 
-        public BlockBase.Info c() {
+        public Info c() {
             return this.d(0.0F);
         }
 
-        public BlockBase.Info d(float f) {
+        public Info d(float f) {
             this.a(f, f);
             return this;
         }
 
-        public BlockBase.Info d() {
+        public Info d() {
             this.i = true;
             return this;
         }
 
-        public BlockBase.Info e() {
+        public Info e() {
             this.v = true;
             return this;
         }
 
-        public BlockBase.Info f() {
+        public Info f() {
             this.m = LootTables.a;
             return this;
         }
 
-        public BlockBase.Info a(Block block) {
-            this.m = block.r();
+        public Info a(Block block) {
+            this.m = block.q();
             return this;
         }
 
-        public BlockBase.Info g() {
+        public Info g() {
             this.o = true;
             return this;
         }
 
-        public BlockBase.Info a(BlockBase.d<EntityTypes<?>> blockbase_d) {
+        public Info a(BlockBase.d<EntityTypes<?>> blockbase_d) {
             this.p = blockbase_d;
             return this;
         }
 
-        public BlockBase.Info a(BlockBase.e blockbase_e) {
+        public Info a(BlockBase.e blockbase_e) {
             this.q = blockbase_e;
             return this;
         }
 
-        public BlockBase.Info b(BlockBase.e blockbase_e) {
+        public Info b(BlockBase.e blockbase_e) {
             this.r = blockbase_e;
             return this;
         }
 
-        public BlockBase.Info c(BlockBase.e blockbase_e) {
+        public Info c(BlockBase.e blockbase_e) {
             this.s = blockbase_e;
             return this;
         }
 
-        public BlockBase.Info d(BlockBase.e blockbase_e) {
+        public Info d(BlockBase.e blockbase_e) {
             this.t = blockbase_e;
             return this;
         }
 
-        public BlockBase.Info e(BlockBase.e blockbase_e) {
+        public Info e(BlockBase.e blockbase_e) {
             this.u = blockbase_e;
             return this;
         }
 
-        public BlockBase.Info h() {
+        public Info h() {
             this.h = true;
             return this;
         }
+
+        public Info a(MaterialMapColor materialmapcolor) {
+            this.b = (iblockdata) -> {
+                return materialmapcolor;
+            };
+            return this;
+        }
     }
 
     public static enum EnumRandomOffset {
diff --git a/src/main/java/net/minecraft/server/Chunk.java b/src/main/java/net/minecraft/server/Chunk.java
new file mode 100644
index 00000000..30225e7f
--- /dev/null
+++ b/src/main/java/net/minecraft/server/Chunk.java
@@ -0,0 +1,1009 @@
+package net.minecraft.server;
+
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.Maps;
+import com.google.common.collect.Sets;
+import com.google.common.collect.UnmodifiableIterator;
+import it.unimi.dsi.fastutil.ints.Int2ObjectMap;
+import it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap;
+import it.unimi.dsi.fastutil.longs.LongOpenHashSet;
+import it.unimi.dsi.fastutil.longs.LongSet;
+import it.unimi.dsi.fastutil.shorts.ShortList;
+import it.unimi.dsi.fastutil.shorts.ShortListIterator;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.Iterator;
+import java.util.Map;
+import java.util.Map.Entry;
+import java.util.Set;
+import java.util.function.Consumer;
+import java.util.function.Supplier;
+import java.util.stream.Stream;
+import java.util.stream.StreamSupport;
+import javax.annotation.Nullable;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+
+public class Chunk implements IChunkAccess {
+
+    private static final Logger LOGGER = LogManager.getLogger();
+    private static final ITickable c = new ITickable() {
+        @Override
+        public void a() {}
+
+        @Override
+        public boolean b() {
+            return true;
+        }
+
+        @Override
+        public BlockPosition c() {
+            return BlockPosition.ZERO;
+        }
+
+        @Override
+        public String d() {
+            return "<null>";
+        }
+    };
+    @Nullable
+    public static final ChunkSection a = null;
+    private final ChunkSection[] sections;
+    private BiomeStorage e;
+    private final Map<BlockPosition, NBTTagCompound> f;
+    private final Map<BlockPosition, Chunk.c> g;
+    public boolean loaded;
+    public final WorldServer world; // CraftBukkit - type
+    public final Map<HeightMap.Type, HeightMap> heightMap;
+    private final ChunkConverter k;
+    public final Map<BlockPosition, TileEntity> tileEntities;
+    private final Map<StructureGenerator<?>, StructureStart<?>> m;
+    private final Map<StructureGenerator<?>, LongSet> n;
+    private final ShortList[] o;
+    private TickList<Block> p;
+    private TickList<FluidType> q;
+    private volatile boolean r;
+    private long inhabitedTime;
+    @Nullable
+    private Supplier<PlayerChunk.State> t;
+    @Nullable
+    private Consumer<Chunk> u;
+    private final ChunkCoordIntPair loc;
+    private volatile boolean w;
+    private final Int2ObjectMap<cla> x;
+
+    public Chunk(World world, ChunkCoordIntPair chunkcoordintpair, BiomeStorage biomestorage) {
+        this(world, chunkcoordintpair, biomestorage, ChunkConverter.a, TickListEmpty.b(), TickListEmpty.b(), 0L, (ChunkSection[]) null, (Consumer) null);
+    }
+
+    public Chunk(World world, ChunkCoordIntPair chunkcoordintpair, BiomeStorage biomestorage, ChunkConverter chunkconverter, TickList<Block> ticklist, TickList<FluidType> ticklist1, long i, @Nullable ChunkSection[] achunksection, @Nullable Consumer<Chunk> consumer) {
+        this.f = Maps.newHashMap();
+        this.g = Maps.newHashMap();
+        this.heightMap = Maps.newEnumMap(HeightMap.Type.class);
+        this.tileEntities = Maps.newHashMap();
+        this.m = Maps.newHashMap();
+        this.n = Maps.newHashMap();
+        this.world = (WorldServer) world; // CraftBukkit - type
+        this.loc = chunkcoordintpair;
+        this.k = chunkconverter;
+        this.x = new Int2ObjectOpenHashMap();
+        HeightMap.Type[] aheightmap_type = HeightMap.Type.values();
+        int j = aheightmap_type.length;
+
+        for (int k = 0; k < j; ++k) {
+            HeightMap.Type heightmap_type = aheightmap_type[k];
+
+            if (ChunkStatus.FULL.h().contains(heightmap_type)) {
+                this.heightMap.put(heightmap_type, new HeightMap(this, heightmap_type));
+            }
+        }
+
+        this.e = biomestorage;
+        this.p = ticklist;
+        this.q = ticklist1;
+        this.inhabitedTime = i;
+        this.u = consumer;
+        this.sections = new ChunkSection[world.ah()];
+        if (achunksection != null) {
+            if (this.sections.length == achunksection.length) {
+                System.arraycopy(achunksection, 0, this.sections, 0, this.sections.length);
+            } else {
+                Chunk.LOGGER.warn("Could not set level chunk sections, array length is {} instead of {}", achunksection.length, this.sections.length);
+            }
+        }
+
+        this.o = new ShortList[world.ah()];
+        // CraftBukkit start
+        this.bukkitChunk = new org.bukkit.craftbukkit.CraftChunk(this);
+    }
+
+    public org.bukkit.Chunk bukkitChunk;
+    public org.bukkit.Chunk getBukkitChunk() {
+        return bukkitChunk;
+    }
+
+    public boolean mustNotSave;
+    public boolean needsDecoration;
+
+    private static final org.bukkit.craftbukkit.persistence.CraftPersistentDataTypeRegistry DATA_TYPE_REGISTRY = new org.bukkit.craftbukkit.persistence.CraftPersistentDataTypeRegistry();
+    public final org.bukkit.craftbukkit.persistence.CraftPersistentDataContainer persistentDataContainer = new org.bukkit.craftbukkit.persistence.CraftPersistentDataContainer(DATA_TYPE_REGISTRY);
+    // CraftBukkit end
+
+    public Chunk(WorldServer worldserver, ProtoChunk protochunk, @Nullable Consumer<Chunk> consumer) {
+        this(worldserver, protochunk.getPos(), protochunk.getBiomeIndex(), protochunk.q(), protochunk.n(), protochunk.p(), protochunk.getInhabitedTime(), protochunk.getSections(), consumer);
+        Iterator iterator = protochunk.y().values().iterator();
+
+        while (iterator.hasNext()) {
+            TileEntity tileentity = (TileEntity) iterator.next();
+
+            this.setTileEntity(tileentity);
+        }
+
+        this.f.putAll(protochunk.A());
+
+        for (int i = 0; i < protochunk.k().length; ++i) {
+            this.o[i] = protochunk.k()[i];
+        }
+
+        this.a(protochunk.g());
+        this.b(protochunk.w());
+        iterator = protochunk.e().iterator();
+
+        while (iterator.hasNext()) {
+            Entry<HeightMap.Type, HeightMap> entry = (Entry) iterator.next();
+
+            if (ChunkStatus.FULL.h().contains(entry.getKey())) {
+                this.a((HeightMap.Type) entry.getKey()).a(((HeightMap) entry.getValue()).a());
+            }
+        }
+
+        this.b(protochunk.s());
+        this.r = true;
+        this.needsDecoration = true; // CraftBukkit
+    }
+
+    @Override
+    public cla a(int i) {
+        return (cla) this.x.computeIfAbsent(i, (j) -> {
+            return new cky(this.world);
+        });
+    }
+
+    @Override
+    public HeightMap a(HeightMap.Type heightmap_type) {
+        return (HeightMap) this.heightMap.computeIfAbsent(heightmap_type, (heightmap_type1) -> {
+            return new HeightMap(this, heightmap_type1);
+        });
+    }
+
+    @Override
+    public Set<BlockPosition> c() {
+        Set<BlockPosition> set = Sets.newHashSet(this.f.keySet());
+
+        set.addAll(this.tileEntities.keySet());
+        return set;
+    }
+
+    @Override
+    public ChunkSection[] getSections() {
+        return this.sections;
+    }
+
+    @Override
+    public IBlockData getType(BlockPosition blockposition) {
+        int i = blockposition.getX();
+        int j = blockposition.getY();
+        int k = blockposition.getZ();
+
+        if (this.world.isDebugWorld()) {
+            IBlockData iblockdata = null;
+
+            if (j == 60) {
+                iblockdata = Blocks.BARRIER.getBlockData();
+            }
+
+            if (j == 70) {
+                iblockdata = ChunkProviderDebug.b(i, k);
+            }
+
+            return iblockdata == null ? Blocks.AIR.getBlockData() : iblockdata;
+        } else {
+            try {
+                int l = this.e(j);
+
+                if (l >= 0 && l < this.sections.length) {
+                    ChunkSection chunksection = this.sections[l];
+
+                    if (!ChunkSection.a(chunksection)) {
+                        return chunksection.getType(i & 15, j & 15, k & 15);
+                    }
+                }
+
+                return Blocks.AIR.getBlockData();
+            } catch (Throwable throwable) {
+                CrashReport crashreport = CrashReport.a(throwable, "Getting block state");
+                CrashReportSystemDetails crashreportsystemdetails = crashreport.a("Block being got");
+
+                crashreportsystemdetails.a("Location", () -> {
+                    return CrashReportSystemDetails.a(this, i, j, k);
+                });
+                throw new ReportedException(crashreport);
+            }
+        }
+    }
+
+    @Override
+    public Fluid getFluid(BlockPosition blockposition) {
+        return this.a(blockposition.getX(), blockposition.getY(), blockposition.getZ());
+    }
+
+    public Fluid a(int i, int j, int k) {
+        try {
+            int l = this.e(j);
+
+            if (l >= 0 && l < this.sections.length) {
+                ChunkSection chunksection = this.sections[l];
+
+                if (!ChunkSection.a(chunksection)) {
+                    return chunksection.b(i & 15, j & 15, k & 15);
+                }
+            }
+
+            return FluidTypes.EMPTY.h();
+        } catch (Throwable throwable) {
+            CrashReport crashreport = CrashReport.a(throwable, "Getting fluid state");
+            CrashReportSystemDetails crashreportsystemdetails = crashreport.a("Block being got");
+
+            crashreportsystemdetails.a("Location", () -> {
+                return CrashReportSystemDetails.a(this, i, j, k);
+            });
+            throw new ReportedException(crashreport);
+        }
+    }
+
+    // CraftBukkit start
+    @Nullable
+    @Override
+    public IBlockData setType(BlockPosition blockposition, IBlockData iblockdata, boolean flag) {
+        return this.setType(blockposition, iblockdata, flag, true);
+    }
+
+    @Nullable
+    public IBlockData setType(BlockPosition blockposition, IBlockData iblockdata, boolean flag, boolean doPlace) {
+        // CraftBukkit end
+        int i = blockposition.getY();
+        int j = this.e(i);
+        ChunkSection chunksection = this.sections[j];
+
+        if (chunksection == Chunk.a) {
+            if (iblockdata.isAir()) {
+                return null;
+            }
+
+            chunksection = new ChunkSection(SectionPosition.a(i));
+            this.sections[j] = chunksection;
+        }
+
+        boolean flag1 = chunksection.c();
+        int k = blockposition.getX() & 15;
+        int l = i & 15;
+        int i1 = blockposition.getZ() & 15;
+        IBlockData iblockdata1 = chunksection.setType(k, l, i1, iblockdata);
+
+        if (iblockdata1 == iblockdata) {
+            return null;
+        } else {
+            Block block = iblockdata.getBlock();
+
+            ((HeightMap) this.heightMap.get(HeightMap.Type.MOTION_BLOCKING)).a(k, i, i1, iblockdata);
+            ((HeightMap) this.heightMap.get(HeightMap.Type.MOTION_BLOCKING_NO_LEAVES)).a(k, i, i1, iblockdata);
+            ((HeightMap) this.heightMap.get(HeightMap.Type.OCEAN_FLOOR)).a(k, i, i1, iblockdata);
+            ((HeightMap) this.heightMap.get(HeightMap.Type.WORLD_SURFACE)).a(k, i, i1, iblockdata);
+            boolean flag2 = chunksection.c();
+
+            if (flag1 != flag2) {
+                this.world.getChunkProvider().getLightEngine().a(blockposition, flag2);
+            }
+
+            boolean flag3 = iblockdata1.isTileEntity();
+
+            if (!this.world.isClientSide) {
+                iblockdata1.remove(this.world, blockposition, iblockdata, flag);
+            } else if (!iblockdata1.a(block) && flag3) {
+                this.removeTileEntity(blockposition);
+            }
+
+            if (!chunksection.getType(k, l, i1).a(block)) {
+                return null;
+            } else {
+                // CraftBukkit - Don't place while processing the BlockPlaceEvent, unless it's a BlockContainer. Prevents blocks such as TNT from activating when cancelled.
+                if (!this.world.isClientSide && doPlace && (!this.world.captureBlockStates || block instanceof BlockTileEntity)) {
+                    iblockdata.onPlace(this.world, blockposition, iblockdata1, flag);
+                }
+
+                if (iblockdata.isTileEntity()) {
+                    TileEntity tileentity = this.a(blockposition, b.c);
+
+                    if (tileentity == null) {
+                        tileentity = ((ITileEntity) block).createTile(blockposition, iblockdata);
+                        if (tileentity != null) {
+                            this.b(tileentity);
+                        }
+                    } else {
+                        tileentity.b(iblockdata);
+                        this.f(tileentity);
+                    }
+                }
+
+                this.r = true;
+                return iblockdata1;
+            }
+        }
+    }
+
+    @Deprecated
+    @Override
+    public void a(Entity entity) {}
+
+    @Override
+    public void a(HeightMap.Type heightmap_type, long[] along) {
+        ((HeightMap) this.heightMap.get(heightmap_type)).a(along);
+    }
+
+    @Override
+    public int getHighestBlock(HeightMap.Type heightmap_type, int i, int j) {
+        return ((HeightMap) this.heightMap.get(heightmap_type)).a(i & 15, j & 15) - 1;
+    }
+
+    @Nullable
+    private TileEntity j(BlockPosition blockposition) {
+        IBlockData iblockdata = this.getType(blockposition);
+
+        return !iblockdata.isTileEntity() ? null : ((ITileEntity) iblockdata.getBlock()).createTile(blockposition, iblockdata);
+    }
+
+    @Nullable
+    @Override
+    public TileEntity getTileEntity(BlockPosition blockposition) {
+        return this.a(blockposition, b.c);
+    }
+
+    @Nullable
+    public TileEntity a(BlockPosition blockposition, b chunk_b) {
+        // CraftBukkit start
+        if (world.capturedTileEntities.containsKey(blockposition)) {
+            return world.capturedTileEntities.get(blockposition);
+        }
+        // CraftBukkit end
+        // CraftBukkit start
+        TileEntity tileentity = world.capturedTileEntities.get(blockposition);
+        if (tileentity == null) {
+            tileentity = (TileEntity) this.tileEntities.get(blockposition);
+        }
+        // CraftBukkit end
+
+        if (tileentity == null) {
+            NBTTagCompound nbttagcompound = (NBTTagCompound) this.f.remove(blockposition);
+
+            if (nbttagcompound != null) {
+                TileEntity tileentity1 = this.a(blockposition, nbttagcompound);
+
+                if (tileentity1 != null) {
+                    return tileentity1;
+                }
+            }
+        }
+
+        if (tileentity == null) {
+            if (chunk_b == b.a) {
+                tileentity = this.j(blockposition);
+                if (tileentity != null) {
+                    this.b(tileentity);
+                }
+            }
+        } else if (tileentity.isRemoved()) {
+            this.tileEntities.remove(blockposition);
+            return null;
+        }
+
+        return tileentity;
+    }
+
+    public void b(TileEntity tileentity) {
+        this.setTileEntity(tileentity);
+        if (this.F()) {
+            this.e(tileentity);
+            this.f(tileentity);
+        }
+
+    }
+
+    private boolean F() {
+        return this.loaded || this.world.g();
+    }
+
+    private boolean k(BlockPosition blockposition) {
+        return (this.world.g() || this.getState().isAtLeast(PlayerChunk.State.TICKING)) && this.world.getWorldBorder().a(blockposition);
+    }
+
+    @Override
+    public void setTileEntity(TileEntity tileentity) {
+        BlockPosition blockposition = tileentity.getPosition();
+
+        if (this.getType(blockposition).isTileEntity()) {
+            tileentity.setWorld(this.world);
+            tileentity.q();
+            TileEntity tileentity1 = (TileEntity) this.tileEntities.put(blockposition.immutableCopy(), tileentity);
+
+            if (tileentity1 != null && tileentity1 != tileentity) {
+                tileentity1.ap_();
+            }
+
+            // CraftBukkit start
+        } else {
+            System.out.println("Attempted to place a tile entity (" + tileentity + ") at " + tileentity.position.getX() + "," + tileentity.position.getY() + "," + tileentity.position.getZ()
+                + " (" + getType(blockposition) + ") where there was no entity tile!");
+            System.out.println("Chunk coordinates: " + (this.loc.x * 16) + "," + (this.loc.z * 16));
+            new Exception().printStackTrace();
+            // CraftBukkit end
+        }
+    }
+
+    @Override
+    public void a(NBTTagCompound nbttagcompound) {
+        this.f.put(new BlockPosition(nbttagcompound.getInt("x"), nbttagcompound.getInt("y"), nbttagcompound.getInt("z")), nbttagcompound);
+    }
+
+    @Nullable
+    @Override
+    public NBTTagCompound i(BlockPosition blockposition) {
+        TileEntity tileentity = this.getTileEntity(blockposition);
+        NBTTagCompound nbttagcompound;
+
+        if (tileentity != null && !tileentity.isRemoved()) {
+            nbttagcompound = tileentity.save(new NBTTagCompound());
+            nbttagcompound.setBoolean("keepPacked", false);
+            return nbttagcompound;
+        } else {
+            nbttagcompound = (NBTTagCompound) this.f.get(blockposition);
+            if (nbttagcompound != null) {
+                nbttagcompound = nbttagcompound.clone();
+                nbttagcompound.setBoolean("keepPacked", true);
+            }
+
+            return nbttagcompound;
+        }
+    }
+
+    @Override
+    public void removeTileEntity(BlockPosition blockposition) {
+        if (this.F()) {
+            TileEntity tileentity = (TileEntity) this.tileEntities.remove(blockposition);
+
+            if (tileentity != null) {
+                this.c(tileentity);
+                tileentity.ap_();
+            }
+        }
+
+        this.l(blockposition);
+    }
+
+    private <T extends TileEntity> void c(T t0) {
+        if (!this.world.isClientSide) {
+            Block block = t0.getBlock().getBlock();
+
+            if (block instanceof ITileEntity) {
+                clb clb = ((ITileEntity) block).a(this.world, t0);
+
+                if (clb != null) {
+                    int i = SectionPosition.a(t0.getPosition().getY());
+                    cla cla = this.a(i);
+
+                    cla.b(clb);
+                    if (cla.a()) {
+                        this.x.remove(i);
+                    }
+                }
+            }
+
+        }
+    }
+
+    private void l(BlockPosition blockposition) {
+        Chunk.c chunk_c = (Chunk.c) this.g.remove(blockposition);
+
+        if (chunk_c != null) {
+            chunk_c.a(Chunk.c);
+        }
+
+    }
+
+    public void addEntities() {
+        if (this.u != null) {
+            this.u.accept(this);
+            this.u = null;
+        }
+
+    }
+
+    // CraftBukkit start
+    public void loadCallback() {
+        org.bukkit.Server server = this.world.getServer();
+        if (server != null) {
+            /*
+             * If it's a new world, the first few chunks are generated inside
+             * the World constructor. We can't reliably alter that, so we have
+             * no way of creating a CraftWorld/CraftServer at that point.
+             */
+            server.getPluginManager().callEvent(new org.bukkit.event.world.ChunkLoadEvent(this.bukkitChunk, this.needsDecoration));
+
+            if (this.needsDecoration) {
+                this.needsDecoration = false;
+                java.util.Random random = new java.util.Random();
+                random.setSeed(world.getSeed());
+                long xRand = random.nextLong() / 2L * 2L + 1L;
+                long zRand = random.nextLong() / 2L * 2L + 1L;
+                random.setSeed((long) this.loc.x * xRand + (long) this.loc.z * zRand ^ world.getSeed());
+
+                org.bukkit.World world = this.world.getWorld();
+                if (world != null) {
+                    this.world.populating = true;
+                    try {
+                        for (org.bukkit.generator.BlockPopulator populator : world.getPopulators()) {
+                            populator.populate(world, random, bukkitChunk);
+                        }
+                    } finally {
+                        this.world.populating = false;
+                    }
+                }
+                server.getPluginManager().callEvent(new org.bukkit.event.world.ChunkPopulateEvent(bukkitChunk));
+            }
+        }
+    }
+
+    public void unloadCallback() {
+        org.bukkit.Server server = this.world.getServer();
+        org.bukkit.event.world.ChunkUnloadEvent unloadEvent = new org.bukkit.event.world.ChunkUnloadEvent(this.bukkitChunk, this.isNeedsSaving());
+        server.getPluginManager().callEvent(unloadEvent);
+        // note: saving can be prevented, but not forced if no saving is actually required
+        this.mustNotSave = !unloadEvent.isSaveChunk();
+    }
+    // CraftBukkit end
+
+    public void markDirty() {
+        this.r = true;
+    }
+
+    public boolean isEmpty() {
+        return false;
+    }
+
+    @Override
+    public ChunkCoordIntPair getPos() {
+        return this.loc;
+    }
+
+    private void d(TileEntity tileentity) {
+        tileentity.ap_();
+        this.g.remove(tileentity.getPosition());
+    }
+
+    @Override
+    public BiomeStorage getBiomeIndex() {
+        return this.e;
+    }
+
+    public void setLoaded(boolean flag) {
+        this.loaded = flag;
+    }
+
+    public World getWorld() {
+        return this.world;
+    }
+
+    @Override
+    public Collection<Entry<HeightMap.Type, HeightMap>> e() {
+        return Collections.unmodifiableSet(this.heightMap.entrySet());
+    }
+
+    public Map<BlockPosition, TileEntity> getTileEntities() {
+        return this.tileEntities;
+    }
+
+    @Override
+    public NBTTagCompound h(BlockPosition blockposition) {
+        return (NBTTagCompound) this.f.get(blockposition);
+    }
+
+    @Override
+    public Stream<BlockPosition> l() {
+        return StreamSupport.stream(BlockPosition.b(this.loc.d(), this.getMinBuildHeight(), this.loc.e(), this.loc.f(), this.getMaxBuildHeight() - 1, this.loc.g()).spliterator(), false).filter((blockposition) -> {
+            return this.getType(blockposition).f() != 0;
+        });
+    }
+
+    @Override
+    public TickList<Block> n() {
+        return this.p;
+    }
+
+    @Override
+    public TickList<FluidType> p() {
+        return this.q;
+    }
+
+    @Override
+    public void setNeedsSaving(boolean flag) {
+        this.r = flag;
+    }
+
+    @Override
+    public boolean isNeedsSaving() {
+        return this.r && !this.mustNotSave; // CraftBukkit
+    }
+
+    @Nullable
+    @Override
+    public StructureStart<?> a(StructureGenerator<?> structuregenerator) {
+        return (StructureStart) this.m.get(structuregenerator);
+    }
+
+    @Override
+    public void a(StructureGenerator<?> structuregenerator, StructureStart<?> structurestart) {
+        this.m.put(structuregenerator, structurestart);
+    }
+
+    @Override
+    public Map<StructureGenerator<?>, StructureStart<?>> g() {
+        return this.m;
+    }
+
+    @Override
+    public void a(Map<StructureGenerator<?>, StructureStart<?>> map) {
+        this.m.clear();
+        this.m.putAll(map);
+    }
+
+    @Override
+    public LongSet b(StructureGenerator<?> structuregenerator) {
+        return (LongSet) this.n.computeIfAbsent(structuregenerator, (structuregenerator1) -> {
+            return new LongOpenHashSet();
+        });
+    }
+
+    @Override
+    public void a(StructureGenerator<?> structuregenerator, long i) {
+        ((LongSet) this.n.computeIfAbsent(structuregenerator, (structuregenerator1) -> {
+            return new LongOpenHashSet();
+        })).add(i);
+    }
+
+    @Override
+    public Map<StructureGenerator<?>, LongSet> w() {
+        return this.n;
+    }
+
+    @Override
+    public void b(Map<StructureGenerator<?>, LongSet> map) {
+        this.n.clear();
+        this.n.putAll(map);
+    }
+
+    @Override
+    public long getInhabitedTime() {
+        return this.inhabitedTime;
+    }
+
+    @Override
+    public void setInhabitedTime(long i) {
+        this.inhabitedTime = i;
+    }
+
+    public void A() {
+        ChunkCoordIntPair chunkcoordintpair = this.getPos();
+
+        for (int i = 0; i < this.o.length; ++i) {
+            if (this.o[i] != null) {
+                ShortListIterator shortlistiterator = this.o[i].iterator();
+
+                while (shortlistiterator.hasNext()) {
+                    Short oshort = (Short) shortlistiterator.next();
+                    BlockPosition blockposition = ProtoChunk.a(oshort, this.g(i), chunkcoordintpair);
+                    IBlockData iblockdata = this.getType(blockposition);
+                    IBlockData iblockdata1 = Block.b(iblockdata, (GeneratorAccess) this.world, blockposition);
+
+                    this.world.setTypeAndData(blockposition, iblockdata1, 20);
+                }
+
+                this.o[i].clear();
+            }
+        }
+
+        this.B();
+        UnmodifiableIterator unmodifiableiterator = ImmutableList.copyOf(this.f.keySet()).iterator();
+
+        while (unmodifiableiterator.hasNext()) {
+            BlockPosition blockposition1 = (BlockPosition) unmodifiableiterator.next();
+
+            this.getTileEntity(blockposition1);
+        }
+
+        this.f.clear();
+        this.k.a(this);
+    }
+
+    @Nullable
+    private TileEntity a(BlockPosition blockposition, NBTTagCompound nbttagcompound) {
+        IBlockData iblockdata = this.getType(blockposition);
+        TileEntity tileentity;
+
+        if ("DUMMY".equals(nbttagcompound.getString("id"))) {
+            if (iblockdata.isTileEntity()) {
+                tileentity = ((ITileEntity) iblockdata.getBlock()).createTile(blockposition, iblockdata);
+            } else {
+                tileentity = null;
+                Chunk.LOGGER.warn("Tried to load a DUMMY block entity @ {} but found not block entity block {} at location", blockposition, iblockdata);
+            }
+        } else {
+            tileentity = TileEntity.create(blockposition, iblockdata, nbttagcompound);
+        }
+
+        if (tileentity != null) {
+            tileentity.setWorld(this.world);
+            this.b(tileentity);
+        } else {
+            Chunk.LOGGER.warn("Tried to load a block entity for block {} but failed at location {}", iblockdata, blockposition);
+        }
+
+        return tileentity;
+    }
+
+    @Override
+    public ChunkConverter q() {
+        return this.k;
+    }
+
+    @Override
+    public ShortList[] k() {
+        return this.o;
+    }
+
+    public void B() {
+        if (this.p instanceof ProtoChunkTickList) {
+            ((ProtoChunkTickList<Block>) this.p).a(this.world.getBlockTickList(), (blockposition) -> { // CraftBukkit - decompile error
+                return this.getType(blockposition).getBlock();
+            });
+            this.p = TickListEmpty.b();
+        } else if (this.p instanceof TickListChunk) {
+            ((TickListChunk) this.p).a(this.world.getBlockTickList());
+            this.p = TickListEmpty.b();
+        }
+
+        if (this.q instanceof ProtoChunkTickList) {
+            ((ProtoChunkTickList<FluidType>) this.q).a(this.world.getFluidTickList(), (blockposition) -> { // CraftBukkit - decompile error
+                return this.getFluid(blockposition).getType();
+            });
+            this.q = TickListEmpty.b();
+        } else if (this.q instanceof TickListChunk) {
+            ((TickListChunk) this.q).a(this.world.getFluidTickList());
+            this.q = TickListEmpty.b();
+        }
+
+    }
+
+    public void a(WorldServer worldserver) {
+        if (this.p == TickListEmpty.<Block>b()) { // CraftBukkit - decompile error
+            this.p = new TickListChunk<>(IRegistry.BLOCK::getKey, worldserver.getBlockTickList().a(this.loc, true, false), worldserver.getTime());
+            this.setNeedsSaving(true);
+        }
+
+        if (this.q == TickListEmpty.<FluidType>b()) { // CraftBukkit - decompile error
+            this.q = new TickListChunk<>(IRegistry.FLUID::getKey, worldserver.getFluidTickList().a(this.loc, true, false), worldserver.getTime());
+            this.setNeedsSaving(true);
+        }
+
+    }
+
+    @Override
+    public int getMinBuildHeight() {
+        return this.world.getMinBuildHeight();
+    }
+
+    @Override
+    public int getHeight() {
+        return this.world.getHeight();
+    }
+
+    @Override
+    public ChunkStatus getChunkStatus() {
+        return ChunkStatus.FULL;
+    }
+
+    public PlayerChunk.State getState() {
+        return this.t == null ? PlayerChunk.State.BORDER : (PlayerChunk.State) this.t.get();
+    }
+
+    public void a(Supplier<PlayerChunk.State> supplier) {
+        this.t = supplier;
+    }
+
+    @Override
+    public boolean s() {
+        return this.w;
+    }
+
+    @Override
+    public void b(boolean flag) {
+        this.w = flag;
+        this.setNeedsSaving(true);
+    }
+
+    public void C() {
+        this.tileEntities.values().forEach(this::d);
+    }
+
+    public void D() {
+        this.tileEntities.values().forEach((tileentity) -> {
+            this.e(tileentity);
+            this.f(tileentity);
+        });
+    }
+
+    private <T extends TileEntity> void e(T t0) {
+        if (!this.world.isClientSide) {
+            Block block = t0.getBlock().getBlock();
+
+            if (block instanceof ITileEntity) {
+                clb clb = ((ITileEntity) block).a(this.world, t0);
+
+                if (clb != null) {
+                    cla cla = this.a(SectionPosition.a(t0.getPosition().getY()));
+
+                    cla.a(clb);
+                }
+            }
+
+        }
+    }
+
+    private <T extends TileEntity> void f(T t0) {
+        IBlockData iblockdata = t0.getBlock();
+        TileEntityTicker<T> tileentityticker = (TileEntityTicker<T>) iblockdata.a(this.world, t0.getTileType()); // CraftBukkit - decompile error
+
+        if (tileentityticker == null) {
+            this.l(t0.getPosition());
+        } else {
+            this.g.compute(t0.getPosition(), (blockposition, chunk_c) -> {
+                ITickable itickable = this.a(t0, tileentityticker);
+
+                if (chunk_c != null) {
+                    chunk_c.a(itickable);
+                    return chunk_c;
+                } else if (this.F()) {
+                    Chunk.c chunk_c1 = new c(itickable);
+
+                    this.world.a((ITickable) chunk_c1);
+                    return chunk_c1;
+                } else {
+                    return null;
+                }
+            });
+        }
+
+    }
+
+    private <T extends TileEntity> ITickable a(T t0, TileEntityTicker<T> tileentityticker) {
+        return new EnumTileEntityState<>(t0, tileentityticker);
+    }
+
+    class c implements ITickable {
+
+        private ITickable b;
+
+        private c(ITickable itickable) {
+            this.b = itickable;
+        }
+
+        private void a(ITickable itickable) {
+            this.b = itickable;
+        }
+
+        @Override
+        public void a() {
+            this.b.a();
+        }
+
+        @Override
+        public boolean b() {
+            return this.b.b();
+        }
+
+        @Override
+        public BlockPosition c() {
+            return this.b.c();
+        }
+
+        @Override
+        public String d() {
+            return this.b.d();
+        }
+
+        public String toString() {
+            return this.b.toString() + " <wrapped>";
+        }
+    }
+
+    class EnumTileEntityState<T extends TileEntity> implements ITickable {
+
+        private final T QUEUED;
+        private final TileEntityTicker<T> CHECK;
+        private boolean d;
+
+        private EnumTileEntityState(TileEntity tileentity, TileEntityTicker tileentityticker) {
+            this.QUEUED = (T) tileentity; // CraftBukkit - decompile error
+            this.CHECK = tileentityticker;
+        }
+
+        @Override
+        public void a() {
+            if (!this.QUEUED.isRemoved() && this.QUEUED.hasWorld()) {
+                BlockPosition blockposition = this.QUEUED.getPosition();
+
+                if (Chunk.this.k(blockposition)) {
+                    try {
+                        GameProfilerFiller gameprofilerfiller = Chunk.this.world.getMethodProfiler();
+
+                        gameprofilerfiller.a(this::d);
+                        IBlockData iblockdata = Chunk.this.getType(blockposition);
+
+                        if (this.QUEUED.getTileType().isValidBlock(iblockdata)) {
+                            this.CHECK.tick(Chunk.this.world, this.QUEUED.getPosition(), iblockdata, this.QUEUED);
+                            this.d = false;
+                        } else if (!this.d) {
+                            this.d = true;
+                            Chunk.LOGGER.warn("Block entity {} @ {} state {} invalid for ticking:", new org.apache.logging.log4j.util.Supplier[]{this::d, this::c, () -> {
+                                        return iblockdata;
+                                    }});
+                        }
+
+                        gameprofilerfiller.exit();
+                    } catch (Throwable throwable) {
+                        CrashReport crashreport = CrashReport.a(throwable, "Ticking block entity");
+                        CrashReportSystemDetails crashreportsystemdetails = crashreport.a("Block entity being ticked");
+
+                        this.QUEUED.a(crashreportsystemdetails);
+                        throw new ReportedException(crashreport);
+                    }
+                }
+            }
+
+        }
+
+        @Override
+        public boolean b() {
+            return this.QUEUED.isRemoved();
+        }
+
+        @Override
+        public BlockPosition c() {
+            return this.QUEUED.getPosition();
+        }
+
+        @Override
+        public String d() {
+            return TileEntityTypes.a(this.QUEUED.getTileType()).toString();
+        }
+
+        public String toString() {
+            return "Level ticker for " + this.d() + "@" + this.c();
+        }
+    }
+
+    public static enum b {
+
+        a, b, c;
+
+        private b() {}
+    }
+}
diff --git a/src/main/java/net/minecraft/server/JsonList.java b/src/main/java/net/minecraft/server/JsonList.java
new file mode 100644
index 00000000..de4f9507
--- /dev/null
+++ b/src/main/java/net/minecraft/server/JsonList.java
@@ -0,0 +1,203 @@
+package net.minecraft.server;
+
+import com.google.common.collect.Lists;
+import com.google.common.collect.Maps;
+import com.google.common.io.Files;
+import com.google.gson.Gson;
+import com.google.gson.GsonBuilder;
+import com.google.gson.JsonArray;
+import com.google.gson.JsonElement;
+import com.google.gson.JsonObject;
+import java.io.BufferedReader;
+import java.io.BufferedWriter;
+import java.io.File;
+import java.io.IOException;
+import java.nio.charset.StandardCharsets;
+import java.util.Collection;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import javax.annotation.Nullable;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+
+public abstract class JsonList<K, V extends JsonListEntry<K>> {
+
+    protected static final Logger LOGGER = LogManager.getLogger();
+    private static final Gson b = (new GsonBuilder()).setPrettyPrinting().create();
+    private final File c;
+    private final Map<String, V> d = Maps.newHashMap();
+
+    public JsonList(File file) {
+        this.c = file;
+    }
+
+    public File b() {
+        return this.c;
+    }
+
+    public void add(V v0) {
+        this.d.put(this.a(v0.getKey()), v0);
+
+        try {
+            this.save();
+        } catch (IOException ioexception) {
+            JsonList.LOGGER.warn("Could not save the list after adding a user.", ioexception);
+        }
+
+    }
+
+    @Nullable
+    public V get(K k0) {
+        this.g();
+        return (V) this.d.get(this.a(k0)); // CraftBukkit - fix decompile error
+    }
+
+    public void remove(K k0) {
+        this.d.remove(this.a(k0));
+
+        try {
+            this.save();
+        } catch (IOException ioexception) {
+            JsonList.LOGGER.warn("Could not save the list after removing a user.", ioexception);
+        }
+
+    }
+
+    public void b(JsonListEntry<K> jsonlistentry) {
+        this.remove(jsonlistentry.getKey());
+    }
+
+    public String[] getEntries() {
+        return (String[]) this.d.keySet().toArray(new String[0]);
+    }
+
+    // CraftBukkit start
+    public Collection<V> getValues() {
+        return this.d.values();
+    }
+    // CraftBukkit end
+
+    public boolean isEmpty() {
+        return this.d.size() < 1;
+    }
+
+    protected String a(K k0) {
+        return k0.toString();
+    }
+
+    protected boolean d(K k0) {
+        return this.d.containsKey(this.a(k0));
+    }
+
+    private void g() {
+        List<K> list = Lists.newArrayList();
+        Iterator iterator = this.d.values().iterator();
+
+        while (iterator.hasNext()) {
+            V v0 = (V) iterator.next(); // CraftBukkit - decompile error
+
+            if (v0.hasExpired()) {
+                list.add(v0.getKey());
+            }
+        }
+
+        iterator = list.iterator();
+
+        while (iterator.hasNext()) {
+            K k0 = (K) iterator.next(); // CraftBukkit - decompile error
+
+            this.d.remove(this.a(k0));
+        }
+
+    }
+
+    protected abstract JsonListEntry<K> a(JsonObject jsonobject);
+
+    public Collection<V> d() {
+        return this.d.values();
+    }
+
+    public void save() throws IOException {
+        JsonArray jsonarray = new JsonArray();
+
+        this.d.values().stream().map((jsonlistentry) -> {
+            JsonObject jsonobject = new JsonObject();
+
+            jsonlistentry.getClass();
+            return (JsonObject) SystemUtils.a(jsonobject, jsonlistentry::a); // CraftBukkit - decompile error
+        }).forEach(jsonarray::add);
+        BufferedWriter bufferedwriter = Files.newWriter(this.c, StandardCharsets.UTF_8);
+        Throwable throwable = null;
+
+        try {
+            JsonList.b.toJson(jsonarray, bufferedwriter);
+        } catch (Throwable throwable1) {
+            throwable = throwable1;
+            throw throwable1;
+        } finally {
+            if (bufferedwriter != null) {
+                if (throwable != null) {
+                    try {
+                        bufferedwriter.close();
+                    } catch (Throwable throwable2) {
+                        throwable.addSuppressed(throwable2);
+                    }
+                } else {
+                    bufferedwriter.close();
+                }
+            }
+
+        }
+
+    }
+
+    public void load() throws IOException {
+        if (this.c.exists()) {
+            BufferedReader bufferedreader = Files.newReader(this.c, StandardCharsets.UTF_8);
+            Throwable throwable = null;
+
+            try {
+                JsonArray jsonarray = (JsonArray) JsonList.b.fromJson(bufferedreader, JsonArray.class);
+
+                this.d.clear();
+                Iterator iterator = jsonarray.iterator();
+
+                while (iterator.hasNext()) {
+                    JsonElement jsonelement = (JsonElement) iterator.next();
+                    JsonObject jsonobject = ChatDeserializer.m(jsonelement, "entry");
+                    JsonListEntry<K> jsonlistentry = this.a(jsonobject);
+
+                    if (jsonlistentry.getKey() != null) {
+                        this.d.put(this.a(jsonlistentry.getKey()), (V) jsonlistentry); // CraftBukkit - fix decompile error
+                    }
+                }
+            // Spigot Start
+            } catch ( com.google.gson.JsonParseException ex )
+            {
+                org.bukkit.Bukkit.getLogger().log( java.util.logging.Level.WARNING, "Unable to read file " + this.c + ", backing it up to {0}.backup and creating new copy.", ex );
+                File backup = new File( this.c + ".backup" );
+                this.c.renameTo( backup );
+                this.c.delete();
+            // Spigot End
+            } catch (Throwable throwable1) {
+                throwable = throwable1;
+                throw throwable1;
+            } finally {
+                if (bufferedreader != null) {
+                    if (throwable != null) {
+                        try {
+                            bufferedreader.close();
+                        } catch (Throwable throwable2) {
+                            throwable.addSuppressed(throwable2);
+                        }
+                    } else {
+                        bufferedreader.close();
+                    }
+                }
+
+            }
+
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/server/UserCache.java b/src/main/java/net/minecraft/server/UserCache.java
index 04a6bf30..ce81aaf3 100644
--- a/src/main/java/net/minecraft/server/UserCache.java
+++ b/src/main/java/net/minecraft/server/UserCache.java
@@ -219,6 +219,11 @@ public class UserCache {
             return arraylist1;
         } catch (FileNotFoundException filenotfoundexception) {
             ;
+        // Spigot Start
+        } catch (com.google.gson.JsonSyntaxException ex) {
+            JsonList.LOGGER.warn( "Usercache.json is corrupted or has bad formatting. Deleting it to prevent further issues." );
+            this.g.delete();
+        // Spigot End
         } catch (JsonParseException | IOException ioexception) {
             UserCache.LOGGER.warn("Failed to load profile cache {}", this.g, ioexception);
         }
-- 
2.21.0.windows.1

